["```py\nDataSetIterator iter = new MnistDataSetIterator(miniBatchSize,numOfExamples,binarize);\n```", "```py\nDataSet ds = iter.next();\n SplitTestAndTrain split = ds.splitTestAndTrain(numHoldOut, new Random(12345));\n```", "```py\nList<INDArray> featuresTrain = new ArrayList<>();\n List<INDArray> featuresTest = new ArrayList<>();\n List<INDArray> labelsTest = new ArrayList<>();\n```", "```py\nfeaturesTrain.add(split.getTrain().getFeatures());\n DataSet dsTest = split.getTest();\n featuresTest.add(dsTest.getFeatures());\n INDArray indexes = Nd4j.argMax(dsTest.getLabels(),1);\n labelsTest.add(indexes);\n```", "```py\nwhile(iter.hasNext()){\n DataSet ds = iter.next();\n SplitTestAndTrain split = ds.splitTestAndTrain(80, new Random(12345)); // 80/20 split (from miniBatch = 100)\n featuresTrain.add(split.getTrain().getFeatures());\n DataSet dsTest = split.getTest();\n featuresTest.add(dsTest.getFeatures());\n INDArray indexes = Nd4j.argMax(dsTest.getLabels(),1);\n labelsTest.add(indexes);\n }\n```", "```py\nNd4j.argMax(dsTest.getLabels(),1);\n```", "```py\nNeuralNetConfiguration.Builder configBuilder = new NeuralNetConfiguration.Builder();\n configBuilder.seed(12345);\n configBuilder.weightInit(WeightInit.XAVIER);\n configBuilder.updater(new AdaGrad(0.05));\n configBuilder.activation(Activation.RELU);\n configBuilder.l2(l2RegCoefficient);\n NeuralNetConfiguration.ListBuilder builder = configBuilder.list();\n```", "```py\nbuilder.layer(new DenseLayer.Builder().nIn(784).nOut(250).build());\n builder.layer(new DenseLayer.Builder().nIn(250).nOut(10).build());\n```", "```py\nconfigBuilder.updater(new AdaGrad(learningRate));\n```", "```py\nOutputLayer outputLayer = new OutputLayer.Builder().nIn(250).nOut(784)\n .lossFunction(LossFunctions.LossFunction.MSE)\n .build();\n```", "```py\nbuilder.layer(new OutputLayer.Builder().nIn(250).nOut(784)\n .lossFunction(LossFunctions.LossFunction.MSE)\n .build());\n```", "```py\n Input -> Encoded Input -> Decode -> Output\n```", "```py\nint nEpochs = 30;\n for( int epoch=0; epoch<nEpochs; epoch++ ){\n for(INDArray data : featuresTrain){\n net.fit(data,data);\n }\n }\n```", "```py\nfor(INDArray data : featuresTrain){\n net.fit(data,data);\n}\n```", "```py\nMap<Integer,List<Pair<Double,INDArray>>> listsByDigit = new HashMap<>();\n```", "```py\nfor( int i=0; i<featuresTest.size(); i++ ){\n INDArray testData = featuresTest.get(i);\n INDArray labels = labelsTest.get(i);\n for( int j=0; j<testData.rows(); j++){\n INDArray example = testData.getRow(j, true);\n int digit = (int)labels.getDouble(j);\n double score = net.score(new DataSet(example,example));\n // Add (score, example) pair to the appropriate list\n List digitAllPairs = listsByDigit.get(digit);\n digitAllPairs.add(new Pair<>(score, example));\n }\n }\n```", "```py\nComparator<Pair<Double, INDArray>> sortComparator = new Comparator<Pair<Double, INDArray>>() {\n @Override\n public int compare(Pair<Double, INDArray> o1, Pair<Double, INDArray> o2) {\n return Double.compare(o1.getLeft(),o2.getLeft());\n }\n };\n```", "```py\nfor(List<Pair<Double, INDArray>> digitAllPairs : listsByDigit.values()){\n Collections.sort(digitAllPairs, sortComparator);\n }\n```", "```py\nList<INDArray> best = new ArrayList<>(50);\n List<INDArray> worst = new ArrayList<>(50);\n for( int i=0; i<10; i++ ){\n List<Pair<Double,INDArray>> list = listsByDigit.get(i);\n for( int j=0; j<5; j++ ){\n best.add(list.get(j).getRight());\n worst.add(list.get(list.size()-j-1).getRight());\n }\n }\n```", "```py\n//Visualize the best and worst digits\n MNISTVisualizer bestVisualizer = new MNISTVisualizer(imageScale,best,\"Best (Low Rec. Error)\");\n bestVisualizer.visualize();\n MNISTVisualizer worstVisualizer = new MNISTVisualizer(imageScale,worst,\"Worst (High Rec. Error)\");\n worstVisualizer.visualize();\n```", "```py\ndouble score = net.score(new DataSet(example,example));\n```", "```py\nFile modelFile = new File(\"model.zip\");\n ModelSerializer.writeModel(multiLayerNetwork,file, saveUpdater);\n```", "```py\nModelSerializer.addNormalizerToModel(modelFile,dataNormalization);\n```", "```py\nFile locationToSave = new File(\"MyMultiLayerNetwork.zip\");\n   model.save(locationToSave, saveUpdater);\n```", "```py\nModelSerializer.restoreMultiLayerNetwork(new File(\"model.zip\"));\n```", "```py\nMultiLayerNetwork restored = MultiLayerNetwork.load(locationToSave, saveUpdater);\n```"]