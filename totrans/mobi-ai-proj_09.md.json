["```py\nclass sklearn.pipeline.Pipeline(steps, memory=None)\n```", "```py\nclass sklearn.svm.LinearSVC(penalty=’l2’, loss=’squared_hinge’, dual=True, tol=0.0001, C=1.0, multi_class=’ovr’, fit_intercept=True, intercept_scaling=1, class_weight=None, verbose=0, random_state=None, max_iter=1000)\n```", "```py\nimport re\nimport coremltools\nimport pandas as pd\nimport numpy as np\nfrom nltk.corpus import stopwords\nfrom nltk import word_tokenize\nfrom string import punctuation\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\n```", "```py\n# Read reviews from CSV\nreviews = pd.read_csv('epinions.csv')\nreviews = reviews.as_matrix()[:, :]\nprint \"%d reviews in dataset\" % len(reviews)\n```", "```py\n# Create features\ndef features(sentence):\n stop_words = stopwords.words('english') + list(punctuation)\n words = word_tokenize(sentence)\n words = [w.lower() for w in words]\n filtered = [w for w in words if w not in stop_words and not    \n             w.isdigit()]\n words = {}\n for word in filtered:\n     if word in words:\n         words[word] += 1.0\n     else:\n         words[word] = 1.0\n return words\n```", "```py\n# Vectorize the features function\nfeatures = np.vectorize(features)\n# Extract the features for the whole dataset\nX = features(reviews[:, 1])\n# Set the targets\ny = reviews[:, 0]\n```", "```py\n# Do grid search\nclf = Pipeline([(\"dct\", DictVectorizer()), (\"svc\", LinearSVC())])\nparams = {\n \"svc__C\": [1e15, 1e13, 1e11, 1e9, 1e7, 1e5, 1e3, 1e1, 1e-1, 1e-3,  \n            1e-5]\n}\ngs = GridSearchCV(clf, params, cv=10, verbose=2, n_jobs=-1)\ngs.fit(X, y)\nmodel = gs.best_estimator_\n```", "```py\n# Print results\nprint model.score(X, y)\nprint \"Optimized parameters: \", model\nprint \"Best CV score: \", gs.best*score*\n```", "```py\n# Convert to CoreML model\ncoreml_model = coremltools.converters.sklearn.convert(model)\ncoreml_model.short_description = 'Sentiment analysis AI projects.'\ncoreml_model.input_description['input'] = 'Features extracted from \n                                           the text.'\ncoreml_model.output_description['classLabel'] = 'The most likely polarity (positive or negative or neutral), for the given input.'\ncoreml_model.output_description['classProbability'] = 'The probabilities for each class label, for the given input.'\ncoreml_model.save('Sentiment.mlmodel')\n```", "```py\n//initialize Ui components\nprivate lazy var textView: UITextView = self.makeTextView()   private lazy var accessoryView = UIView()\nprivate lazy var resultLabel: UILabel = self.makeResultLabel()    private lazy var clearButton: UIButton = self.makeClearButton()\nprivate let padding = CGFloat(16)\nprivate var textViewBottomConstraint: NSLayoutConstraint?\n```", "```py\nenum Sentiment {\n     case neutral\n     case positive\n     case negative\n    var emoji: String {\n        switch self {\n         case .neutral:\n         return \"\"\n         case .positive:\n         return \"\"\n         case .negative:\n         return \"\"\n     }\n }\n    var color: UIColor? {\n         switch self {\n             case .neutral:\n             return UIColor(named: \"NeutralColor\")\n             case .positive:\n             return UIColor(named: \"PositiveColor\")\n             case .negative:\n             return UIColor(named: \"NegativeColor\")\n         }\n     }\n}\n```", "```py\n  //variables initialization\n  private let options: NSLinguisticTagger.Options = [.omitWhitespace, .omitPunctuation, .omitOther]\n  private lazy var tagger: NSLinguisticTagger = .init(\n    tagSchemes: NSLinguisticTagger.availableTagSchemes(forLanguage: \"en\"),\n    options: Int(self.options.rawValue)\n  )\n\nprivate extension ClassificationService {\n func features(from text: String) -> [String: Double] {\n     var wordCounts = [String: Double]()\n     tagger.string = text\n     let range = NSRange(location: 0, length: text.utf16.count)\n     // let's tokenize the input text and count the sentence\n     tagger.enumerateTags(in: range, scheme: .nameType, options: options) { _, tokenRange, _, _ in\n         let token = (text as NSString).substring(with: tokenRange).lowercased()\n         // Skip small words\n         guard token.count >= 3 else {\n         return\n         }\n         if let value = wordCounts[token] {\n             wordCounts[token] = value + 1.0\n         } else {\n             wordCounts[token] = 1.0\n         }\n     }\n return wordCounts\n }\n```", "```py\nfunc predictSentiment(from text: String) -> Sentiment {\n do {\n let inputFeatures = features(from: text)\n // Make prediction only with 2 or more words\n guard inputFeatures.count > 1 else {\n throw Error.featuresMissing\n }\n let output = try model.prediction(input: inputFeatures)\n     switch output.classLabel {\n         case \"Positive\":\n             return .positive\n         case \"Negative\":\n             return .negative\n         default:\n             return .neutral\n             }\n } catch {\n     return .neutral\n     }\n }\n}\n```", "```py\noverride func viewDidLoad() {\n super.viewDidLoad()\n title = \"Sentiment Analysis\".uppercased()\n view.backgroundColor = UIColor(named: \"BackgroundColor\")\n view.addSubview(textView)\n accessoryView.frame = CGRect(x: 0, y: 0, width: view.frame.size.width, height: 60)\n accessoryView.addSubview(resultLabel)\n accessoryView.addSubview(clearButton)\n textView.inputAccessoryView = accessoryView\nNotificationCenter.default.addObserver(\n self,\n selector: #selector(keyboardDidShow(notification:)),\n name: .UIKeyboardDidShow,\n object: nil\n )\n setupConstraints()\n //Show default sentiment as neutral\n show(sentiment: .neutral)\n }\n```", "```py\nfunc setupConstraints() {\n //input textview \n textView.translatesAutoresizingMaskIntoConstraints = false\n textView.topAnchor.constraint(equalTo: view.topAnchor, constant: 80).isActive = true\n textView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding).isActive = true\n textView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -padding).isActive = true\n textViewBottomConstraint = textView.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n textViewBottomConstraint?.isActive = true\n\n//result label at the bottom\n resultLabel.translatesAutoresizingMaskIntoConstraints = false\n resultLabel.centerXAnchor.constraint(equalTo: accessoryView.centerXAnchor).isActive = true\n resultLabel.centerYAnchor.constraint(equalTo: accessoryView.centerYAnchor).isActive = true\n\n//Clear button at the bottom right\n clearButton.translatesAutoresizingMaskIntoConstraints = false\n clearButton.trailingAnchor.constraint(\n equalTo: accessoryView.trailingAnchor,\n constant: -padding\n ).isActive = true\n clearButton.centerYAnchor.constraint(equalTo: accessoryView.centerYAnchor).isActive = true\n }\n```", "```py\nprivate func show(sentiment: Sentiment) {                                  accessoryView.backgroundColor = sentiment.color    \n         resultLabel.text = sentiment.emoji\n }\n```"]