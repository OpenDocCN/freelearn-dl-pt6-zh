- en: Caffe2 at the Edge and in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In chapters 1-6 of this book, we have learned how to install and use Caffe2
    to train DL neural networks and how to work with other popular DL frameworks.
    We have also learnt how to deploy our trained Caffe2 models on popular inference
    engines. In this last chapter, we will look at applications of Caffe2 that exploit
    its ability to scale from tiny edge devices such as the Raspberry Pi to running
    on containers in the cloud. We will also look at visualizing Caffe2 models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Caffe2 at the edge on Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffe2 in the cloud using containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffe2 model visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffe2 at the edge on Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a lot of interest in using deep learning at the edge. This is the
    application of deep learning to compute solutions on or near the devices that
    capture data using sensors and cameras. An alternative solution to deep learning
    at the edge is to capture edge data and send it to in the cloud for processing.
    But, deep learning at the edge has the advantage of lower latency and higher security.
    Devices at the edge are typically cheap, have a small form factor and use less
    power, and their processors or accelerators have less compute capability. One
    of the key advantages of Caffe2 is that it has been designed and developed from
    the beginning to scale: from multi-GPU, multi-CPU servers, down to tiny edge devices.
    In this section, we will use the Raspberry Pi as an example of an edge device
    and learn how to use Caffe2 on it.'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Raspberry Pi is a series of single-board general-purpose computers introduced
    by the Raspberry Pi Foundation from the UK. *Figure 7.1* shows the latest Rv3
    board of the Raspberry Pi B+ unit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa3ebe16-1ea5-4f44-9649-bd767ed2c26b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: A Raspberry Pi B+ Rev3 board, released in 2018'
  prefs: []
  type: TYPE_NORMAL
- en: Since its introduction in 2012, the Pi has taken the world by storm, being used
    for teaching in schools, for hobby projects, and real-world deployments at the
    edge. Costing about $35 each, the Pi is affordable for all types of projects.
    What makes the Raspberry Pi computer so useful is its small form factor; it is
    about the size of a pack of cards. The Pi requires little power, running off a
    5V micro-USB power supply. And the Pi is a fully general-purpose computer, with
    all common storage and I/O ports, such as SD/microSD card slots, USB ports, wireless
    connectivity, an Ethernet port, an HDMI out, and a composite video out. Probably
    the biggest advantage of the Pi over other devices in its form factor is the availability
    of Raspbian, a port of the popular Debian Linux distribution for the Pi. With
    Raspbian, Pi users get to use the same tools, compilers and programming libraries
    that are available on a mainstream Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Caffe2 experiment on the Raspberry Pi will involve the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Raspbian
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and using Caffe2 on Raspbian
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Raspbian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to install Raspbian:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Raspbian releases from [https://www.raspberrypi.org/downloads/raspbian/](https://www.raspberrypi.org/downloads/raspbian/).
    There is a Raspbian release corresponding to every Debian release. The latest
    Debian version 9 is called **Stretch** and the corresponding Raspbian is called
    Raspbian 9 or Raspbian Stretch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a Raspbian bundle that is appropriate for you. To suit various applications,
    there are three type of Raspbian Stretch bundles that are available. For our purpose,
    the smallest bundle called Raspbian Stretch Lite is adequate. If you would like
    to use a desktop and GUI apps, then you can try the other bundles that ship with
    those features. Once your Raspbian is connected to your network, you can SSH into
    it and get full access to a Bash shell to run commands and console tools and editors.
    You could also choose to install other GUI applications later if you required
    them. Stretch Lite is sufficient for all these purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a tool to flash the Raspbian disk image to an SD card. A recommended easy-to-use
    tool for this purpose is **Etcher**. Download it from [https://www.balena.io/etcher/](https://www.balena.io/etcher/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have installed Etcher, plug in an SD card with a minimum of 4 GB capacity
    into your computer's SD card slot. Use Etcher to flash the Raspbian disk image
    to the SD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Raspberry Pi can be used as a headless computer by SSHing to it instead
    of working at it locally. If you would like this feature to be enabled from the
    very first boot up of Raspbian then put back the flashed SD card into your computer.
    Then, create an empty file named `ssh` in the root directory of the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are done with flashing the SD card with Raspbian. Insert this SD card
    into the SD card slot on the Raspberry Pi board. Make sure your Pi is connected
    to your home wireless router with an Ethernet cable. Optionally, you can also
    connect your Pi to your TV or computer display with an HDMI cable to watch its
    boot messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power on the Pi. You can see the boot messages of Raspbian on your TV or display.
    At the end of the boot-up sequence, it displays the IP address assigned to it
    by DHCP and asks you to log in locally. Alternatively, you can also figure out
    the IP address allocated to the Pi by checking the admin console of your wireless
    router. Now you can SSH into the Raspbian from any computer on the network using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the default password: `raspberry`. After your first successful login, Raspbian
    will remind you to change the default password. Please do so by typing the `passwd`
    command at the shell. You can use this new password from the next time you SSH
    into the Pi.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, make sure to update the package repositories and update the installed
    packages using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building Caffe2 on Raspbian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caffe2 has been ported to Raspbian. But there is no easy way to cross-compile
    to the Raspberry Pi from your x86_64 computer, so Caffe2 has to be built on the
    diminutive Pi itself.
  prefs: []
  type: TYPE_NORMAL
- en: We could SSH to the Pi and clone the Caffe2 Git repository on it. However, the
    full PyTorch and Caffe2 repository, along with their submodules, is more than
    400 MB, and that clone operation could take a long time to complete on the Pi.
    Also, note that it is fastest to clone to the SD card rather than a hard disk
    connected by USB to the Pi. The latter can be painfully slow because Pi only has
    USB 2.0 (which is slower than USB 3.0) and the USB ports and Ethernet ports share
    the same bus, further limiting the Git clone speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with building Caffe 2 on Raspbian:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is easiest to clone on your local computer, let''s do that first using
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the clone is done, reduce the size of this directory by deleting the Git
    repository data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compress this into a `.tar.gz` archive and copy it over SSH to the Pi,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH to the Pi and decompress the copied archive there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The script to build Caffe2 on Raspbian is `scripts/build_raspbian.sh`. Note
    that this Raspbian build has not been maintained in recent times. So, before we
    run it, we need to install a few Python packages that are necessary for successful
    compilation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to build by invoking the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like the build process we used in [Chapter 1](5f3ecee9-fc6c-4a3f-bc8f-3bffb7cb2269.xhtml),
    *Introduction and Installation*, this also uses CMake, first to configure the
    make process and then to invoke `make` to build the necessary components, placing
    the built artifacts in the `build` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the build process takes a long time and could take as much as half
    a day. The Raspberry Pi has 500 MB to 1 GB of RAM (depending on which variant
    of Pi you have) and Raspbian, by default, allocates only about 100 MB of swap
    space. So, the build can fail sometimes because it runs out of memory. If that
    happens, you can increase the swap space by opening the `/etc/dphys-swapfile`
    file and increasing the `CONF_SWAPSIZE` value. I found that increasing it from
    `100` to `1000` was sufficient for successful compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compilation, you can install and test Caffe2 just as we did in [Chapter
    1](5f3ecee9-fc6c-4a3f-bc8f-3bffb7cb2269.xhtml), *Introduction and Installation*,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You now have Caffe2 working on the Raspberry Pi. You can now attach sensors
    or camera modules to the Pi, read images and data from them, and run them through
    DL networks for classification, detection, and understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Caffe2 in the cloud using containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are now a ubiquitous and necessary tool for robustly deploying software
    in production, both locally and in the cloud. They enable developers to create
    the ideal software environment for the application and ensure that this software
    environment is exactly replicated on developer workstations, test computers, staging
    computers, and the final deployment to local servers or instances in the cloud.
    Containers also help create a sanitized software environment for every single
    application, enabling multiple software environments, one for each application,
    when multiple applications are running on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: Among the many available container tools, *Docker* is the most popular. We will
    focus on using Docker in this section. Docker is available for all popular Linux
    distributions, macOS X, and Windows. With Docker, you can create an Ubuntu software
    environment from a specific Ubuntu version and run your Caffe2 application inside
    that on a RedHat host OS from a different version. Docker makes such varied deployments
    easy and doable in mere minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps for installation:'
  prefs: []
  type: TYPE_NORMAL
- en: To install Docker using package repositories and packages specific to your OS
    or distribution, please follow the instructions here [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation is successful, remember to add your username to the
    `docker` user group using a command like the one shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For this addition to the group to take full effect, you may need to log out
    and log back in again.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, finally, to test if your Docker setup is working correctly, run the `hello-world`
    image. If successful, you will see a welcoming message similar to the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final experiment, you can get a Bash shell inside an Ubuntu container
    and explore inside that Ubuntu instance by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we are launching an Ubuntu container. The `-it` option indicates that this
    is an interactive session. That is, we want to run the application (bash) and
    stay with it until we quit the container. This is opposed to the normal flow (such
    as in the `hello-world` container) where Docker executes an application and quits
    once it is completed. The `--rm` option indicates that Docker should tear down
    the container once we quit it. Normally, it would keep it around in the background,
    ready for use again.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that Docker logs you in as the `root` user and you get a root
    shell. You are placed at the root of the filesystem. The root privileges are only
    inside this Docker container. Any files you create or change inside the container
    are ephemeral. They are lost when you exit the container.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done exploring the Ubuntu container, you can quit by pressing *Ctrl
    + D* or typing `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing nvidia-docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can run Caffe2, Python, and C++ applications on the CPU in Docker after
    following the preceding steps. However, if you want to run Caffe2 applications
    on the GPU, then you need to install and use nvidia-docker.
  prefs: []
  type: TYPE_NORMAL
- en: NVIDIA-Docker provides full and unfettered access to the NVIDIA GPUs on your
    system to your applications running inside Docker. Note that this feature relies
    on the NVIDIA GPU driver installed on your host system. However, you do not need
    to install CUDA or cuDNN on your host system because you can spin up a container
    having any CUDA version you want installed inside it. This is a convenient way
    to build and test your applications against different CUDA versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions for installing NVIDIA Docker can be found at [https://github.com/NVIDIA/nvidia-docker](https://github.com/NVIDIA/nvidia-docker).
    At the time of writing, nvidia-docker could be installed using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `nvidia-docker` repositories and update the package cache, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the NVIDIA Docker runtime, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, restart the Docker daemon, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to test if our NVIDIA Docker is working and can access the
    NVIDIA GPU on our system. To do this we need to run the application `nvidia-smi`
    in the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`nvidia-smi` is a tool that talks to the NVIDIA GPU driver on your host system
    to print information about the GPUs available on your system. If your NVIDIA Docker
    installation is successful, you should be able to see the `nvidia-smi` list, the
    NVIDIA GPU driver version and the GPUs you have installed on it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the Docker tag we used in this command: `nvidia/cuda:9.0-base`. This is
    a Docker image that has CUDA 9.0 installed inside it. The full list of available
    Docker images and tags can be seen here: [https://hub.docker.com/r/nvidia/cuda/tags](https://hub.docker.com/r/nvidia/cuda/tags).
    A table of CUDA versions and GPU driver versions compatible with each CUDA version
    can be found at [https://github.com/NVIDIA/nvidia-docker/wiki/CUDA](https://github.com/NVIDIA/nvidia-docker/wiki/CUDA).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding command, we specified that we wanted to use the NVIDIA Docker
    runtime using the `--runtime=nvidia` option. We can also run the same command
    without specifying the runtime by using the alias `nvidia-docker`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running Caffe2 containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Caffe2 project provides Docker images for different versions of Caffe2 and
    Ubuntu, both for CPU and GPU. The full list of available Docker images can be
    found at [https://hub.docker.com/r/caffe2ai/caffe2/tags](https://hub.docker.com/r/caffe2ai/caffe2/tags).
    The Caffe2 image Docker tag describes its capabilities succinctly. For example,
    the `c2v0.8.1.cpu.min.ubuntu16.04` tag indicates that the image has Caffe2 v0.8.1
    for CPU on Ubuntu 16.04\. The `c2v0.8.1.cuda8.cudnn7.ubuntu16.04` tag indicates
    that the image has Caffe2 v0.8.1 for GPU on Ubuntu 16.04 with CUDA 8.1 and cuDNN
    7 installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can spin up a Caffe2 CPU image and check whether Caffe2 works inside it
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can spin up a Caffe2 GPU image and check whether Caffe2 works inside it
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how we need to use `nvidia-docker` instead of `docker` if we are using
    a Caffe2 GPU image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your Caffe2 containers are working, you can mount your Caffe2 applications
    and data inside it and execute them. You can mount your host directories inside
    a Docker container using the `-v` option and indicating the guest directory to
    mount them to, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This mounts your `/home/joe/caffe2_apps` directory as `/joe_caffe2_apps` inside
    the container. You are now ready to build Caffe2 applications inside containers
    and deploy those applications to servers locally or in the cloud using containers.
  prefs: []
  type: TYPE_NORMAL
- en: Caffe2 model visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DL models contain a high number of layers. Layers have many parameters, such
    as their name, type, weight dimensions, layer-type-specific parameters, input,
    and output tensor names. While typical feedforward network structures do not have
    cycles, the **Recurrent Neural Network** (**RNN**) and other network structures
    have cycles and other topologies. So, the ability to visualize the structure of
    a DL model is important, both for researchers devising new networks to solve problems,
    and for practitioners using new networks.
  prefs: []
  type: TYPE_NORMAL
- en: Visualization using Caffe2 net_drawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caffe2 ships with a simple visualization tool written in Python named `net_drawer`.
    This Python script can be found in your Caffe2 installation directory. For example,
    if you installed Caffe2 at `/usr/local`, then this tool is available at `/usr/local/lib/python2.7/dist-packages/caffe2/python/net_drawer.py`
    on your system. You can also find this tool in your Caffe2 source code at `caff2/python/net_drawer.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the AlexNet model from [Chapter 4](95863955-3504-48ab-a217-e95339a754d3.xhtml),
    *Working with Caffe*, using `net_drawer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are indicating that we want to visualize the nodes of the graph in a top-to-bottom
    order using the option `--rankdir TB`. This command renders the AlexNet graph
    shown in *Figure 4.3* in [Chapter 4](95863955-3504-48ab-a217-e95339a754d3.xhtml),
    *Working with Caffe*.
  prefs: []
  type: TYPE_NORMAL
- en: This command writes two files. The first is a text file named `AlexNet.dot`
    that holds the graph structure in the human-readable GraphViz DOT format. The
    second is a PDF file named `AlexNet.pdf` with a graphical rendering of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this tool provides other options to customize the visualization.
    You can find these by using the `--help` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Visualization using Netron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Netron** is a browser based DL model visualization written in Python. It
    is open source and available at [https://github.com/lutzroeder/netron](https://github.com/lutzroeder/netron).'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to `net_drawer`, Netron has a modern visualization style and allows
    a far better interaction with the graph nodes to view their parameters. Also,
    Netron's zoom capability makes it easier to use on larger networks. The biggest
    advantage of using Netron is that it supports the visualization of models from
    a large number of DL frameworks, such as Caffe2, Caffe, TensorFlow, and also the
    ONNX format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Netron can be installed from PyPI repository using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize our Caffe2 AlexNet protobuf file using Netron, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens a new tab in your browser at `http://localhost:8080` with a visualization
    of the AlexNet model. We can zoom in and out using the scroll feature of the mouse.
    Clicking on any layer in the model shows its parameters on the right. This can
    be seen in *Figure 7.2* for our AlexNet model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eba9a08d-39f8-4fb2-8434-6c8168e9e83e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Netron visualization of AlexNet with the parameters of the first
    Convolution layer shown on the right'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final chapter of this guide, we looked at two applications of Caffe2
    that demonstrate its ability. As an application of Caffe2 to edge devices, we
    looked at how to build Caffe2 on the Raspberry Pi single-board computers and run
    Caffe2 applications on them. As an application of Caffe2 to the cloud, we looked
    at how to build and run Caffe2 applications inside Docker containers. As an aid
    to understanding the structure of DL models, we examined two tools that helped
    in the visualization of Caffe2 models.
  prefs: []
  type: TYPE_NORMAL
