- en: Sentiment Analysis over Text Using LinearSVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build an iOS application to do sentiment analysis
    over text and image through user input. We will use existing data models that
    were built for the same purpose by using LinearSVC, and convert those models into
    core **machine learning** (**ML**) models for ease of use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Sentiment analysis is the process of identifying a feeling or opinion that is
    inspired by any given data in the form of text, image, audio, or video. There
    are a lot of use cases for sentiment analysis. Even now, political parties can
    easily identify the general mindset of the people who are going to elect them
    and they also have the potential to change that mindset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at building our own ML model on sentiment analysis from
    an existing dataset. In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the ML model using scikit-learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Support Vector Classification** (**LinearSVC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an iOS application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the ML model using scikit–learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build our own model. There are existing datasets available
    that are related to Twitter feed data on the topic of product and movie reviews.
    You can pick a dataset that suits you; in this chapter, we will pick a dataset
    that has customer reviews.
  prefs: []
  type: TYPE_NORMAL
- en: A dataset that contains both positive and negative reviews of customers can
    be found at [http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/](http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/).
    You can download the dataset from the following link: [http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/epinions3.zip](http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/epinions3.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned dataset has both positive and negative feedback about a
    product, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5643436-bbd4-4559-8af3-aee1844cc3b4.png)'
  prefs: []
  type: TYPE_IMG
- en: We will train the dataset using the scikit-learn pipeline and LinearSVC. Let's
    take a closer look at both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Scikit-learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a data mining and data analysis Python library built on top of **NumPy**,
    **SciPy**, and **Matplotlib**. This helps with ML problems related to classification,
    regression, clustering, and dimensionality reduction.
  prefs: []
  type: TYPE_NORMAL
- en: The scikit-learn pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of the scikit-learn pipeline is to assemble ML steps. This
    can be cross-validated to set various parameters. Scikit-learn provides a library
    of transformers that are used for preprocessing data (data cleaning), kernel approximation
    (expand), unsupervised dimensionality reduction (reduce), and feature extraction (generate).
    The pipeline contains a series of transformers with a final estimator.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline sequentially applies a list of transforms, followed by a final
    estimator. In the pipeline, the `fit` and `transform` methods are implemented
    during the intermediate steps. The `fit` method is implemented only at the end
    of pipeline operation by the final estimator. To cache the transformers in the
    pipeline, memory arguments are used.
  prefs: []
  type: TYPE_NORMAL
- en: An estimator for classification is a Python object that implements the method's
    fit (*x*, *y*) and predict (*T*) values. An example of this is `class sklearn.svm.SVC`,
    which implements SVC. The model's parameters are taken as arguments for the estimator's
    constructor. The `memory` class in scikit-learn has the `class sklearn.utils.Memory(*args,
    **kwargs)` signature. This has methods to cache, clear, reduce, evaluate, and
    format the memory objects. The `cache` method is used to compute the return value
    of the function. The returned object is a `MemorizedFunc` object, which behaves
    like a function and offers additional methods for cache lookup and management.
    The `cache` method takes parameters such as `func=None, ignore=None, verbose=None,
    and mmap_mode=False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `class signature` pipeline is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at another important component in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: LinearSVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the classes in the scikit-learn library is LinearSVC, which supports
    both sparse and dense types of input. A one-versus-the-rest scheme is used to
    handle the multiclass support. LinearSVC is similar to SVC, where the parameter
    is `kernel = linear`, but `liblinear` is used to implement the parameter in LinearSVC,
    rather than `libvsm`, which is used in SVC. This provides us with more flexibility
    to choose the penalties and loss functions. It also helps in scaling a large number
    of samples in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `class` signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to start building our model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by importing all the necessary libraries, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `re` library is the regular expressions library that provides the matching
    operations that make it easy to handle text data. The `nltk` library is used to
    format the text according to our requirements, while `sklearn` offers the ML tools
    required. The `coremltools` library helps us in to convert the `sklearn` model
    to a Core ML model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start reading our input, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code reads the CSV file and then converts it into a `numpy` array
    that includes all the rows and columns. Now that we have the dataset ready, we
    can start extracting the features from the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s work on feature selection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by vectorizing the `features` function. Then, we will extract
    the features of every sentence in the DataFrame and store them in an `X` variable.
    After this, we will set the target variable. The target variable is going to be
    the output. In our case, we will get a label for every sentence that indicates
    the sentiment in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we will create a pipeline with `DictVectorizer` and `LinearSVC`.
    `DictVectorizer`, as the name suggests, converts the dictionary in to vectors.
    We have picked `GridSearchCV` to select the best model from a family of models,
    parametrized by a grid of parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then print the results, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now convert the scikit-learn model into `mlmodel`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once we have our model, we can start building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the iOS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start building the iOS application with the model that was built in the
    previous step. The model will predict the output according to whether the input
    text is positive, neutral, or negative in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this application, Xcode version 10.1 should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project with a **Single View app**, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33d4fee8-f8c2-44fb-b863-da21ec9aecd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Mention the name of our application on the **Next** screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next wizard screen, pick an appropriate name for your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the rest of the fields, including Organization Name, as well as Organization
    Identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are not going to use core data in this application, so let's skip that option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new app in Xcode. The following screenshot demonstrates
    how to create a new project in Xcode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/81976eeb-5ae5-4f01-bbd5-1246a2f011c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a storyboard, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d498728f-2fb4-4fab-bf81-5e3b27eb1b43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you select the file location in which to save your application, you will
    be able to see the General tab with information on the new application that has
    been initialized, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8cfe0a2b-ef16-4717-bab9-7b4ebf6a7790.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will create a simple UI with a button at the bottom to display the sentiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define `sentiments` as the enumerator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write the `ClassificationService` to fetch the result from the model
    that we have built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The input is passed on to the `prediction` method to filter the statements
    into `positive`, `negative`, or `neutral` sentiments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write `ViewController` by initializing the `view` components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial `setupConstraints` on the buttons and labels are defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Show()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application on the simulator. You can see the output in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/251e6987-1989-41b3-844c-fc1bf96f162c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use different inputs for our application and get the output, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/017d54c1-515d-4d4e-aae4-dceb1ac848b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example statement of a negative input with the same output is shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c08a356a-a977-4bba-95f4-2152ab7aa4d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example input using neutral text is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a79e9403-a408-4265-acbc-46072f9e1a73.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we are able to get the sentiment from the given text input. Now, you can
    go one step further by improving the existing model.
  prefs: []
  type: TYPE_NORMAL
- en: You can explore finding sentiments on images in further detail in various sources.
    An example application is *Fine-tuning CNNs for Visual Sentiment Prediction*.
    You can read about this application at [https://github.com/imatge-upc/sentiment-2017-imavis](https://github.com/imatge-upc/sentiment-2017-imavis).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be able to build your own TensorFlow model and convert
    it into a Core ML model so that it can be used in an iOS application. The same
    TensorFlow model can be converted into a TensorFlow Lite model, which can then
    be used in an Android application or iOS application. Now, you can take on this
    task and experiment with the results. That said, we are now ready to move on to
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use the knowledge we have acquired in this book
    to move on and explore how you can build your own application.
  prefs: []
  type: TYPE_NORMAL
