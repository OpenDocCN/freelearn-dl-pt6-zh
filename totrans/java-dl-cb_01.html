<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Deep Learning in Java</h1>
                </header>
            
            <article>
                
<p><span>Let's discuss various deep learning libraries so as to pick the best for the purpose at hand. This is a context-dependent decision and will vary according to the situation. In this chapter, we will start with a brief introduction to deep learning and explore how DL4J is a good choice for solving deep learning puzzles. We will also discuss how to set up DL4J in your workspace.</span></p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Deep learning intuition</li>
<li><span>Determining the right network type to solve deep learning problems</span></li>
<li><span>Determining the right activation function</span></li>
<li><span>Combating overfitting problems</span></li>
<li><span>Determining the right batch size and learning rates</span></li>
<li><span>Configuring Maven for DL4J</span></li>
<li><span>Configuring DL4J for a GPU-accelerated environment</span></li>
<li><span>Troubleshooting installation issues</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You'll need the following to get the most out of this cookbook:</p>
<ul>
<li><span>Java SE 7, or higher, installed</span></li>
<li><span>Basic core Java knowledge</span></li>
<li><span>DL4J basics</span></li>
<li><span>Maven basics</span></li>
<li><span><span>Basic data analytical skills</span></span></li>
<li><span>Deep learning/machine learning basics</span></li>
<li><span>OS command basics (Linux/Windows)</span></li>
<li><span>IntelliJ IDEA IDE (this is a very easy and hassle-free way of managing code; however, you're free to try another IDE, such as Eclipse)</span></li>
<li><span>Spring Boot basics (to integrate DL4J with Spring Boot for use with web applications)</span><span><br/></span></li>
</ul>
<div class="packt_infobox">We use DL4J version<span> </span>1.0.0-beta3<span> </span>throughout this book except for <a href="ade34354-ad22-4d3e-b45e-ce112947df49.xhtml" target="_blank">Chapter 7</a>, <em>Constructing an LSTM Neural Network for Sequence Classification</em>, where we used the current latest version,<span> </span>1.0.0-beta4<span>, </span>to avoid bugs. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deep learning intuition</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you're a newbie to deep learning, you may be wondering how exactly it is differs from machine learning; or is it the same? Deep learning is a subset of the larger domain of machine learning. Let's think about this in the context of an automobile image classification problem:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1186 image-border" src="assets/aff78d29-b0a5-4b31-984b-c329227ed7da.png" style="width:36.58em;height:8.92em;"/></p>
<p class="mce-root CDPAlignLeft CDPAlign">As you can see in the preceding diagram, we need to perform feature extraction ourselves as legacy machine learning algorithms cannot do that on their own. They might be super-efficient with accurate results, but they cannot learn signals from data. In fact, they don't learn on their own and still rely on human effort: </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1187 image-border" src="assets/78a06015-1bc7-42a6-bf4c-df580e370f0a.png" style="width:37.92em;height:9.25em;"/></p>
<p>On the other hand, deep learning algorithms learn to perform tasks <span>on their own</span>. Neural networks under the hood are based on the concept of deep learning and it trains on their own to optimize the results. However, the final decision process is hidden and cannot be tracked. The intent of deep learning is to imitate the functioning of a human brain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backpropagation</h1>
                </header>
            
            <article>
                
<p>The backbone of a neural network is the backpropagation algorithm. Refer to the sample neural network structure shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1188 image-border" src="assets/fc9dffda-d154-47bc-852c-25b7fca57cb9.png" style="width:33.67em;height:18.67em;"/></p>
<p>For any neural network, data flows from the input layer to the output layer during the forward pass. Each circle in the diagram represents a neuron. Every layer has a number of neurons present. Our data will pass through the neurons across layers. <span>The input needs to be in a numerical format to support computational operations in neurons. </span>Each neuron in the neural network is assigned a weight (matrix) and an activation function. Using the input data, weight matrix, and an activation function, a probabilistic value is generated at each neuron. The error (that is, a deviation from the actual value) is calculated at the output layer using a loss function. We utilize the loss score during the backward pass (that is, from the output layer to the input layer ) by reassigning weights to the neurons to reduce the loss score. During this stage, some output layer neurons will be assigned with high weights and vice versa depending upon the loss score results. This process will continue backward as far as the input layer by updating the weights of neurons. In a nutshell, we are tracking the rate of change of loss with respect to the change in weights across all neurons. This entire cycle (a forward and backward pass) is called an epoch. We perform multiple epochs during a training session. A neural network will tend to optimize the results after every training epoch. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multilayer Perceptron (MLP)</h1>
                </header>
            
            <article>
                
<p>An MLP is a standard feed-forward neural network with at least three layers: an input layer, a hidden layer, and an output layer. Hidden layers come after the input layer in the structure. Deep neural networks have two or more hidden layers in the structure, while an MLP has only one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convolutional Neural Network (CNN)</h1>
                </header>
            
            <article>
                
<p><span>CNNs are generally used for image classification problems, but can also be exposed in</span> <strong>Natural Language Processing</strong> <span>(</span><strong>NLP</strong><span>), in conjunction with word vectors, because of their proven results. Unlike a regular neural network, a CNN will have additional layers such as convolutional layers and subsampling layers. Convolutional layers take input data (such as images) and apply convolution operations on top of them. You can think of it as applying a function to the input. Convolutional layers act as filters that pass a feature of interest to the upcoming subsampling layer. A feature of interest can be anything (for example, a fur, shade and so on in the case of an image) that can be used to identify the image. In the subsampling layer, the input from convolutional layers is further smoothed. So, we end up with a much smaller image resolution and reduced color contrast, preserving only the important information. The input is then passed on to fully connected layers. Fully connected layers resemble regular feed-forward neural networks. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recurrent Neural Network (RNN)</h1>
                </header>
            
            <article>
                
<p>An RNN is a neural network that can process sequential data. In a regular feed-forward neural network, the current input is considered for neurons in the next layer. On the other hand, an RNN can accept previously received inputs as well. It can also use memory to memorize previous inputs. So, it is capable of preserving long-term dependencies throughout the training session. RNN is a popular choice for NLP tasks such as speech recognition. In practice, a slightly variant structure called <strong>Long Short-Term Memory</strong> (<strong>LSTM</strong>) is used as a better alternative to RNN.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why is DL4J important for deep learning?</h1>
                </header>
            
            <article>
                
<p>The following points will help you understand why DL4J is important for deep learning:</p>
<ul>
<li>DL4J provides commercial support. It is the first commercial-grade, open source, deep learning library in Java.</li>
<li>Writing training code is simple and precise. DL4J supports Plug and Play mode, which means switching between hardware (CPU to GPU) is just a matter of changing the Maven dependencies and no modifications are needed on the code.</li>
<li>DL4J uses ND4J as its backend. ND4J is a computation library that can run twice as fast as NumPy (a computation library in Python) in large matrix operations. DL4J exhibits faster training times in GPU environments compared to other Python counterparts. </li>
<li>DL4J supports training on a cluster of machines that are running in CPU/GPU using Apache Spark. DL4J brings in automated parallelism in distributed training. This means that DL4J bypasses the need for extra libraries by setting up worker nodes and connections. </li>
<li>DL4J is a good production-oriented deep learning library. As a JVM-based library, DL4J applications can be easily integrated/deployed with existing corporate applications that are running in Java/Scala. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the right network type to solve deep learning problems</h1>
                </header>
            
            <article>
                
<p>It is crucial to identify the right neural network type to solve a business problem efficiently. A standard neural network can be a best fit for most use cases and can produce approximate results. However, in some scenarios, the core neural network architecture needs to be changed in order to accommodate the features (input) and to produce the desired results. In the following recipe, we will walk through key steps to decide the best network architecture for a deep learning problem with the help of known use cases. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Determine the problem type.</li>
<li>Determine the type of data engaged in the system.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To solve use cases effectively, we need to use the right neural network architecture by determining the problem type. The following are globally some use cases and respective problem types to consider for step 1:</p>
<ul>
<li><strong>Fraud detection problems</strong>:<strong> </strong>We want to differentiate between legitimate and suspicious transactions so as to separate unusual activities from the entire activity list. The intent is to<span> </span>reduce false-positive (that is, incorrectly tagging legitimate transactions as fraud) cases. Hence, this is an anomaly detection problem. </li>
<li><strong>Prediction problems</strong>:<strong> </strong><span>Prediction problems can be classification or regression problems. For labeled classified data, we can have discrete labels. We need to model data against those discrete labels. On the other hand, regression models don't have discrete labels. </span></li>
<li><strong>Recommendation problems</strong>:<strong> </strong><span>You would need to build a recommender system (a recommendation engine) to recommend products or content to customers. Recommendation engines can also be applied to an agent performing tasks such as gaming, autonomous driving, robotic movements, and mor</span>e. Recommendation engines implement reinforcement learning and can be enhan<span>ced further by introducing deep learning into it. </span></li>
</ul>
<p>We also need to know the type of data that is consumed by the neural network. <span>Here are some use cases and respective data types fo</span>r step 2:</p>
<ul>
<li><strong>Fraud detection problems</strong>:<strong> </strong>Transactions usually happen over a number of<span> </span>time steps. So, we need to continuously collect transaction data over time. This is an example of time series data. Each time sequence represents a new transaction sequence. These time sequences can be regular or irregular. For instance, if you have credit card transaction data to analyze, then you have labeled data. You can also have unlabeled data in the case of user metadata from production logs. <span>We can ha</span>ve supervised/unsupervised dat<span>asets for fraud detection analysis, for example. Take a look at the following CSV supervised dataset:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1189 image-border" src="assets/d882cc72-71ce-454a-9289-1cb7b3261bbf.png" style="width:56.33em;height:15.17em;"/></p>
<p style="padding-left: 60px"><span>In the preceding screenshot, features such a</span>s <kbd>amount</kbd>, <kbd>oldBalanceOrg</kbd>, and so on make sense and each record has a label indicating whether the particular observation is fr<span>audulent or not.</span></p>
<p style="padding-left: 60px"><span>On the other hand, an unsupervised dataset will not give you any clue about input features. It doesn't have any labels either, as shown in the following CSV data:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1190 image-border" src="assets/be8a3dd1-e5e9-4241-ab1c-f036d08f883a.png" style="width:55.58em;height:15.83em;"/></p>
<p style="padding-left: 60px"><span>As you can see, the feature labels (top row) follow a numbered naming convention without any clue as to its significance for fraud detection outcomes. We can also have time series data where transactions are logged over a series of time steps. </span></p>
<p class="mce-root"/>
<ul>
<li><strong>Prediction problems</strong>:<strong> </strong><span>Historical data collected from organizations can be used to train neural networks. These are usually simple file types such as a CSV/text files</span><span>. Data can be obtained as records. For a stock market prediction problem, the data type would be a time series. A dog breed prediction problem requires feeding in dog images for network training. Stock price prediction is an example of a regression problem. Stock price datasets usually are time series data where stock prices are measured over a series as follows:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1191 image-border" src="assets/0061cfc1-2139-4c7a-bbd5-612b220c2b28.png" style="width:40.58em;height:25.92em;"/></p>
<p style="padding-left: 60px"><span>In most stock price datasets, there are multiple files. Each one of them represents a company stock market. And each file will have stock prices recorded over a series of time steps, as shown here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1192 image-border" src="assets/f553df10-3d7d-4339-9a60-14d4afe47f67.png" style="width:55.25em;height:27.67em;"/></p>
<ul>
<li><strong>Recommendation problems</strong>:<strong> </strong>For a product recommendation system, e<span>xplicit data might be customer reviews posted on a website and implicit data might be the customer activity history, such as product search or purchase history. We will use unlabeled data to feed the neural network. Recommender systems can also solve games or learn a job that requires skills. Agents (trained to perform tasks during reinforcement learning) can take real-time data in the form of image frames or any text data (unsupervised) to learn what actions to make depending on their states.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The following are possible deep learning solutions to the problem types previously discussed:</p>
<ul>
<li><strong>Fraud detection problems</strong>: The optimal solution varies according to the data. We previously mentioned two data sources. One was credit card transactions and the other was user metadata based on their login/logoff activities. In the first case, we have labeled data and have a transaction sequence to analyze.</li>
</ul>
<p style="padding-left: 60px">Recurrent networks may be best suited to sequencing data. You can add<span> </span>LSTM (<a href="https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/layers/recurrent/LSTM.html">https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/layers/recurrent/LSTM.html</a>)<span> </span><span>recurrent layers, and DL4J has an implementation for that. For the second case, we have unlabeled data and the best choice would be a variational</span> (<a href="https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/layers/variational/VariationalAutoencoder.html">https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/layers/variational/VariationalAutoencoder.html</a>)<span> </span><span>autoencoder to compress unlabeled data.</span></p>
<ul>
<li><strong>Prediction problems</strong>: For classification problems that use<span> </span><span>CSV</span><span> </span><span>records, a feed-forward neural network will do. For time series data, the best choice would be recurrent networks because of the nature of sequential data. For image classification problems, you would need a</span><span> </span><span>CNN (<a href="https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/conf/layers/ConvolutionLayer.Builder.html">https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/conf/layers/ConvolutionLayer.Builder.html)</a>.</span></li>
<li><strong>Recommendation problems</strong>: We can employ <strong>Reinforcement Learning</strong><span> (<strong>RL</strong>)</span> to solve recommendation problems. RL is very often used for such use cases and might be a better option. RL4J was specifically developed for this purpose. We will introduce RL4J in <a href="9d49be5b-7d29-47f8-848d-b1c5c1b742e9.xhtml">Chapter 9</a>, <em>Using RL4J for Reinforcement Learning</em>, as it would be an advanced topic at this point. We can also go for simpler options such as feed-forward networks RNNs) with a different approach. We can feed an unlabeled data sequence to recurrent or convolutional layers as per the data type (image/text/video). Once the recommended content/product is classified, you can apply further logic to pull random products from the list based on customer preferences.</li>
</ul>
<p>In order to choose the right network type, you need to understand the type of data and the problem it tries to solve. The most basic neural network that you could construct is a feed-forward network or a multilayer perceptron. You can create multilayer network architectures using <kbd>NeuralNetConfiguration</kbd> in <span>DL4J.</span></p>
<p class="mce-root">Refer to the following sample neural network configuration in DL4J:</p>
<pre class="mce-root">MultiLayerConfiguration configuration = new NeuralNetConfiguration.Builder()<br/> .weightInit(WeightInit.RELU_UNIFORM)<br/> .updater(new Nesterovs(0.008,0.9))<br/> .list()<br/> .layer(new DenseLayer.Builder().nIn(layerOneInputNeurons).nOut(layerOneOutputNeurons).activation(Activation.RELU).dropOut(dropOutRatio).build())<br/> .layer(new DenseLayer.Builder().nIn(layerTwoInputNeurons).nOut(layerTwoOutputNeurons).activation(Activation.RELU).dropOut(0.9).build())<br/> .layer(new OutputLayer.Builder(new LossMCXENT(weightsArray))<br/> .nIn(layerThreeInputNeurons).nOut(numberOfLabels).activation(Activation.SOFTMAX).build())<br/> .backprop(true).pretrain(false)<br/> .build();</pre>
<p class="mce-root">We specify activation functions for every layer in a neural network, and <kbd>nIn()</kbd> and <kbd>nOut()</kbd> represent the number of connections in/out of the layer of neurons. The purpose of the <kbd>dropOut()</kbd> function is to deal with network performance optimization. We mentioned it in <a href="5cf01186-c9e3-46e7-9190-10cd43933694.xhtml">Chapter 3</a>, <em>Building Deep Neural Networks for Binary Classification</em>. Essentially, we are ignoring some neurons at random to avoid blindly memorizing patterns during training. Activation functions will be discussed in the <em>Determining the right activation function </em>recipe in this chapter. Other attributes control how weights are distributed between neurons and how to deal with errors calculated across each epoch.</p>
<p class="mce-root">Let's focus on a specific decision-making process: choosing the right network type. Sometimes, it is better to use a custom architecture to yield better results. For example, you can perform sentence classification using word vectors combined with a CNN. DL4J offers the <kbd>ComputationGraph</kbd> <span>(<a href="https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/graph/ComputationGraph.html">https://deeplearning4j.org/api/latest/org/deeplearning4j/nn/graph/ComputationGraph.html</a>)</span> implementation to accommodate CNN architecture.</p>
<p class="mce-root"><kbd>ComputationGraph</kbd> allows an arbitrary (custom) neural network architecture. Here is how it is defined in DL4J:</p>
<pre class="mce-root">public ComputationGraph(ComputationGraphConfiguration configuration) {<br/> this.configuration = configuration;<br/> this.numInputArrays = configuration.getNetworkInputs().size();<br/> this.numOutputArrays = configuration.getNetworkOutputs().size();<br/> this.inputs = new INDArray[numInputArrays];<br/> this.labels = new INDArray[numOutputArrays];<br/> this.defaultConfiguration = configuration.getDefaultConfiguration();<kbd><br/></kbd><span>//Additional source is omitted from here. Refer to https://github.com/deeplearning4j/deeplearning4j<br/></span><span>}</span></pre>
<p class="mce-root">Implementing a CNN is just like constructing network layers for a feed-forward network:</p>
<pre class="mce-root">public class ConvolutionLayer extends FeedForwardLayer</pre>
<p>A CNN has <kbd>ConvolutionalLayer</kbd> and <kbd>SubsamplingLayer</kbd> apart from <kbd>DenseLayer</kbd> and <kbd>OutputLayer</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the right activation function</h1>
                </header>
            
            <article>
                
<p>The purpose of an activation function is to introduce non-linearity into a neural network. Non-linearity helps a neural network to learn more complex patterns. We will discuss some important activation functions, and their respective DL4J implementations.</p>
<p>The following are the activation functions that we will consider:</p>
<ul>
<li>Tanh</li>
<li>Sigmoid</li>
<li>ReLU (short for <strong>Rectified Linear Unit</strong>)</li>
<li>Leaky ReLU</li>
<li>Softmax</li>
</ul>
<p>In this recipe, we will walk through the key steps to decide the right activation functions for a neural network.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Choose an activation function according to the network layers</strong>: We need to know the activation functions to be used for the input/hidden layers and output layers. <span>Use</span> ReLU for inp<span>ut/hidden layers preferably.</span></li>
<li><strong><span>Choose the right activation function to handle data impurities</span></strong>: Inspect the data that you feed to the neural network. Do you have inputs with a majority of negative values observing dead neurons? Choose the appropriate activation functions accordingly. <span>Us</span>e Leaky ReLU if de<span>ad neurons are observed during training. </span></li>
<li><strong>Choose the right activation function to handle overfitting</strong>: Observe the evaluation metrics and their variation for each training period. Understand gradient behavior and how well your model performs on new unseen data. </li>
<li><strong>Choose the right activation function as per the expected output of your use case</strong>: Examine the desired outcome of your network as a first step. For example, the SOFTMAX function can be used when you need to measure the probability of the occurrence of the output class. It is used in the output layer. For any input/hidden layers, ReLU is what you need for most cases. If you're not sure about what to use, just start experimenting with ReLU; if that doesn't improve your expectations, then try other activation functions.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">For step 1, ReLU is most commonly used because of its non-linear behavior. The output layer activation function depends on the expected output behavior. Step 4 targets this too. </p>
<p class="mce-root">For step 2, Leaky ReLU is an improved version of ReLU and is used to avoid the zero gradient problem. However, you might observe a performance drop. We use Leaky ReLU if dead neurons are observed during training. Dead neurons are referred to as neurons with a zero gradient for all possible inputs, which makes them useless for training.</p>
<p class="mce-root">For step 3, the tanh and sigmoid activation functions are similar and are used in feed-forward networks. If you use these activation functions, then make sure you add regularization to network layers to avoid the vanishing gradient problem. These are generally used for classifier problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The ReLU activation function is non-linear, hence, the backpropagation of errors can easily be performed. Backpropagation is the backbone of neural networks. This is the learning algorithm that computes gradient descent with respect to weights across neurons. The following are ReLU variations currently supported in DL4J:</p>
<ul>
<li><kbd>ReLU</kbd>: The standard ReLU activation function:</li>
</ul>
<pre style="padding-left: 60px">public static final Activation RELU</pre>
<ul>
<li><kbd>ReLU6</kbd>: ReLU activation, which is capped at 6, where 6 is an arbitrary choice:</li>
</ul>
<pre style="padding-left: 60px">public static final Activation RELU6</pre>
<ul>
<li><kbd>RReLU</kbd>: The randomized ReLU activation function:</li>
</ul>
<pre style="padding-left: 60px">public static final Activation RRELU</pre>
<ul>
<li><kbd>ThresholdedReLU</kbd>: Threshold ReLU:</li>
</ul>
<pre style="padding-left: 60px">public static final Activation THRESHOLDEDRELU</pre>
<p>There are a few more implementations, such as<span> </span><strong>SeLU</strong><span> </span>(short for the<span> </span><strong>Scaled Exponential Linear Unit</strong>), which is similar to the ReLU activation function but has a slope for negative values.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combating overfitting problems</h1>
                </header>
            
            <article>
                
<p>As we know, overfitting is a major challenge that machine learning developers face. It becomes a big challenge when the neural network architecture is complex and training data is huge. While mentioning overfitting, we're not ignoring the chances of underfitting at all. We will keep overfitting and underfitting in the same category. Let's discuss how we can combat overfitting problems.</p>
<p>The following are possible reasons for overfitting, including but not limited to:</p>
<ul>
<li>Too many feature variables compared to the number of data records</li>
<li>A complex neural network model</li>
</ul>
<p>Self-evidently, overfitting reduces the generalization power of the network and the network will fit noise instead of a signal when this happens. In this recipe, we will walk through key steps to prevent overfitting problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Use <kbd>KFoldIterator</kbd> to perform k-fold cross-validation-based resampling:</li>
</ol>
<pre style="padding-left: 60px">KFoldIterator kFoldIterator = new KFoldIterator(k, dataSet);</pre>
<ol start="2">
<li>Construct a simpler neural network architecture.</li>
<li>Use enough train data to train the neural network.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In step 1, <strong><kbd>k</kbd></strong> is the arbitrary number of choice and <kbd>dataSet</kbd> is the dataset object that represents your training data. We perform k-fold cross-validation to optimize the model evaluation process.</p>
<p>Complex neural network architectures can cause the network to tend to memorize patterns. Hence, your neural network will have a hard time generalizing unseen data. For example, it's better and more efficient to have a few hidden layers rather than hundreds of hidden layers. <span>That's the relevance of step 2. </span></p>
<p class="mce-root"/>
<p>Fairly large training data will encourage the network to learn better and a batch-wise evaluation of test data will increase the generalization power of the network. That's the relevance of step 3. Although there are multiple types of data iterator and various ways to introduce batch size in an iterator in DL4J, the following is a more conventional definition for <kbd>RecordReaderDataSetIterator</kbd>:</p>
<pre>public RecordReaderDataSetIterator(RecordReader recordReader,<br/> WritableConverter converter,<br/> int batchSize,<br/> int labelIndexFrom,<br/> int labelIndexTo,<br/> int numPossibleLabels,<br/> int maxNumBatches,<br/> boolean regression)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When you perform k-fold cross-validation, data is divided into <em>k</em> number of subsets. For every subset, we perform evaluation by keeping one of the subsets for testing and the remaining <em>k-1</em> subsets for training. We will repeat this <em>k</em> number of times. Effectively, we use the entire data for training with no data loss, as opposed to wasting some of the data on testing.</p>
<p>Underfitting is handled here. However, note that we perform the evaluation <em>k</em> number of times only.</p>
<p>When you perform batch training, the entire dataset is divided as per the batch size. If your dataset has 1,000 records and the batch size is 8, then you have 125 training batches.</p>
<p>You need to note the training-to-testing ratio as well. According to that ratio, every batch will be divided into a training set and testing set. Then the evaluation will be performed accordingly. For 8-fold cross-validation, you evaluate the model 8 times, but for a batch size of 8, you perform 125 model evaluations.</p>
<div class="packt_infobox">Note the rigorous mode of evaluation here, which will help to improve the generalization power while increasing the chances of underfitting.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the right batch size and learning rates</h1>
                </header>
            
            <article>
                
<p class="mce-root">Although there is no specific batch size or learning rate that works for all models, we can find the best values for them by experimenting with multiple training instances. The primary step is to experiment with a set of batch size values and learning rates with the model. Observe the efficiency of the model by evaluating additional parameters such as<span> </span><kbd>Precision</kbd>,<span> </span><kbd>Recall</kbd>, and<span> </span><kbd>F1 Score</kbd>. Test scores alone don't confirm the model's performance. Also, parameters such as<span> </span><kbd>Precision</kbd><span>, </span><kbd>Recall</kbd><span>, and </span><kbd>F1 Score</kbd><span> </span>vary according to the use case. You need to analyze your problem statement to get an idea about this. <span>In this recipe, we will walk through key steps to determine the right batch size and learning rates.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Run the training instance multiple times and track the evaluation metrics.</li>
<li>Run experiments by increasing the learning rate and track the results.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Consider the following experiments to illustrate step 1.</p>
<p>The following training was performed on 10,000 records with a batch size of 8 and a learning rate of 0.008:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1193 image-border" src="assets/8669f24e-f834-47fa-9a11-2b6e4e8e85fa.png" style="width:51.50em;height:15.42em;"/></p>
<p class="mce-root"/>
<p class="CDPAlignLeft CDPAlign">The following is the evaluation performed on the same dataset for a batch size of 50 and a learning rate of 0.008:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1194 image-border" src="assets/4dc5d658-38f8-4eda-9402-b2531fbcbeab.png" style="width:41.08em;height:16.58em;"/></p>
<p>To perform step 2, we increased the learning rate to 0.6, to observe the results. Note that a learning rate beyond a certain limit will not help efficiency in any way. Our job is to find that limit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1195 image-border" src="assets/4b100a4e-a906-4e13-a870-639b4447828f.png" style="width:41.75em;height:11.25em;"/></p>
<p class="CDPAlignLeft CDPAlign">You can observe that<span> </span><kbd>Accuracy</kbd><span> is </span>reduced to 82.40% and<span> </span><kbd>F1 Score</kbd> is reduced to 20.7%. This indicates that<span> </span><kbd>F1 Score</kbd><span> </span>might be the evaluation parameter<span> </span>to be accounted for in this model. This is not true for all models, and we reach this conclusion after experimenting with a couple of batch sizes and learning rates. In a nutshell, you have to repeat the same process for your model's training and choose arbitrary values that yield the best results. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When we increase the batch size, the number of iterations will eventually reduce, hence the number of evaluations will also be reduced. This can overfit the data for a large batch size. A batch size of 1 is as useless as a batch size based on an entire dataset. So, you need to experiment with values starting from a safe arbitrary point. </p>
<p>A very small learning rate will lead to a very small convergence rate to the target. This can also impact the training time. If the learning rate is very large, this will cause divergent behavior in the model. We need to increase the learning rate until we observe the evaluation metrics getting better. There is an implementation of a cyclic learning rate in the fast.ai and Keras libraries; however, a cyclic learning rate is not implemented in DL4J.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Maven for DL4J</h1>
                </header>
            
            <article>
                
<p>We need to add DL4J/ND4J Maven dependencies to leverage DL4J capabilities. ND4J is a scientific computation library dedicated to DL4J. It is necessary to mention the ND4J backend dependency in your <kbd>pom.xml</kbd> file. In this recipe, we will add a CPU-specific Maven configuration in <kbd>pom.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's discuss the required Maven dependencies. We assume you have already done the following:</p>
<ul>
<li>JDK 1.7, or higher, is installed and the <kbd>PATH</kbd> variable is set.</li>
<li class="mce-root"><span>Maven is installed and the</span> <kbd>PATH</kbd> <span>variable is set.</span></li>
</ul>
<div class="packt_infobox">A 64-bit JVM is required to run DL4J.</div>
<div>
<p>Set the <kbd>PATH</kbd><span> </span>variable for JDK and Maven:</p>
<ul>
<li><strong>On Linux</strong>: Use the <kbd>export</kbd><span> </span><span>command to add Maven and JDK to the </span><kbd>PATH</kbd> v<span>ariable:<br/></span></li>
</ul>
<pre style="padding-left: 60px">export PATH=/opt/apache-maven-3.x.x/bin:$PATH<br/>export PATH=${PATH}:/usr/java/jdk1.x.x/bin</pre>
<p style="padding-left: 60px"><span>Replace the version number as per the installation.<br/></span></p>
<ul>
<li><strong>On Windows</strong>: <span>Set</span><span> </span><span class="packt_screen">System Environment variables</span><span> </span><span>from syste</span>m <span class="packt_screen">Properties</span>:</li>
</ul>
<pre style="padding-left: 60px">set PATH="C:/Program Files/Apache Software Foundation/apache-maven-3.x.x/bin:%PATH%"<br/> set PATH="C:/Program Files/Java/jdk1.x.x/bin:%PATH%"</pre>
<p><span>Replace the JDK version number as per the installation.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add the DL4J core dependency:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.deeplearning4j&lt;/groupId&gt;<br/> &lt;artifactId&gt;deeplearning4j-core&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0-beta3&lt;/version&gt;<br/> &lt;/dependency&gt;<br/> </pre>
<ol start="2">
<li>Add the ND4J native dependency:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.nd4j&lt;/groupId&gt;<br/> &lt;artifactId&gt;nd4j-native-platform&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0-beta3&lt;/version&gt;<br/> &lt;/dependency&gt;<br/> <br/> </pre>
<ol start="3">
<li>Add the DataVec dependency to perform ETL (short for <strong>Extract, Transform and Load</strong>) operations:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.datavec&lt;/groupId&gt;<br/> &lt;artifactId&gt;datavec-api&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0-beta3&lt;/version&gt;<br/> &lt;/dependency&gt;</pre>
<ol start="4">
<li>Enable logging for debugging:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br/> &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;<br/> &lt;version&gt;1.7.25&lt;/version&gt; //change to latest version<br/> &lt;/dependency&gt; </pre>
<div class="packt_tip packt_infobox">Note that 1.0.0-beta 3 is the current DL4J release version at the time of writing this book, and is the official version used in this cookbook. Also, note that DL4J relies on an ND4J backend for hardware-specific implementations.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>After adding DL4J core dependency and ND4J dependencies, as mentioned in step 1 and step 2, we are able to create neural networks. In step 2, the <span>ND4J </span>maven configuration is mentioned as a necessary backend dependency for Deeplearnign4j. ND4J is the scientific computation library for Deeplearning4j. </p>
<div class="packt_infobox"><strong><br/></strong> ND4J is a scientific computing library written for Java, just like NumPy is for Python.</div>
<p>Step 3 is very crucial for the ETL process: that is, data extraction, transformation, and loading. So, we definitely need this as well in order to train the neural network using data.</p>
<p>Step 4 is optional but recommended, since logging will reducee the effort involved in debugging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring DL4J for a GPU-accelerated environment</h1>
                </header>
            
            <article>
                
<p><span>For GPU-powered hardware, DL4J comes with a different API implementation. This is to ensure the GPU hardware is utilized effectively without wasting hardware resources. Resource optimization is a major concern for expensive GPU-powered applications in production. </span><span>In this recipe, we will add a </span>GPU-spec<span>ific Maven configuration</span> to <kbd>pom.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need the following in order to complete this recipe:</p>
<ul>
<li>JDK version 1.7, or higher, installed and added to the <span><kbd>PATH</kbd> variable</span></li>
<li>Maven installed and added to the <kbd>PATH</kbd> variable</li>
<li>NVIDIA-compatible hardware</li>
<li><span>CUDA v9.2+ installed and configured</span></li>
<li><strong>cuDNN</strong> (short for <strong><span>CUDA Deep Neural Network</span></strong>) installed and configured</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Download and install CUDA v9.2+ from the NVIDIA developer website URL: <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>.</li>
<li>Configure the CUDA dependencies. For Linux, go to a Terminal and edit the <kbd>.bashrc</kbd> file. Run the following commands and make sure you replace username and the CU<span>DA version number as per y</span><span>our downloaded version:</span></li>
</ol>
<pre style="padding-left: 60px">nano /home/username/.bashrc<br/> export PATH=/usr/local/cuda-9.2/bin${PATH:+:${PATH}}$<br/> <br/> export LD_LIBRARY_PATH=/usr/local/cuda-9.2/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}<br/> <br/> source .bashrc<span><br/> <br/></span></pre>
<ol start="3">
<li>Add the <kbd>lib64</kbd> directory to <kbd>PATH</kbd> for older DL4J versions.</li>
<li>Run the <kbd>nvcc --version</kbd> command to verify the CUDA installation.</li>
<li>Add Maven dependencies for the ND4J CUDA backend:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.nd4j&lt;/groupId&gt;<br/> &lt;artifactId&gt;nd4j-cuda-9.2&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0-beta3&lt;/version&gt;<br/> &lt;/dependency&gt; </pre>
<ol start="6">
<li>Add the DL4J CUDA Maven dependency:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.deeplearning4j&lt;/groupId&gt;<br/> &lt;artifactId&gt;deeplearning4j-cuda-9.2&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0-beta3&lt;/version&gt;<br/> &lt;/dependency&gt; </pre>
<ol start="7">
<li>Add cuDNN dependencies to use bundled CUDA and cuDNN:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/> &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt;<br/> &lt;artifactId&gt;cuda&lt;/artifactId&gt;<br/> &lt;version&gt;9.2-7.1-1.4.2&lt;/version&gt;<br/> &lt;classifier&gt;linux-x86_64-redist&lt;/classifier&gt; //system specific<br/> &lt;/dependency&gt;<strong><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We configured NVIDIA CUDA using steps 1 to 4. For more detailed OS-specific instructions, refer to the official NVIDIA CUDA website at <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>.</p>
<p>Depending on your OS, installation instructions will be displayed on the website. DL4J version 1.0.0-beta 3 currently supports CUDA installation versions 9.0, 9.2, and 10.0. For instance, if you need to install CUDA v10.0 for Ubuntu 16.04, you should navigate the CUDA website as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1196 image-border" src="assets/9472152e-f538-4507-8961-48716ebdd996.png" style="width:49.17em;height:36.58em;"/></p>
<p>Note that step 3 is not applicable to newer versions of DL4J. For of 1.0.0-beta and later versions, the necessary CUDA libraries are bundled with DL4J. However, this is not applicable for step 7.</p>
<p>Additionally, before proceeding with steps 5 and 6, make sure that there are no redundant dependencies (such as CPU-specific dependencies) present in <kbd>pom.xml</kbd>.</p>
<p>DL4J supports CUDA, but performance can be further accelerated by adding a cuDNN library. cuDNN does not show up as a bundled package in DL4J. Hence, make sure you download and install NVIDIA cuDNN from the NVIDIA developer website. Once cuDNN is installed and configured, we can follow step 7 to add support for cuDNN in the DL4J application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For multi-GPU systems, you can consume all GPU resources by placing the following code in the main method of your application:</p>
<pre>CudaEnvironment.getInstance().getConfiguration().allowMultiGPU(true);</pre>
<p>This is a temporary workaround for initializing the ND4J backend in the case of multi-GPU hardware. In this way, we will not be limited to only a few GPU resources if more are available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Troubleshooting installation issues</h1>
                </header>
            
            <article>
                
<p>Though the DL4J setup doesn't seem complex, installation issues can still happen because of different OSes or applications installed on the system, and so on. <span>CUDA installation issues are not within the scope of this book. Maven build issues that are due to unresolved dependencies can have multiple causes. </span><span>If you are working for an organization with its own internal repositories and proxies, then you need to make relevant changes in t</span>he <kbd>pom.xml</kbd> file. Th<span>ese issues are also outside the scope of this book.</span> In this recipe, we will walk through the steps to mitigate common installation issues with DL4J.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The following checks are mandatory before we proceed:</p>
<ul>
<li>Verify Java and Maven are installed and the<span> </span><kbd>PATH</kbd><span> variables are </span>configured.</li>
<li>Verify the CUDA and cuDNN installations.</li>
<li>Verify that the Maven build is successful and the dependencies are downloaded at <kbd>~/.m2/repository</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Enable logging levels to yield more information on errors:</li>
</ol>
<pre style="padding-left: 60px">Logger log = LoggerFactory.getLogger("YourClassFile.class");<br/> log.setLevel(Level.DEBUG);</pre>
<ol start="2">
<li>Verify the JDK/Maven installation and configuration. </li>
<li>Check whether all the required dependencies are added in the <kbd>pom.xml</kbd> file.</li>
<li>Remove the contents of the Maven local repository and rebuild Maven to mitigate <kbd>NoClassDefFoundError</kbd> in DL4J. For Linux, this is as follows:</li>
</ol>
<pre style="padding-left: 60px">rm -rf ~/.m2/repository/org/deeplearning4j<br/> rm -rf ~/.m2/repository/org/datavec<br/> mvn clean install</pre>
<ol start="5">
<li>Mitigate <kbd>ClassNotFoundException</kbd> in DL4J. You can try this if step 4 didn't help to resolve the issue. DL4J/ND4J/DataVec should have the same version. For CUDA-related error stacks, check the installation as well. </li>
</ol>
<div class="mce-root packt_tip">If adding the proper<span> </span>DL4J CUDA<em> </em>version doesn't fix this, then check your cuDNN installation.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To mitigate exceptions such as <kbd>ClassNotFoundException</kbd>, the primary task is to verify we installed the JDK properly (step 2) and whether the environment variables we set up point to the right place. Step 3 is also important as the missing dependencies result in the same error. </p>
<p>In step 4, we are removing redundant dependencies that are present in the local repository and are attempting a fresh Maven build. Here is a sample for <kbd>NoClassDefFoundError</kbd> while trying to run a DL4J application:</p>
<pre><strong>root@instance-1:/home/Deeplearning4J# java -jar target/dl4j-1.0-SNAPSHOT.jar</strong><br/><strong> 09:28:22.171 [main] INFO org.nd4j.linalg.factory.Nd4jBackend - Loaded [JCublasBackend] backend</strong><br/><strong> Exception in thread "main" java.lang.NoClassDefFoundError: org/nd4j/linalg/api/complex/IComplexDouble</strong><br/><strong> at java.lang.Class.forName0(Native Method)</strong><br/><strong> at java.lang.Class.forName(Class.java:264)</strong><br/><strong> at org.nd4j.linalg.factory.Nd4j.initWithBackend(Nd4j.java:5529)</strong><br/><strong> at org.nd4j.linalg.factory.Nd4j.initContext(Nd4j.java:5477)</strong><br/><strong> at org.nd4j.linalg.factory.Nd4j.(Nd4j.java:210)</strong><br/><strong> at org.datavec.image.transform.PipelineImageTransform.(PipelineImageTransform.java:93)</strong><br/><strong> at org.datavec.image.transform.PipelineImageTransform.(PipelineImageTransform.java:85)</strong><br/><strong> at org.datavec.image.transform.PipelineImageTransform.(PipelineImageTransform.java:73)</strong><br/><strong> at examples.AnimalClassifier.main(AnimalClassifier.java:72)</strong><br/><strong> Caused by: java.lang.ClassNotFoundException: org.nd4j.linalg.api.complex.IComplexDouble</strong></pre>
<p>One possible reason for <kbd>NoClassDefFoundError</kbd> could be the absence of required dependencies in the Maven local repository. So, we remove the repository contents and rebuild Maven to download the dependencies again. If any dependencies were not downloaded previously due to an interruption, it should happen now.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here is an example of <span><kbd>ClassNotFoundException</kbd> during DL4J training:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1197 image-border" src="assets/128dd62a-9167-4658-9060-b6a46a826555.png" style="width:77.00em;height:50.00em;"/></p>
<p>Again, this suggests version issues or redundant dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In addition to the common runtime issues that were discussed previously, Windows users may face cuDNN-specific errors<span> </span>while training a CNN. The actual root cause could be different and is tagged under <kbd>UnsatisfiedLinkError</kbd>:</p>
<pre><strong>o.d.n.l.c.ConvolutionLayer - Could not load CudnnConvolutionHelper</strong><br/><strong> java.lang.UnsatisfiedLinkError: no jnicudnn in java.library.path</strong><br/><strong> at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867) ~[na:1.8.0_102]</strong><br/><strong> at java.lang.Runtime.loadLibrary0(Runtime.java:870) ~[na:1.8.0_102]</strong><br/><strong> at java.lang.System.loadLibrary(System.java:1122) ~[na:1.8.0_102]</strong><br/><strong> at org.bytedeco.javacpp.Loader.loadLibrary(Loader.java:945) ~[javacpp-1.3.1.jar:1.3.1]</strong><br/><strong> at org.bytedeco.javacpp.Loader.load(Loader.java:750) ~[javacpp-1.3.1.jar:1.3.1]</strong><br/><strong> Caused by: java.lang.UnsatisfiedLinkError: C:\Users\Jürgen.javacpp\cache\cuda-7.5-1.3-windows-x86_64.jar\org\bytedeco\javacpp\windows-x86_64\jnicudnn.dll: Can't find dependent libraries</strong><br/><strong> at java.lang.ClassLoader$NativeLibrary.load(Native Method) ~[na:1.8.0_102]</strong></pre>
<p>Perform the following steps to fix the issue:</p>
<ol>
<li>Download the latest dependency walker here:<span> </span><a href="https://github.com/lucasg/Dependencies/">https://github.com/lucasg/Dependencies/</a>.</li>
<li>Add the following code to your DL4J<span> </span><kbd>main()</kbd><span> </span>method:</li>
</ol>
<pre style="padding-left: 60px">try {<br/> Loader.load(&lt;module&gt;.class);<br/> } catch (UnsatisfiedLinkError e) {<br/> String path = Loader.cacheResource(&lt;module&gt;.class, "windows-x86_64/jni&lt;module&gt;.dll").getPath();<br/> new ProcessBuilder("c:/path/to/DependenciesGui.exe", path).start().waitFor();<br/> }</pre>
<ol start="3">
<li>Replace <kbd>&lt;module&gt;</kbd><span> </span>with the name of the JavaCPP preset module that is experiencing the problem; for example, <kbd>cudnn</kbd>. For newer DL4J versions, the necessary CUDA libraries are bundled with DL4J. Hence, you should not face this issue.</li>
</ol>
<p class="mce-root">If you feel like you might have found a bug or functional error with DL4J, then feel free to create an issue tracker at <a href="https://github.com/eclipse/deeplearning4j">https://github.com/eclipse/deeplearning4j</a>.</p>
<p>You're also welcome to initiate a discussion with the Deeplearning4j community here: <a href="https://gitter.im/deeplearning4j/deeplearning4j">https://gitter.im/deeplearning4j/deeplearning4j</a>.</p>


            </article>

            
        </section>
    </body></html>