["```py\nimport numpy as np\ndef feed_forward(inputs, outputs, weights):\n     pre_hidden = np.dot(inputs,weights[0])+ weights[1]\n     hidden = 1/(1+np.exp(-pre_hidden))\n     out = np.dot(hidden, weights[2]) + weights[3]\n     squared_error = (np.square(pred_out - outputs))\n     return squared_error\n```", "```py\npre_hidden = np.dot(inputs,weights[0])+ weights[1]\n```", "```py\nhidden = 1/(1+np.exp(-pre_hidden))\n```", "```py\npred_out = np.dot(hidden, weights[2]) + weights[3]\n```", "```py\nsquared_error = (np.square(pred_out - outputs))\n```", "```py\ndef tanh(x):\n    return (exp(x)-exp(-x))/(exp(x)+exp(-x))\n```", "```py\ndef relu(x):\n    return np.where(x>0,x,0)\n```", "```py\ndef softmax(x):\n    return np.exp(x)/np.sum(np.exp(x))\n```", "```py\ndef mse(p, y):\n    return np.mean(np.square(p - y))\n```", "```py\ndef mae(p, y):\n    return np.mean(np.abs(p-y))\n```", "```py\ndef cat_cross_entropy(p, y):\n     return -np.sum((y*np.log2(p)+(1-y)*np.log2(1-p)))\n```", "```py\nx = [[1],[2],[3],[4]]\ny = [[2],[4],[6],[8]]\n```", "```py\nw = [[[1.477867]], [0.]]\n```", "```py\nimport numpy as np\ndef feed_forward(inputs, outputs, weights):\n     out = np.dot(inputs,weights[0]) + weights[1]\n     squared_error = (np.square(out - outputs))\n     return squared_error\n```", "```py\ndef update_weights(inputs, outputs, weights, epochs): \n     for epoch in range(epochs):\n```", "```py\n        org_loss = feed_forward(inputs, outputs, weights)\n```", "```py\n        wts_tmp = deepcopy(weights)\n        wts_tmp2 = deepcopy(weights)\n```", "```py\n        for i in range(len(weights)):\n             wts_tmp[-(i+1)] += 0.0001\n```", "```py\n            loss = feed_forward(inputs, outputs, wts_tmp)\n            delta_loss = np.sum(org_loss - loss)/(0.0001*len(inputs))\n```", "```py\n            wts_tmp2[-(i+1)] += delta_loss*0.01 \n            wts_tmp = deepcopy(weights)\n```", "```py\n    weights = deepcopy(wts_tmp2)\n return wts_tmp2\n```", "```py\nfrom copy import deepcopy\nimport numpy as np\n\nx = [[1],[2],[3],[4]]\ny = [[2],[4],[6],[8]]\n```", "```py\nw = [[[-0.82203424, -0.9185806 , 0.03494298]], [0., 0., 0.], [[ 1.0692896 ],[ 0.62761235],[-0.5426246 ]], [0]]\n```", "```py\ndef feed_forward(inputs, outputs, weights):\n     pre_hidden = np.dot(inputs,weights[0])+ weights[1]\n     hidden = np.where(pre_hidden<0, 0, pre_hidden) \n     out = np.dot(hidden, weights[2]) + weights[3]\n     squared_error = (np.square(out - outputs))\n     return squared_error\n```", "```py\ndef update_weights(inputs, outputs, weights, epochs): \n     for epoch in range(epochs):\n         org_loss = feed_forward(inputs, outputs, weights)\n```", "```py\n        wts_new = deepcopy(weights)\n        wts_new2 = deepcopy(weights)\n```", "```py\n         for i, layer in enumerate(reversed(weights)):\n            for index, weight in np.ndenumerate(layer):\n                wts_tmp[-(i+1)][index] += 0.0001\n                loss = feed_forward(inputs, outputs, wts_tmp)\n                del_loss = np.sum(org_loss - loss)/(0.0001*len(inputs))\n```", "```py\n               wts_tmp2[-(i+1)][index] += del_loss*0.01\n               wts_tmp = deepcopy(weights)\n```", "```py\n\n          weights = deepcopy(wts_tmp2)\n return wts_tmp2\n```", "```py\nupdate_weights(x,y,w,1)\n```", "```py\n$pip install --no-cache-dir tensorflow-gpu==1.7\n```", "```py\n$pip install keras\n```", "```py\nfrom keras.models import Sequential\nmodel = Sequential()\n```", "```py\nmodel.add(Dense(3, activation='relu', input_shape=(1,)))\n```", "```py\nmodel.add(Dense(1, activation='linear'))\n```", "```py\nmodel.summary()\n```", "```py\nfrom keras.optimizers import sgd\nsgd = sgd(lr = 0.01)\n```", "```py\nmodel.compile(optimizer=sgd,loss='mean_squared_error')\n```", "```py\nmodel.fit(np.array(x), np.array(y), epochs=1, batch_size = 4, verbose=1)\n```", "```py\nmodel.weights\n```", "```py\nmodel.get_weights()\n```", "```py\nx1 = [[5],[6]]\nmodel.predict(np.array(x1))\n```"]