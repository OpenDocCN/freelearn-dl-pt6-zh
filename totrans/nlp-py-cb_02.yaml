- en: Raw Text, Sourcing, and Normalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of string operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting deeper with string operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a PDF file in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading Word documents in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking  PDF, DOCX, and plain text files and creating a user-defined corpus from
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading contents from an RSS feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML parsing using BeautifulSoup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we looked at NLTK inbuilt corpora. The corpora are
    very well organized and normalized for usage, but that will not always be the
    case when you work on your industry problems. Let alone normalization and organization,
    we may not even get the data we need in a uniform format. The goal of this chapter
    is to introduce some Python libraries that will help you extract data from binary
    formats: PDF and Word DOCX files. We will also look at libraries that can fetch
    data from web feeds such as RSS and a library that will help you parse HTML and
    extract the raw text out of the documents. We will also learn to extract raw text
    from heterogeneous sources, normalize it, and create a user-defined corpus from
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn seven different recipes. As the name of the
    chapter suggests, we will be learning to source data from PDF files, Word documents,
    and the Web. PDFs and Word documents are binary, and over the Web, you will get
    data in the form of HTML. For this reason, we will also perform normalization and
    raw text conversion tasks on this data.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of string operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an NLP expert, you are going to work on a lot of textual content. And when
    you are working with text, you must know string operations. We are going to start
    with a couple of short and crisp recipes that will help you understand the `str`
    class and operations with it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you will just need the Python interpreter and a text editor,
    nothing more. We will see `join`, `split`, `addition`, and `multiplication` operators
    and indices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new Python file named `StringOps1.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define two objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first object, `nameList`, is a list of `str` objects containing some names
    as implied, and the second object, `sentence`, is a sentence that is an `str`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will see the join functionality and what it does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `join()` function can be called on any `string` object. It accepts a list
    of `str` objects as argument and concatenates all the star objects into a single
    `str` object, with the calling string object''s contents as the joining delimiter.
    It returns that object. Run these two lines and your output should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will check out the `split` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split` function called on a string will split its contents into multiple
    `str` objects, create a list of the same, and return that list. The function accepts
    a single `str` argument, which is used as the splitting criterion. Run the code
    and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The arithmetic operators `+` and `*` can also be used with strings. Add the
    following lines and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we will first see the output and then discuss how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `+` operator is known as concatenation. It produces a new string, concatenating
    the strings into a single `str` object. Using the `*` operator, we can multiply
    the strings too, as shown previously in the output. Also, please note that these
    operations don't add anything extra, such as insert a space between the strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the indices of the characters in the strings. Add the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we declare a new `string` object. Then we access the second character
    (`y`) in the string, which just shows that it is straightforward. Now comes the
    tricky part; Python allows you to use negative indexes when accessing any list
    object; `-1` means the last member, `-2` is the second last, and so on. For example,
    in the preceding `str` object, index `7` and `-4` are the same character, `N`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a list of strings from a string and a string from a list of strings
    using the `split()` and `join()` functions, respectively. Then we saw the use
    of some arithmetic operators with strings. Please note that we can't use the "`-`"(negation)
    and the "`/`"(division) operators with strings. In the end, we saw how to access
    individual characters in any string, in which peculiarly, we can use negative
    index numbers while accessing strings.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is pretty simple and straightforward, in that the objective was
    to introduce some common and uncommon string operations that Python allows. Up
    next, we will continue where we left off and do some more string operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting deeper with string operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving ahead from the previous recipe, we will see substrings, string replacements,
    and how to access all the characters of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Python file named `StringOps2.py` and define the following string
    object `str`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's access the substring that ends at the fourth character from the `str` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know the index starts at zero, this will return the substring containing
    characters from zero to three. When you run, the output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will access the substring that starts at a certain point until the end
    in object `str`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the interpreter to return a substring of object `str` from index
    `11` to the end. When you run this, the following output will be visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s access the `Dolly` substring from the `str` object. Add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax returns characters from index `5` to `10`, excluding the
    10th character. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time for a fancy trick. We have already seen how negative indices
    work for string operations. Let''s try the following and see how it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Exactly similar to the previous step! Go ahead and do the back calculations: `-1`
    as the last character, `-2` as the last but one, and so and so forth. Thus, you
    will get the index values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the `in` operator with `if`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code and check the output; it will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As elaborate as it looks, the `in` operator simply checks whether the left-hand
    side string is a substring of the right-hand side string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the simple `replace` function on an `str` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `replace` function simply takes two arguments. The first is the substring
    that needs to be replaced and the second is the new substring that will come in
    place of it. It returns a new `string` object and doesn''t modify the object it
    was called upon. Run and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we will iterate over the `replaced` object and access every
    character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print each character from the replaced object on a new line. Let''s
    see the final output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `string` object is nothing but a list of characters. As we saw in the first
    step we can access every character from the string using the `for` syntax for
    accessing a list. The character `:` inside square brackets for any list denotes
    that we want a piece of the list; `:` followed by a number means we want the sublist
    starting at zero and ending at the index minus 1\. Similarly, a number followed
    by `a :` means we want a sublist from the given number to the end.
  prefs: []
  type: TYPE_NORMAL
- en: This ends our brief journey of exploring string operations with Python. After
    this, we will move on to files, online resources, HTML, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a PDF file in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start off with a small recipe for accessing PDF files from Python. For this,
    you need to install the `PyPDF2` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We assume you have `pip` installed. Then, to install the `PyPDF2` library with
    `pip` on Python 2 and 3, you only need to run the following command from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you successfully install the library, we are ready to go ahead. Along with
    that, I also that request you to download some test documents that we will be
    using during this chapter from this link: [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `pdf.py` and add the following import line to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It imports the `PdfFlleReader` class from the lib `PyPDF2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this Python function in the file that is supposed to read the file and
    return the full text from the PDF file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts two arguments, the path to the PDF file you want to read
    and the password (if any) for the PDF file. As you can see, the `password` parameter
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define the function. Add the following lines under the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line opens the file in read and backwards seek mode. The first line
    is essentially the Python open file command/function that will only open a file
    that is non-text in binary mode. The second line will pass this opened file to
    the `PdfFileReader` class, which will consume the PDF document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to decrypt password-protected files, if any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If a password is provided with the function call, then we will try to decrypt
    the file using the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will read the text from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We create a list of strings and append text from each page to that list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the final output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We return the single `string` object by joining the contents of all the string
    objects inside the list with a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file named `TestPDFs.py` in the same folder as `pdf.py`, and
    add the following import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll just print out the text from a couple of documents, one password
    protected and one plain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**: The first six steps of the recipe only create a Python function
    and no output will be generated on the console. The seventh and eighth steps will
    output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PyPDF2` is a pure Python library that we use to extract content from PDFs.
    The library has many more functionalities to crop pages, superimpose images for
    digital signatures, create new PDF files, and much more. However, your purpose
    as an NLP engineer or in any text analytics task would only be to read the contents.
    In step *2*, it''s important to open the file in backwards seek mode since the
    `PyPDF2` module tries to read files from the end when loading the file contents.
    Also, if any PDF file is password protected and you do not decrypt it before accessing
    its contents, the Python interpreter will throw a `PdfReadError`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading Word documents in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to load and read Word/DOCX documents. The libraries
    available for reading DOCX word documents are more comprehensive, in that we can
    also see paragraph boundaries, text styles, and do what are called runs. We will
    see all of this as it can prove vital in your text analytics tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have access to Microsoft Word, you can always use open source
    versions of Liber Office and Open Office to create and edit `.docx` files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you already have `pip` installed on your machine, we will use pip
    to install a module named `python-docx`. Do not confuse this with another library
    named `docx`, which is a different module altogether. We will be importing the
    `docx` object from the `python-docx` library. The following command, when fired
    on your command line, will install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After having successfully installed the library, we are ready to go ahead. We
    will be using a test document in this recipe, and if you have already downloaded
    all the documents from the link shared in the first recipe in this chapter, you
    should have the relevant document. If not, then please download the `sample-one-line.docx`
    document from [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0).
  prefs: []
  type: TYPE_NORMAL
- en: Now we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Python file named `word.py` and add the following `import` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Simply import the `docx` object of the `python-docx` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function `getTextWord`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The function accepts one `string` parameter, `wordFileName`, which should contain
    the absolute path to the Word file you are interested in reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the `doc` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `doc` object is now loaded with the word file you want to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will read the text from the document loaded inside the `doc` object. Add
    the following lines for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialized a string array, `fullText`. The `for` loop reads the text
    from the document paragraph by paragraph and goes on appending to the list `fullText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will join all the fragments/paras in a single string object and return
    it as the final output of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We joined all the constituents of the `fullText` array with the delimited `\n` and
    returned the resultant object. Save the file and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file, name it `TestDocX.py`, and add the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Simply import the `docx` library and the `word.py` that we wrote in the first
    five steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will read a DOCX document and print the full contents using the API
    we wrote on `word.py.` Write down the following two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the document path in the first line, and then, using the API print
    out the full document. When you run this part, you should get an output that looks
    something similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a sample PDF document with some text in bold, some in italic, and some
    underlined. We are also embedding a title shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As already discussed, Word/DOCX documents are a much richer source of information
    and the libraries will give us much more than text. Now let us look at the paragraph
    information. Add the following four lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line in the previous snippet gives us the number of paragraphs in
    the given document. The third line returns only the second paragraph from the
    document and the fourth line will analyze the style of the second paragraph, which
    is `Title` in this case. When you run, the output for these four lines will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is quite self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will see what a run is. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are first returning the first paragraph; next we are returning the
    number of runs in the paragraph. Later we are printing out every run.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now to identify the styling of each run, write the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the previous snippet is checking for underline, bold, and italic
    styling respectively. In the following section, we will see the final output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we wrote a function in the `word.py` file that will read any given DOCX
    file and return to us the full contents in a `string` object. The preceding output
    text you see is fairly self-explanatory though some things I would like to elaborate
    are `Paragraph` and `Run` lines. The structure of a `.docx` document is represented
    by three data types in the `python-docx` library. At the highest level is the
    `Document` object. Inside each document, we have multiple paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we see a new line or a carriage return, it signifies the start of
    a new paragraph. Every paragraph contains multiple `Runs` , which denotes a change
    in word styling. By styling, we mean the possibilities of different fonts, sizes,
    colors, and other styling elements such as bold, italic, underline, and so on.
    Each time any of these elements vary, a new run is started.
  prefs: []
  type: TYPE_NORMAL
- en: Taking PDF, DOCX, and plain text files and creating a user-defined corpus from
    them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we are not going to use anything new in terms of libraries
    or concepts. We are reinvoking the concept of corpus from the first chapter. Just
    that we are now going to create our own corpus here instead of using what we got
    from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In terms of getting ready, we are going to use a few files from the Dropbox
    folder introduced in the first recipe of this chapter. If you''ve downloaded all
    the files from the folder, you should be good. If not, please download the following
    files from [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0):'
  prefs: []
  type: TYPE_NORMAL
- en: '`sample_feed.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample-pdf.pdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample-one-line.docx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven't followed the order of this chapter, you will have to go back
    and look at the first two recipes in this chapter. We are going to reuse two modules
    we wrote in the previous two recipes, `word.py` and `pdf.py`. This recipe is more
    about an application of what we did in the first two recipes and the corpus from
    the first chapter than introducing a new concept. Let's get on with the actual
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Python file named `createCorpus.py` and add the following import
    lines to start off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We have imported the `os` library for use with file operations, the `word` and
    `pdf` modules we wrote in the first two recipes of this chapter, and the `PlaintextCorpusReader`,
    which is our final objective of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write a little function that will take as input the path of a plain
    text file and return the full text as a `string` object. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the function and input parameter. The second line opens
    the given file in reading mode (the second parameter of the open function `r`
    denotes read mode). The third line reads the content of the file and returns it
    into a `string` object, all at once in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the new `corpus` folder now on the disk/filesystem. Add the
    following three lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a simple `string` object with the name of the new folder.
    The second line checks whether a directory/folder of the same name already exists
    on the disk. The third line instructs the `os.mkdir()` function to create the
    directory on the disk with the specified name. As the outcome, a new directory
    with the name `mycorpus` would be created in the working directory where your
    Python file is placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will read the three files one by one. Starting with the plain text file,
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `getText()` function written earlier, it will read the `sample_feed.txt`
    file and return the output in the `txt1` string object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will read the PDF file. Add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using the `pdf.py` module's `getTextPDF()` function, we are retrieving the contents
    of the `sample-pdf.pdf` file into the `txt2` string object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will read the DOCX file by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using the `word.py` module's `getTextWord()` function, we are retrieving the
    contents of the `sample-one-line.docx` file into the `txt3` string object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write the contents of these three string objects on the
    disk, in files. Write the following lines of code for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**First line**: Creates an array from the string objects so as to use it in
    the upcoming for loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second line**: A `for` loop with index on the files array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third line**: This opens a new file in write mode (the `w` option in the
    open function call)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fourth line**: Writes the contents of the string object in the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will create a `PlainTextCorpus` object from the `mycorpus` directory,
    where we have stored our files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A simple one-line instruction but internally it does a lot of text processing,
    identifying paragraphs, sentences, words, and much more. The two parameters are
    the path to the corpus directory and the pattern of the filenames to consider
    (here we have asked the corpus reader to consider all files in the directory).
    We have created a user-defined corpus. As simple as that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see whether the our `PlainTextCorpusReader` is loaded correctly. Add
    the following lines of code to test it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line will print the array containing all the words in the corpus
    (curtailed). The second line will print the sentences in file `1.txt`. The third
    line will print the paragraphs in file `0.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The output is fairly straightforward and as explained in the last step of the
    recipe. What is peculiar is the characteristics of each of objects on show. The
    first line is the list of all words in the new corpus; it doesn't have anything
    to do with higher level structures like sentences/paragrpahs/files and so on.
    The second line is the list of all sentences in the file `1.txt`, of which each
    sentence is a list of words inside each of the sentences. The third line is a
    list of paragraphs, of which each paragraph object is in turn a list of sentences,
    of which each sentence is in turn a list of words in that sentence, all from the
    file `0.txt`. As you can see, a lot of structure is maintained in paragraphs and
    sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Read contents from an RSS feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Rich Site Summary** (**RSS**) feed is a computer-readable format in which
    regularly changing content on the Internet is delivered. Most of the websites
    that provide information in this format give updates, for example, news articles,
    online publishing and so on. It gives the listeners access to the updated feed
    at regular intervals in a standardized format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this recipe is to read such an RSS feed and access content
    of one of the posts from that feed. For this purpose, we will be using the RSS
    feed of Mashable. Mashable is a digital media website, in short a tech and social
    media blog listing. The URL of the website's RS feed is [http://feeds.mashable.com/Mashable](http://feeds.mashable.com/Mashable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need the `feedparser` library to be able to read an RSS feed. To install
    this library on your computer, simply open the terminal and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Armed with this module and the useful information, we can begin to write our
    first RSS feed reader in Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file named `rssReader.py` and add the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will load the Mashable feed into our memory. Add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `myFeed` object contains the first page of the RSS feed of Mashable. The
    feed will be downloaded and parsed to fill all the appropriate fields by the `feedparser`.
    Each post will be part of the entry list in to the `myFeed` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the title and count the number of posts in the current feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we are fetching the feed title from the `myFeed` object,
    and in the second line, we are counting the length of the `entries` object inside
    the `myFeed` object. The `entries` object is nothing but a list of all the posts
    from the parsed feed as mentioned previously. When you run, the output is something
    similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`Title` will always be Mashable, and at the time of writing this chapter, the
    Mashable folks were putting a maximum of 30 posts in the feed at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will fetch the very first `post` from the entries list and print it''s
    title on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we are physically accessing the zeroth element in the entries
    list and loading it in the `post` object. The second line prints the title of
    that post. Upon running, you should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: I say something similar and not exactly the same as the feed keeps updating
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will access the raw HTML content of the post and print it on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'First we access the content object from the post and the actual value of the
    same. And then we print it on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the RSS feeds you will get on the Internet will follow a chronological
    order, with the latest post on top. Hence, the post we accessed in the recipe
    will be always be the most recent post the feed is offering. The feed itself is
    ever-changing. So every time you run the program, the format of the output will
    the remain same, but the content of the post on the console may differ depending
    upon how fast the feed updates. Also, here we are directly displaying the raw
    HTML on the console and not the clean content. Up next, we are going to look at
    parsing HTML and getting only the information we need from a page. Again, a further
    addendum to this recipe could be to read any feed of your choice, store all the
    posts from the feed on disk, and create a plain text corpus using it. Needless
    to say, you can take inspiration from the previous and the next recipes.
  prefs: []
  type: TYPE_NORMAL
- en: HTML parsing using BeautifulSoup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the times when you have to deal with data on the Web, it will be in
    the form of HTML pages. For this purpose, we thought it is necessary to introduce
    you to HTML parsing in Python. There are many Python modules available to do this,
    but in this recipe, we will see how to parse HTML using the library `BoutifulSoup4`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The package `BeautifulSoup4` will work for Python 2 and Python 3\. We will
    have to download and install this package on our interpreter before we can start
    using it. In tune with what we have been doing throughout, we will use the pip
    install utility for it. Run the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with this module, you will also need the `sample-html.html` file from
    the chapter''s Dropbox location. In case you haven''t downloaded the files already,
    here''s the link again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you have already installed the required package, start with the following
    import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We have imported the `BeautifulSoup` class from the module `bs4`, which we will
    be using to parse the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load the HTML file into the `BeautifulSoup` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we load the `sample-html.html` file's content into the `str`
    object `html_doc`. Next we create a `BeautifulSoup` object, passing to it the
    contents of our HTML file as the first argument and `html.parser` as the second
    argument. We instruct it to parse the document using the `html` parser. This will
    load the document into the `soup` object, parsed and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, simplest, and most useful task on this `soup` object will be to
    strip all the HTML tags and get the text content. Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_text()` method called on the `soup` object will fetch us the HTML
    stripped content of the file. If you run the code written so far, you will get
    this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it''s not enough to have pure HTML stripped content. You may also
    need specific tag contents. Let''s access one of the tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `soup.title` will return the first title tag it encounters in the file.
    Output of these lines will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us get only the HTML stripped text from a tag now. We will grab the text
    of the `<h1>` tag with the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `soup.h1.string` will return the text surrounded by the first `<h1>`
    tag encountered. The output of this line will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will access attributes of a tag. In this case, we will access the `alt`
    attribute of the `img` tag; add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully; the syntax to access attributes of a tag is different than
    accessing the text. When you run this piece of code, you will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there can be multiple occurrences of any type of tag in an HTML file.
    Simply using the `.` syntax will only fetch you the first instance. To fetch all
    instances, we use the `find_all()` functionality, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_all()` function called on a `BeautifulSoup` object will take as an
    argument the name of the tag, search through the entire HTML tree, and return
    all occurrences of that tag as a list. We are accessing that list in the `for`
    loop and printing the content/text of all the `<p>` tags in the given `BeautifulSoup`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BeautifulSoup 4 is a very handy library used to parse any HTML and XML content.
    It supports Python's inbuilt HTML parser, but you can also use other third-party
    parsers with it, for example, the `lxml` parser and the pure-Python `html5lib`
    parser. In this recipe, we used the Python inbuilt HTML parser. The output generated
    is pretty much self-explanatory, and of course, the assumption is that you do
    know what HTML is and how to write simple HTML.
  prefs: []
  type: TYPE_NORMAL
