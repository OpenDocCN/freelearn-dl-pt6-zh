["```py\n// Operator Definition\nmessage OperatorDef {\n  repeated string input = 1; // the name of the input blobs\n  repeated string output = 2; // the name of output top blobs\n  optional string name = 3; // the operator name. This is optional.\n  // the operator type. This is needed to create the object from the \n  //operator\n  // registry.\n  optional string type = 4;\n  repeated Argument arg = 5;\n\n  // The device option that the operator should run under.\n  optional DeviceOption device_option = 6;\n\n  // Optionally, one can specify an engine when there are multiple\n  // implementations available simultaneously for one device type.\n  // If one specifies an engine but that engine does not exist in the    \n  //compiled\n  // Caffe2 binary, Caffe2 will fall back to the default engine of that \n  //device\n  // type.\n  optional string engine = 7;\n\n  // Additional 'fake' inputs used for expressing control dependencies\n  // in the operator graph. This can be used to ensure that an\n  // operator does not run until another operator is ready, for e.g.\n  // scheduling control. These are not passed as actual inputs to the\n  // Operator implementation, and are only used by the Net class for\n  // scheduling purposes.\n  repeated string control_input = 8;\n\n  // is_gradient_op argument is only used as a hint in shape inference\n  // and has no runtime significance\n  optional bool is_gradient_op = 9 [0,1][default = false];\n\n  // debug information associated with the construction of the \n  //operator.\n  // This is an optional string with no assumed characteristics as\n  // operators can be constructed in any language.\n  optional string debug_info = 10;\n}\n```", "```py\nmodel = model_helper.ModelHelper(\"MatMul model\")\nmodel.net.MatMul([\"A\", \"B\"], \"C\")\n```", "```py\n#!/usr/bin/env python2\n\n\"\"\"Create a network that performs some mathematical operations.\nRun inference on this network.\"\"\"\n\nfrom caffe2.python import workspace, model_helper\nimport numpy as np\n\n# Initialize Caffe2\nworkspace.GlobalInit([\"caffe2\",])\n\n# Initialize a model with the name \"Math model\"\nmodel = model_helper.ModelHelper(\"Math model\")\n\n# Add a matrix multiplication operator to the model.\n# This operator takes blobs \"A\" and \"B\" as inputs and produces blob \"C\" as output.\nmodel.net.MatMul([\"A\", \"B\"], \"C\")\n\n# Add a Sigmoid operator to the model.\n# This operator takes blob \"C\" as input and produces blob \"D\" as output.\nmodel.net.Sigmoid(\"C\", \"D\")\n\n# Add a Softmax operator to the model.\n# This operator takes blob \"D\" as input and produces blob \"E\" as output.\nmodel.net.Softmax(\"D\", \"E\", axis=0)\n\n# Create input A, a 3x3 matrix initialized with some values\nA = np.linspace(-0.4, 0.4, num=9, dtype=np.float32).reshape(3, 3)\n\n# Create input B, a 3x1 matrix initialized with some values\nB = np.linspace(0.01, 0.03, num=3, dtype=np.float32).reshape(3, 1)\n\n# Feed A and B to the Caffe2 workspace as blobs.\n# Provide names \"A\" and \"B\" for these blobs.\nworkspace.FeedBlob(\"A\", A)\nworkspace.FeedBlob(\"B\", B)\n\n# Run the network inside the Caffe2 workspace.\nworkspace.RunNetOnce(model.net)\n\n# Extract blob \"E\" from the workspace.\nE = workspace.FetchBlob(\"E\")\n\n# Print inputs A and B and final output E\nprint A\nprint B\nprint E\n```", "```py\nfrom caffe2.python import workspace, model_helper\nimport numpy as np\n```", "```py\nworkspace.GlobalInit([\"caffe2\",])\n```", "```py\n# Initialize a model with the name \"Math model\"\nmodel = model_helper.ModelHelper(\"Math model\")\n```", "```py\n# Add a matrix multiplication operator to the model.\n# This operator takes blobs \"A\" and \"B\" as inputs and produces blob \"C\" as output.\nmodel.net.MatMul([\"A\", \"B\"], \"C\")\n```", "```py\n# Add a Sigmoid operator to the model.\n# This operator takes blob \"C\" as input and produces blob \"D\" as output.\nmodel.net.Sigmoid(\"C\", \"D\")\n```", "```py\n# Add a Softmax operator to the model.\n# This operator takes blob \"D\" as input and produces blob \"E\" as output.\nmodel.net.Softmax(\"D\", \"E\", axis=0)\n```", "```py\n# Create input A, a 3x3 matrix initialized with some values\nA = np.linspace(-0.4, 0.4, num=9, dtype=np.float32).reshape(3, 3)\n\n# Create input B, a 3x1 matrix initialized with some values\nB = np.linspace(0.01, 0.03, num=3, dtype=np.float32).reshape(3, 1)\n```", "```py\n# Feed A and B to the Caffe2 workspace as blobs.\n# Provide names \"A\" and \"B\" for these blobs.\nworkspace.FeedBlob(\"A\", A)\nworkspace.FeedBlob(\"B\", B)\n```", "```py\n# Run the network inside the Caffe2 workspace.\nworkspace.RunNetOnce(model.net)\n```", "```py\n# Extract blob \"E\" from the workspace.\nE = workspace.FetchBlob(\"E\")\n\n# Print inputs A and B and final output E\nprint A\nprint B\nprint E\n```", "```py\n$ ./computation_graph.py\nA: [[-0.4 -0.3 -0.2]\n [-0.1  0\\.   0.1]\n [ 0.2  0.3  0.4]]\nB: [[0.01]\n [0.02]\n [0.03]]\nE: [[0.3318345 ]\n [0.33333108]\n [0.33483443]]\n```", "```py\n# Number of digits in MNIST\nMNIST_DIGIT_NUM = 10\n# Every grayscale image in MNIST is of dimensions 28x28 pixels in a single channel\nMNIST_IMG_HEIGHT = 28\nMNIST_IMG_WIDTH = 28\nMNIST_IMG_PIXEL_NUM = MNIST_IMG_HEIGHT * MNIST_IMG_WIDTH\n```", "```py\n# Create first pair of fullyconnected and ReLU activation layers\n# This FC layer is of size (MNIST_IMG_PIXEL_NUM * 2)\n# On its input side it is fed the MNIST_IMG_PIXEL_NUM pixels\n# On its output side it is connected to a ReLU layer\nfc_layer_0_input_dims = MNIST_IMG_PIXEL_NUM\nfc_layer_0_output_dims = MNIST_IMG_PIXEL_NUM * 2\nfc_layer_0 = brew.fc(\n    model,\n    input_blob_name,\n    \"fc_layer_0\",\n    dim_in=fc_layer_0_input_dims,\n    dim_out=fc_layer_0_output_dims\n)\nrelu_layer_0 = brew.relu(model, fc_layer_0, \"relu_layer_0\")\n```", "```py\n# Create second pair of fullyconnected and ReLU activation layers\nfc_layer_1_input_dims = fc_layer_0_output_dims\nfc_layer_1_output_dims = MNIST_IMG_PIXEL_NUM * 2\nfc_layer_1 = brew.fc(\n    model,\n    relu_layer_0,\n    \"fc_layer_1\",\n    dim_in=fc_layer_1_input_dims,\n    dim_out=fc_layer_1_output_dims\n)\nrelu_layer_1 = brew.relu(model, fc_layer_1, \"relu_layer_1\")\n# Create third pair of fullyconnected and ReLU activation layers\nfc_layer_2_input_dims = fc_layer_1_output_dims\nfc_layer_2_output_dims = MNIST_IMG_PIXEL_NUM\nfc_layer_2 = brew.fc(\n    model,\n    relu_layer_1,\n    \"fc_layer_2\",\n    dim_in=fc_layer_2_input_dims,\n    dim_out=fc_layer_2_output_dims\n)\nrelu_layer_2 = brew.relu(model, fc_layer_2, \"relu_layer_2\")\n```", "```py\n# Create a softmax layer to provide output probabilities for each of\n# 10 digits. The digit with highest probability value is considered to be\n# the prediction of the network.\nsoftmax_layer = brew.softmax(model, relu_layer_2, \"softmax_layer\")\n```", "```py\nfor i, layer_blob_name in enumerate(inference_model.params):\n   layer_weights_filepath = \"mnist_mlp_weights/{}.npy\".format(str(i))\n   layer_weights = np.load(layer_weights_filepath, allow_pickle=False)\n   workspace.FeedBlob(layer_blob_name, layer_weights)\n```", "```py\n# Read MNIST images from file to use as input\ninput_blob = None\nwith open(\"mnist_data.npy\") as in_file:\n   input_blob = np.load(in_file)\n# Set MNIST image data as input data\nworkspace.FeedBlob(\"data\", input_blob)\n```", "```py\nworkspace.RunNetOnce(inference_model.net)\n```", "```py\nnetwork_output = workspace.FetchBlob(\"softmax_layer\")\nfor i in range(len(network_output)):\n    # Get prediction and confidence by finding max value and its index \n    # in preds array\n    prediction, confidence = max(enumerate(network_output[i]), \n    key=operator.itemgetter(1))\n    print(\"Input: {} Prediction: {} Confidence: {}\".format(i, \n    prediction, confidence)\n```", "```py\nInput: 0 Prediction: 5 Confidence: 0.609326720238\nInput: 1 Prediction: 7 Confidence: 0.99536550045\nInput: 2 Prediction: 9 Confidence: 0.877566576004\nInput: 3 Prediction: 9 Confidence: 0.741059184074\nInput: 4 Prediction: 2 Confidence: 0.794860899448\nInput: 5 Prediction: 0 Confidence: 0.987336695194\nInput: 6 Prediction: 7 Confidence: 0.900308787823\nInput: 7 Prediction: 1 Confidence: 0.993218839169\nInput: 8 Prediction: 6 Confidence: 0.612009465694\n```"]