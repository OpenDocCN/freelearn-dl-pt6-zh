- en: Rule-Based System for NLP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned to derive various features by using the concepts of linguistics
    and statistics in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml), *Feature
    Engineering and NLP Algorithms* and [Chapter 6](c4861b9e-2bcf-4fce-94d4-f1e2010831de.xhtml),
    *Advanced Feature Engineering and NLP Algorithms*. For developing an NLP application,
    these features are going to be fed into the algorithms. These algorithms take
    features as input. As you know, we are referring to algorithms as black boxes
    that perform some kind of magic and gives us the appropriate output. Refer to
    *Figure 7.1*, which demonstrates our journey so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/177ea531-388f-40dd-aaf5-590ead0a3f4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Stages we have learned so far'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have learned a lot about NLP, and specifically about the
    NLU!
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is high time for us to explore the algorithms which we use to develop
    NLP applications. We refer to these algorithms, techniques, or approaches as our
    black boxes and their logic is works as some magic for us. Now, it's time to dive
    deep into these black boxes and understand the magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms (implementation techniques or approaches) for NLP applications can
    be divided into two parts. Refer to *Figure 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ac4fc1a-6734-4476-bf61-e64c3b495e59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Algorithms or approaches or implementation techniques for black
    boxes'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the **rule-based** (**RB**) system in this chapter and machine
    learning approaches in [Chapter 8](97808151-90d2-4034-8d53-b94123154265.xhtml),
    *Machine Learning for NLP Problems* and [Chapter 9](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml),
    *Deep Learning for NLP and NLG Problems*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on the rule-based system. We are going
    to touch upon the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding of the RB system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purpose of having the RB system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of the RB system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the RB system development life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing NLP applications using the RB system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the RB approach with other approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recent trends for the RB system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding of the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RB systems are also known as **knowledge-based systems**. But first, we will
    see what the RB system means and what it does for us? What kind of NLP applications
    can be implemented by using this approach? For a better understanding, I will
    explain the concepts with the help of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: What does the RB system mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule-based system is defined as by using available knowledge or rules,
    we develop such a system which uses the rules, apply the available system rules
    on a corpus and try to generate or inference the results. Refer *Figure 7.3*,
    which will give you an idea about the RB system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a699c8-d489-42d4-9204-daaa0baff37c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Rule based system input/output flow'
  prefs: []
  type: TYPE_NORMAL
- en: In short, you can say that the RB system is all about applying real-life rules
    or experiences to a available corpus, manipulating information as per the rules,
    and deriving certain decisions or results. Here, rules are generated or created
    by humans.
  prefs: []
  type: TYPE_NORMAL
- en: The RB system is used for interpreting available corpus (information) in a useful
    manner. Here, rules act as core logic for the RB system. The corpus is interpreted
    based on rules or knowledge, so our end result is dependent on these two factors,
    one is rules and the second is our corpus.
  prefs: []
  type: TYPE_NORMAL
- en: Now I will explain one of the **AI** (**Artificial Intelligence**) applications
    for getting the core essence of the RB system.
  prefs: []
  type: TYPE_NORMAL
- en: As humans, we all do very complicated work every day to perform some tasks.
    To perform tasks, we use our prior experiences or follow rules to successfully
    complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example: If you are driving a car, you are following some rules. You
    have prior knowledge of these rules. Now, if you think about the self-driving
    car, then that car should react or perform the entire task that a human was doing
    previously. But cars don''t understand how to drive automatically without a driver.
    To develop this kind of driver less car is quite complicated, as well as challenging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyhow, you want to create a self-driving car. You know there are so many rules
    that the car needs to learn in order to perform as well as a human driver. Here
    you have a few major challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a kind of complicated application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of rules as well as situations need to be learned by the car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accuracy of the self-driving car should be high enough to launch it on the
    market for the consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to solve the challenges, we follow various steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We first try to reduce the problem statement to small chunks of a problem which
    is a subset of our original problem statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We try to solve small chunks of the problem first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve it, we are trying to come up with generalized rules that help us to
    solve our problem as well as help us to achieve our end goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our version of the driver less (self-driving) car, we need to think from
    the software perspective. So, what is the first step the car should learn? Think!
  prefs: []
  type: TYPE_NORMAL
- en: The car should learn to see and identify objects on the road. This is the first
    step for our car and we define some generalized rules which the car will use to
    learn and decide whether there is any object on the road?, then drive based on
    that. What should the speed of the car when it sees road conditions? And so on,
    (think right now using the rule-based system, and for some time don't think about
    the deep learning aspect to solve this step).
  prefs: []
  type: TYPE_NORMAL
- en: For every small part of our task, we try to define rules and feed that rule
    logic into the RB system. Then, we check whether that rule worked out properly
    on the given input data. We will also measure the performance of the system after
    getting the output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you must be thinking this is a book about NLP, so why am I giving an example
    of a generalized AI application? The reason behind it is that the self-driving
    car example is easy to relate to and can be understood by everyone. I want to
    highlight some of the points that also help us to understand the purpose of having
    a rule-based system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one general example and understand the purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: This self-driving car example helps you in identifying that sometimes a task
    that is very easy for a human to perform is so much more complicated for machines
    to do by themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These kinds of complicated tasks need high accuracy! I mean very high!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't expect our system to cover and learn about all situations, but whatever
    rules we feed into the system, it should learn about those situations in the best
    manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the RB system, the coverage of various scenarios is less but accuracy of
    the system should be high. That is what we need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our rules are derived from real-life human experience or by using knowledge
    of humans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development and implementation of rules is done by humans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these points help us to decide when and where to use a rule-based system.
    This leads us to define our purpose of having a rule-based system. So let's jump
    into the next section where we define a rule of thumb for using the rule-based
    approach for any NLP or AI-related application.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of having the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, the rule-based system is used for developing NLP applications and
    generalized AI applications. There are bunch of questions that we need to answer
    to generate a clear picture about the rule-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need the rule-based system?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule-based system tries to mimic human expert knowledge for the NLP applications.
    Here, we are going to address the factors that will help you to understand the
    purpose of the RB system:'
  prefs: []
  type: TYPE_NORMAL
- en: Available corpus size is small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output is too subjective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for humans of a specific domain to generate some specialized rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult for machines to generate specialized rules by just observing small
    amounts of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System output should be highly accurate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding factors are very much critical if you want to develop NLP
    application using the RB system. How do the preceding factors help you to decide
    whether you should choose the RB approach or not?
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you have a large amount of data or a small amount of data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a small amount of data, then ask the next question and if you have
    a large amount of data, then you have many other options
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the NLP application that you want to develop, is its output subjective
    or generalized?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a small amount of data and the output of the application which you
    want to develop is too subjective and you know, with a small amount of data, the
    machine cannot generalize the patterns, then choose the RB system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The NLP application that you want to develop should have very high accuracy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application that you want to develop should have high accuracy, almost
    the same as a human by using a small dataset, then choose the RB system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, you should also keep in mind that human experts create rules for the system.
    According to that system, generate the output, so the RB system is highly accurate
    but does not cover all scenarios
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding questions define why and in what kind of situations we can use
    the RB system. If I needed to summarize the preceding questions, I would describe
    it like this: If you have small amount of data and you know you need a highly
    accurate system where it is easy for a human expert to identify various scenarios
    for making rules and its output but it is very difficult for machines to identify
    generalized rules by themselves accurately, then the RB system is for you! The
    output of the RB system should mimic the experiences of the human expert. This
    is the thumb rule for choosing the RB system.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see in [Chapter 9](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml), *Deep
    Learning for NLP and NLG Problems*, that there is a better approach when you have
    very large amount of data. For this chapter, the RB approach helps us to generate
    very accurate NLP applications.
  prefs: []
  type: TYPE_NORMAL
- en: Which kind of applications can use the RB approach over the other approaches?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we defined earlier, the RB system is developed with the help of human domain
    experts. Let''s take some examples in this section which can help to prove our
    rule of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: Say, we want to build the machine translation system from English to available
    Indian corpora and they are too small. The translation system should be accurate
    enough in order to develop it. We need human experts who know English as well
    as Gujarati. We don't want to address all the different levels of translation
    at a time, so we need to cover small chunks of the problem first and then on top
    of the developed prototype, we will build other chunks. So, here also, I would
    like to choose the RB system. What do you think?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Say we want to develop a grammar correction system for the English language.
    Suppose we have a small amount of parallel corpora (documents with grammatical
    mistakes and the same documents without grammatical mistakes), and by using the
    available corpus we need to make an accurate grammar correction application which
    identifies, as well as corrects, the grammatical mistakes. So, in this kind of
    application, which approach would you take? Think for a minute and then come up
    with your answers! Here, I would like to go with the RB system as per our rule
    of thumb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you wanted to develop a basic chatbot system, which approach would you take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RB approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ML approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to predict the sentiment of given sentences, which approach would
    you take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RB approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ML approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: None of them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of resources do you need if you want to develop a rule-based system?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have understood why we are using the RB system and for which kinds of
    application we use it. The third important aspect is what do we need if we want
    to develop the RB system for any NLP or AI applications?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main resources that we need to consider at this point. Refer
    to *Figure 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af4d10b2-7aee-473c-8aff-783a8f11ab28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Resources for implementing RB system'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the details of each resource that helps us to define RB system
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Domain expert (human expert/knowledge expert): For developing applications
    using the RB system, first and foremost, we need a domain expert, a person who
    knows almost everything about the domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose you want to build a machine translation system, then your domain expert
    could be a person who has deep knowledge of linguistics for the source and target
    languages. He can come up with rules by using his expertise and experience.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'System architect (system engineer) of RB system: For defining the architecture
    of the RB system, you need a team or person who has the following expertise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of the domain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep knowledge or high experience in designing system architectures
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture is the most important part of the RB system because your architecture
    is one of the components which decide how efficient your whole system will be.
    Good architecture design for the RB system will provide good user experience,
    accurate and efficient output, and apart from that, it will make life easy for
    coders and other technical teams such as support or testing teams who will be
    able to work on the system easily. The system architecture is the responsibility
    of the system engineer or system architect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coders (developers or knowledge engineers) for implementing rules: Once rules
    are developed by domain experts and the system architecture has been designed
    properly, then coders or developers come into the picture. Coders are our real
    ninjas! They implement the rules by using programming languages and help to complete
    the application. Their coding skills are a much needed part of the RB system.
    Programming can be done using any of the programming or scripting languages such
    as C, C++, Java, Python, Perl, shell scripts, and so on. You can use any of them
    as per the architecture, but not all of them in a single system without a streamlined
    architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at more technical stuff regarding the architecture part a little
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the RB system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will explain the architecture of the RB system by segregating it into three
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: General architecture of RB system as an expert system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical architecture of the RB system for NLP applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom architecture - RB system for NLP applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache **UIMA** (**Unstructured Information Management Architecture**) the RB
    system for NLP applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General architecture of the rule-based system as an expert system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we described our rule-based system as an expert system, then the architecture
    of this kind of rule-based system would be the same as in *Figure 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdb9c8a5-c956-4910-b2fe-21e5bfe8a59c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Architecture of the RB system, considering it as an expert system'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each of the components of the architecture in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain expert**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in the previous section, domain experts are the ones who have expertise
    for a specific domain and they can help us to generate the rules to solve our
    problems
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developers or knowledge engineer:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers use the rules which are created by the domain expert and convert
    them into a machine-understandable format using their coding skills
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers encode the rules created by experts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly, this encoding is in the form of pseudo codes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge base:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The knowledge base is where all the rules can be put by experts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain expert can add, update, or delete the rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database or working storage:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All meta information-related rules can be put in the working storage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we can store rules as well as special scenarios, some lists if available,
    examples, and so on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also save data on which we want to apply rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inference engine:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inference engine is the core part of the system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we put in actual codes for our rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules will be triggered when predefined rules and conditions meet with a user
    query or on a dataset which we have given to the system as input
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User inference:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, our end users also provide some conditions to narrow down their results,
    so all these user inference will also be considered when our system generates
    the output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface helps our user to submit their input and in return they will
    get the output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This provides an interactive environment for our end users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System architect:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system architect takes care of the whole architecture of the system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system architect also decides what is the most efficient architecture for
    the RB system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen the traditional architecture of the RB system. Now it is time to
    see what will be the real-life practical architecture of the RB system for NLP
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Practical architecture of the rule-based system for NLP applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have already described the general architecture, now we will see the practical
    architecture of the RB system for NLP applications. Refer to *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21152cfe-294d-4141-be51-0056e8931963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Real life architecture of RB system for NLP application'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of the components of the architecture in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the parts, such as domain experts, user interfaces, and system engineer,
    we have seen in the previous section. So, here, we are focusing on new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge-based editor:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain experts may not know how to code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So we are providing them a knowledge-based editor where they can write or create
    the rules by using human language
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we are developing a grammar correction system for the English language
    and we have a linguist who knows how to create rules but doesn't know how to code
    them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, they can add, update, or delete rules by using the knowledge-based
    editor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the created rules are specified in the form of normal human language
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule translator:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we know, all rules are in the form of the human language, so we need to translate
    or convert them into machine-understandable form
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the rule translator is the section where pseudo logic for the rules has
    been defined with examples
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider our grammar correction system example. Here our expert defines
    a rule if there is a singular subject and plural verb in the sentence, and then
    changes the verb to the singular verb format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rule translator, the defined rule has been converted as if there is a
    sentence **S** which has a singular subject with the POS tag **PRP$**, **NP**
    with POS tag of verbs **VBP,** then change the verb to the **VBZ** format. Some
    examples have also been specified to understand the rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule object classes:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule object class act, as the container for supporting libraries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains various prerequisite libraries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It also sometimes contains an optional object class for libraries to optimize
    the entire system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the grammar correction system, we can put tools such as parsers, POS taggers,
    **named entity recognition** (**NER**), and so on in the container to be used
    by the rule engine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database or knowledge base:** A database has metadata for rules, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which supporting libraries have been used from the rule object classes?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the category of the rule?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is priority of the rule?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule engine:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the core part, which is the brain of the RB system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the rule translator, rule object classes, and knowledge base we need
    to develop the core code which actually runs on the user query or on the input
    dataset and generates the output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can code by using any programming language which is the best fit for your
    application and its architectures
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For our grammar correction system, we will code the rule in this stage and the
    final code will be put into the rule engine repository
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all the components that are useful if you are developing an RB system
    for NLP. Now you must have questions. Can we change the architecture of the system
    as per our needs? Is it fine? To get answers to these questions, you need to follow
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Custom architecture - the RB system for NLP applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the needs of different NLP applications, you can change the architecture
    or components. Customization is possible in this approach. There are some points
    that need to be taken care of if you are designing a customized RB system architecture.
    Ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Did you analyze and study the problem and the already existing architectures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before doing customization, you need to do analysis of your application. If
    any existing system is there, then study its architecture and take the bad and
    good out of it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take enough time for analysis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you really need custom architecture?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If after the study, you feel that your application architecture needs to be
    customized, then write down the reasons why you you really need it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State the reasons that you have listed down and can help your system to make
    it better by asking a series of questions. If yes, then you are on the right track
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it help to streamline the development process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the new architecture actually help your development process better? If
    it does, then you can consider that architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, defining a streamline process for developing the RB system
    is challenging but if your new customized architecture can help you, then it is
    really a good thing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this streamline process actually stabilize your RB system?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it maintainable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customized architecture can help you to maintain the system easily as well
    as efficiently
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can add this feature to your customized architecture, then thumbs up!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it modular?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it will provide modularity in the RB system then it will be useful because
    then you can add, remove, or update certain modules easily
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it scalable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of the new architecture, you can scale up the system. You should
    also consider this
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it easy to migrate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is with the defined architecture, it should be easy for the team to migrate
    the system from one platform to another
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to migrate a module from one system to another, it should be easy
    for the technical as well the infrastructure team
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it secure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System security is a major concern. New architecture should definitely have
    this feature of security and user privacy if needed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it easy to deploy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to deploy some changes in the future, then deployment should be
    easy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to sell your end product, then the deployment process should be
    easy enough, which will reduce your efforts and time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it time saving in terms of development time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation as well as the development of the RB system by using the architecture
    should be time saving
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture itself should not take too much time to implement
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it easy for our users to use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture can be complex but for end users it must be user-friendly and
    easy to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can take all of the preceding points or most of them, then try to implement
    a small set of problems using the architecture that you think best for the system,
    then, at the end, ask all the previous questions again and evaluate the output.
  prefs: []
  type: TYPE_NORMAL
- en: If you still get positive answers, then you are good to go! Here, the design
    is neither right nor wrong; it's all about the best fit for your NLP application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Question-Answering** (**Q/A**) system can use the architecture which is
    shown in the *Figure 7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7441eed7-ab5b-4689-a454-cf5953e265a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Architecture for Question-Answering RB system'
  prefs: []
  type: TYPE_NORMAL
- en: You can see a very different kind of architecture. The approach of the Q/A system
    is an ontology based RB system. Question processing and document processing is
    the main rule engine for us. Here, we are not thinking of a high-level question
    answering system. We want to develop a Q/A system for small children who can ask
    questions about stories and the system will send back the answers as per the rules
    and available story data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see each of the components in details:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user submits the question, the parser parses the question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse the question matching the parsing result with the knowledge base, ontology,
    and keywords thesaurus using the interpreter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we apply the reasoning and facts as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We derive some facts from the questions and categorized user questions using
    query classification and reformulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After, the already-generated facts and categorized queries are sent to the document
    processing part where the facts are given to the search engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer extraction is the core RB engine for the Q/A system because it uses facts
    and applies reasoning techniques such as forward chaining or backward chaining
    to extract all possible answers. Now you will want to know about backward chaining
    and forward chaining. So, here, I'm giving you just a brief overview. In forward
    chaining, we start with available data and use inference rules to extract more
    facts from data until a goal is achieved. This technique is used in expert system
    to understand what can happen next. And in backward chaining, we start with a
    list of goals and work backwards to find out which conditions could have happened
    in the past for the current result. These techniques help us to understand why
    this happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all possible answers have been generated, then it will be sent back to
    the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have one question in my mind that I would like to ask you.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of database do you want to select if you develop a Q/A system? Think
    before you go ahead!
  prefs: []
  type: TYPE_NORMAL
- en: 'I would like to choose the NoSQL database over the SQL DBs, and there are a
    couple of reasons behind it. The system should be available for the user 24\7\.
    Here, we care about our user. The user can access the system anytime, and availability
    is a critical part. So, I would like to choose the NoSQL database.If, in the future,
    we want to perform some analytics on the users'' questions and answers, then we
    need to save the users'' questions and the system''s answers in the database .
    Read further to understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose your data warehouse or NoSQL DB. If you are new to NoSQL, then
    you can refer to NoSQL using this link: [https://en.wikipedia.org/wiki/NoSQL,](https://en.wikipedia.org/wiki/NoSQL)
    and if you are new to the word data warehouse, then you can refer to this link:
    [https://en.wikipedia.org/wiki/Data_warehouse.](https://en.wikipedia.org/wiki/Data_warehouse)
    This will help us categorize our users, and we can make some creative changes
    that really matter to the user. We can also provide customized feed or suggestions
    to each of the users.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you are developing a grammar correction system, what kind of system
    architecture do you design? Try to design it on paper! Let your thoughts come
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Apache UIMA - the RB system for NLP applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at one of the famous frameworks for the RB system
    for NLP applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache UIMA is basically developed by IBM to process unstructured data. You
    can explore more details by clicking on this link: [https://uima.apache.org/index.html](https://uima.apache.org/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I want to highlight some points from this framework, which will help you
    to make your own NLP application using the RB approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the features of UIMA:'
  prefs: []
  type: TYPE_NORMAL
- en: UIMA will provide us with the infrastructure, components, and framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UMIA has an inbuilt RB engine and GATE library for performing preprocessing
    of text data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following tools are available as part of the components. I have listed
    down a few of them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language identification tool
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sentence segmentation tool
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NER tool
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can code in Java, Ruta, and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a flexible, modular, and easy-to-use framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C/C++ annotators also supports Python and Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applications/uses of UIMA include:'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Watson uses UIMA to analyze unstructured data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **clinical Text Analysis and Knowledge Extraction System** (**Apache cTAKES**)
    uses the UIMA-based system for information extraction from medical records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The challenges of using UIMA include:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to code rules in either Java, Ruta, or C++. Although, for optimization,
    many RB systems use C++; getting the best human resources for Ruta is a challenging
    task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are new to UIMA, you need some time to become familiar with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the RB system development life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the development life cycle for the RB system,
    which will help you in the future if you want to develop your own. *Figure 7.8*
    describes the development life cycle of the RB system. This figure is quite self-explanatory,
    so there is no need for an extra description.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we follow the stages of the RB development life cycle, then life will be
    easy for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac7a6883-ee3f-41db-9ee5-29a1d3f222de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: RB system development life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I have divided the applications into two sections; one is the
    NLP application and the other one is the generalized AI application.
  prefs: []
  type: TYPE_NORMAL
- en: NLP applications using the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we mention some of the NLP applications that use the RB system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sentence boundary detection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sentence boundary detection is easy for general English writing but it will
    be complicated when you are dealing with research papers or other scientific documents
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So, handcrafted post-processing rules will help us to identify the sentence
    boundary accurately
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach has been used by Grammarly Inc. for the grammar correction system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Machine translation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we think of a machine translation system, in our mind, we think of the
    **Google Neural Machine Translation** (**GNMT**) system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For many Indian languages, Google used to use a complex rule-based system with
    a statistical prediction system, so they have an hybrid system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2016, Google launched the neural network based MT system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many research projects still use the RB system for MT and the majority of them
    try tapping out the languages which are untapped
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template based chatbots:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, chatbots are the new trend and craze in the market
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic version of them is a template-based approach where we have a defined
    set of questions or keywords and we have mapped the answers to each of the keywords
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The good part of this system is matching the keywords. So if you are using any
    other language but if your chat messages contain keywords which we have defined,
    then the system is able to send you a proper message as a response
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The bad part is, if you make any spelling mistakes then the system will not
    be able to respond in a proper manner
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will develop this application from scratch. I will explain the coding part
    in the next section, so keep reading and start your computer!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grammar correction system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A grammar correction system is also implemented by using rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this application, we can define some of the simple rules to very complicated
    rules as well
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will see some of the basic grammar correction rules
    which we are going to implement using Python
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Question answering systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A question answering system also uses the RB system, but here, there is one
    different thing going on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Q/A system uses semantics to get the answer of the submitted question
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For putting semantics into the picture, we are using the ontology-based RB approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalized AI applications using the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have seen the NLP applications which use the RB approach. Now, move into
    the generalized AI applications, which use the RB approach along with other techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Self-driving cars or driver less cars:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the start of the chapter, I gave the example of the self-driving car to highlight
    the purpose of having the RB system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The self-driving car also uses a hybrid approach. Many of the big companies,
    from Google to Tesla, are trying to build self-driving cars, and their experiments
    are in order to develop the most trustworthy self-driving cars
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This application has been developed by using complex RB systems during its initial
    days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the experiment turned into the direction of ML techniques
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, companies are implementing deep learning techniques to make the system
    better
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robotics applications:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has been a long-term goal of the AI community to develop robots which complement
    human skills
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a goal where we want to develop robots which help humans to do their
    work, tasks which are basically time consuming
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose there is a robot that helps you with household work. This kind of task
    can be performed by the robot with the help of defined rules for all possible
    situations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expert system of NASA:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NASA made the expert system by using the general purpose programming language,
    **CLIPS** (**C Language Integrated Production System**)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, I think that's enough of theories. Now we should try to develop some of
    the RB applications from scratch. Get ready for coding. We will begin our coding
    journey in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing NLP applications using the RB system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to develop NLP applications using the RB system.
    We are developing applications from the beginning. So, first you need the following
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the following command to install all the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of dependencies can be found by clicking on this link: [https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt](https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking process for making rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are talking a lot about rules, but how can these rules actually can be derived?
    What is the thinking process of a linguist when they are deriving rules for an
    NLP application? Then, let's begin with this thinking process.
  prefs: []
  type: TYPE_NORMAL
- en: You need to think like a linguist for a while. Remember all the concepts that
    you have learned so far in this book and be a linguist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you are developing rules for a grammar correction system, especially
    for the English language. So, I''m describing the thought process of a linguist
    and this thought process helps you when you are developing rules:'
  prefs: []
  type: TYPE_NORMAL
- en: What should I need to know?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should know about grammatical rules of the language for which you are creating
    rules, here that language is English
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You should know the structure, word order, and other language related concepts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding two points are prerequisites
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From where should I start?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know all the language-related things, then you need to observe and study
    incorrect sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when you study incorrect sentences, you need to know what mistakes there
    are in the sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After that you need to think about the categories of the mistakes, whether the
    mistakes are syntax related, or whether they are because of semantic ambiguity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After all this, you can map your language-related knowledge to the mistakes
    in the sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How can rules be derived?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you find the mistakes in the sentence, then at that moment focus on your
    thinking process. What does your brain think when you're capturing the mistakes?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about how your brain reacts to each of the mistakes that you have identified
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can capture the mistake because you know the grammatical facts of the language
    or other language related technical stuff (sentence syntax structures, semantics
    knowledge, and so on). Your brain actually helps you
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your brain knows the right way to interpret the given text using the given language
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That is the reason you are able to catch the mistakes. At the same time, you
    have some solid reason; based on that, you have identified the mistakes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have identified the mistakes, as per the different categories of the
    mistakes, you can correct the mistakes by changing some parts of the sentences
    using certain logical rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change the word order, or you can change the subject verb agreement,
    or you can change some phrases or all of them together
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bingo! At this point, you will get your rule. You know what the mistakes are
    and you also know what are these steps are for converting incorrect sentences
    to correct sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your rule logic is nothing but the steps of converting incorrect sentences into
    correct sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What elements do I need to take care of?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you need to think about a very simple way of correcting the mistakes
    or incorrect sentences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to make pattern-based rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If pattern-based rule are not possible to derive then check if you can use parsing
    and/or morphological analyzer results and then check other tools and libraries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By the way, there is one catch here. When you defining rules, you also need
    to think about how feasible the rule logic is for implementation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the tools available or not? If the tools are available then you can code
    your rules or the developer can code the rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the tools aren't available then you need to discard your rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Research is involved when you define a rule and then check whether there are
    any tools available which coders can use for coding up the defined rule logic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The selected tools should be capable of coding the exceptional scenarios for
    rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining rules and researching on tools can be basic tasks for linguists if
    you have some linguists in your team. If not, then you as coders need to search
    tools which you can use for coding the rule logic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Without any delay, we will start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Start with simple rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have written a script which scrapes the Wikipedia page entitled Programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click here to open that page: [https://en.wikipedia.org/wiki/Programming_language](https://en.wikipedia.org/wiki/Programming_language)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the name of the programming languages from the text of the given
    page is our goal. Take an example: The page has C, C++, Java, JavaScript, and
    so on, programming languages. I want to extract them. These words can be a part
    of sentences or have occurred standalone in the text data content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, see how we can solve this problem by defining a simple rule. The GitHub
    link for the script is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data file link on GitHub is: [https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt](https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here our task can be divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Scraping the text data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the rule for our goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding our rule and generating the prototype and result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scraping the text data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this stage, we are going to scrape the text from the programming language
    wiki page and export the content into a text file. You can see the code snippet
    in *Figure 7.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7862c8ec-1953-4c0e-91ea-8c1fd703632e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Code snippets for scraping text data'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the scraping data is shown in *Figure 7.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0c90cf2-7310-4035-872c-47f7f48fe65e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Output of scraping script'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the rule for our goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, if you look at our scraped data, you can find the sentences. Now after
    analyzing the text, you need to define a rule for extracting only programming
    language names such as Java, JavaScript, MATLAB, and so on. Then, think for a
    while about what kind of simple rule or logic can help you to achieve your goal.
    Think hard and take your time! Try to focus on your thinking process and try to
    find out the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: If I wanted to define a rule, then I would generalize my problem in the context
    of the data given to me. During my analysis, I have noticed that the majority
    of the programming language keywords come with the word language. I have noticed
    that when language as a word appears in the sentences, then there is a high chance
    that the actual programming language name also appears in that sentence. For example,
    the C programming language is specified by an ISO standard. In the given example,
    the C programming language appears and the word language also appears in the sentence.
    So, I will perform the following process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I need to extract the sentences which contain language as a word. Now
    as a second step, I will start to process the extracted sentences and check any
    capitalized words or camel case words there are in the sentence. Then, if I find
    any capitalized words or camel case words, I need to extract them and I will put
    them into the list because most of the programming languages appear as capitalized
    words or in camel case word format. See the examples: C, C++, Java, JavaScript,
    and so on. There will be cases where a single sentence contains the name of more
    than one programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding process is our rule and the logical form of the rule is given
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract sentences with language as a word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then try to find out words in the sentence which are in camel case or capitalized
    form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put all these words in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding our rule and generating a prototype and result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example gives you the practical essence of the rule making process. This
    is our first step so we are not focusing on accuracy very much. I know, this is
    not the only way of solving this problem and this is not the most efficient way.
    There are also other efficient ways to implement the same problem, but I'm using
    this one because I felt this solution is the simplest one and easiest to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This example can help you to understand how rules can be coded and, after getting
    the result of the first prototype, what next steps you can take to improve your
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the code snippet in *Figure 7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7e81518-af58-4790-8404-d4ab270cdd14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Code for implementation of rule logic for extracting programming
    language'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now as you have seen, our basic rule extracted programming languages but it
    has also extracted junk data. Now think how you can restrict the rule or how you
    can put in some constraints so it will give us an accurate output. That will be
    your assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please improvise the preceding output by putting in some constraints (Hint:
    You can apply some preprocessing and regex can also help you.)'
  prefs: []
  type: TYPE_NORMAL
- en: Python for pattern-matching rules for a proofreading application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, suppose you want to make a proofreading tool. So, here I will provide you
    with one very simple mistake that you can find easily in any business mail or
    in any letter. Then we will try to correct the errors with high accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The mistake is when people specify a meeting timing in their mail, they may
    have specified the time as 2pm, or as 2PM, or as 2P.M., or other variations, but
    the correct format is 2 p.m. or 9 a.m.
  prefs: []
  type: TYPE_NORMAL
- en: This mistake can be fixed by the pattern-based rule. The following is the rule
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the numeric digit of length two starts from 1 to 12\. After this numeric
    digit, if `am` and `pm` occurred without a space or without a period, then add
    the space and the proper period symbol.
  prefs: []
  type: TYPE_NORMAL
- en: I will implement it by using a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Target pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the code on the GitHub URL at: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet is given in *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f42586d-dc3e-4282-a65c-ebba44d8f8e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Code snippet for pattern-based rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code snippet is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90ee2ddc-9ba7-454a-8597-7a7f5b171005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Output of pattern-based rule'
  prefs: []
  type: TYPE_NORMAL
- en: The given example is a basic one, but it helps you to think about how proofreading
    can be done. Many simple sets of rules can be applied on the data and, according
    to the pattern, you will get the corrected result.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a similar kind of rule which helps in correcting the timing pattern 11:30am
    or 5:45pm to 11:30 a.m. or 5:45 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar correction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make a simple rule about a subject verb agreement rule for simple present
    tense.
  prefs: []
  type: TYPE_NORMAL
- en: We know that in simple present tense the third-person singular subjects always
    takes a singular verb with either s/es as the suffix of the verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of incorrect sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: He drink tomato soup in the morning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: She know cooking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We plays game online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We cannot perform a pattern-based correction for these kinds of incorrect sentences.
    Here, to make a rule, we will parse each sentence and try to check by using the
    parser result. Can we make any rules? I have parsed sentences to generate the
    parse result so you can see the parse tree in *Figure 7.14*. This result has been
    generated by using the Stanford parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/864c3aeb-7b89-473a-bad5-cf19fa6b45e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Parsing result for example sentences'
  prefs: []
  type: TYPE_NORMAL
- en: We need to first extract the **NP**, which either takes the pronouns **PRP**/**NNP**
    or **NN**. This rule can be restricted to **PRP** only. We can extract the **PRP**
    tags from the sentence. After that we need to extract the **VP**. By using the
    type of pronoun and **VP**, we can suggest the change to the user. I guess you
    guys remember **NP**, **PRP**, **NNP**, and so on. As we have already shown, these
    are all kinds of POS tags, in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml),
    *Feature Engineering and NLP Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the **NP** with the **PRP** tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the **VP**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As per the **PRP**, perform the correction in ****VP****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s do the coding for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have installed the Stanford-`corenlp` and `pycornlp` libraries. You have
    already learned the steps for installing the Stanford parser in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml),
    *Feature Engineering and NLP Algorithm.*You guys are going to code this. So, it''s
    a complete code challenge. I have a code in which I have extracted the pattern
    for you for **PRP** and **VBZ**/**VBP**. Your task is to check whether the combination
    of **PRP** and **VBP**/**VBZ** is right or wrong. If it is wrong, then raise an
    alert. You can find the code at: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the code snippet in *Figure 7.15* and *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf229a86-fb2e-48e6-9fb4-efd8833a65c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Stated Stanford corenlp server'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have given you the code but you need to complete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a88b6724-67f7-4890-a3fa-59d1c7ac34b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Code which I have given to you but you need to complete'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the output of my incomplete code in *Figure 7.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1083e9d0-41b5-4bb3-be1a-424cfc7d9d37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Output of my incomplete code'
  prefs: []
  type: TYPE_NORMAL
- en: Template-based chatbot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will see how we can build a core engine for a chatbot application which
    can help a loan applicant to apply for the same. We are generating output in JSON
    format, so any front-end developer can integrate this output on a website.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I'm using the flask web framework and making web services for each question
    that our chatbot asks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install MongoDB if you want to save the user data. The installation
    steps of MongoDB are in this link: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have defined functions in the `conversationengine.py` file. The path of this
    file on GitHub is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the flask web engine code in the `flaskengin.py` file. The GitHub
    link is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole folder and package file path is at: [https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot](https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot)'
  prefs: []
  type: TYPE_NORMAL
- en: Flow of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, I have written functions in `conversationengine.py` which generate a JSON
    response according to the questions you have asked and this JSON response can
    be used by the frontend developer team to display messages on the chatbot UI.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I have written a web service using flask so you can see the JSON response
    on the web URL specified in JSON itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conversationengine.py` is the core rule engine with handcrafted rules
    and codes. See the code snippet in *Figure 7.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0fd264e-9b32-44b0-bde0-cfd089c3c676.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Code snippet of conversationengine.py'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used a keywords list and, responses list to implement chatbot.
    I have also made customized JSON schema to export the conversation and, if you
    are from a web development background then you can write JavaScript which will
    help you to display this JSON on the front end with GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the web services part in *Figure 7.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0ad22d9-1614-4e27-a5e0-8c4bfc45dde6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Flask web service URLs defined in flaskengin.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to run the scripts and see the output follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First run `flaskengin.py`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the URL: `http://0.0.0.0:5002/`, where you can see `Hello from chatbot
    Flask!`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the chatbot JSON response by using this URL: `http://0.0.0.0:5002/welcomemsg_chat`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the JSON response in *Figure 7.20*:![](img/266f8f6f-8f8d-4be6-af88-f0d1492a702e.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.20: JSON response of chatbot'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are providing suggestions to our human user which will help them analyze
    what the expected input from them is. So, here, you can see the JSON attribute
    `suggestion_message: ["Hi"]`. So, the user will see the button with the `Hi` label.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to redirect to the next page or next question, then use `next_form_action`
    URL and put the user argument after `msg = USER ARGUMENT`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, I am at the `http://0.0.0.0:5002/welcomemsg_chat` page. Now, you
    can read the `message_bot`. It says you need to say `Hi to bot`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can give your `Hi` response like this: `http://0.0.0.0:5002/hi_chat?msg=Hi`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you are on this URL: `http://0.0.0.0:5002/hi_chat?msg=Hi` you can see
    the bot will ask for your name now you need to enter your name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enter your name and be redirected to the next question, you need to again
    check what is the value of the URL for the `next_form_action` attribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here the value is `/asking_borowers_email_id?msg=`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to put your name after the `=` sign so the URL becomes `/asking_borowers_email_id?msg=Jalaj
    Thanaki`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you use `http://0.0.0.0:5002/asking_borowers_full_name?msg=Jalaj%20Thanaki`,
    you can see next question from the bot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First you need to run the script: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py)
    and then you can check the following URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/welcomemsg_chat`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/hi_chat?msg=Hi`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/asking_borowers_full_name msg=Jalaj%20Thanaki`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/asking_borowers_email_id?msg=jalaj@gmail.com`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/mobilenumber_asking?msg=9425897412`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/loan_chat?msg=100000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://0.0.0.0:5002/end_chat?msg=Bye`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to insert user data in the MongoDB database, then this is possible
    and is included in the code but commented.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of template-based chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Easy to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time and cost efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases are understood prior to development so user experience will also be
    good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a pattern-matching approach, so if users use English and other languages
    in their conversation then users also get answers because chatbot identifies keywords
    which he provides in English, and if English keywords match with the chatbot vocabulary,
    then chatbot can give you answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of template-based chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It cannot work for unseen use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User should process a rigid flow of conversation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spelling mistakes by users create a problem for chatbot. In this case, we will
    use deep learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Develop a template-based chatbot application for a hotel room booking customer
    support service. Develop some questions and answers and develop the application.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the rule-based approach with other approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule-based approach is a very reliable engine which provides your application
    with high accuracy. When you compare the RB approach with ML approaches or deep
    learning approaches, you will find the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: For the RB approach, you need a domain expert, while for the ML approach, or
    for the deep learning approach, you don't need a domain expert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RB system doesn't need a large amount of data, whereas ML and deep learning
    need a very large amount of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the RB system, you need to find patterns manually, whereas ML and deep learning
    techniques find patterns on your behalf as per the data and input features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RB system is often a good approach for developing the first cut of your
    end product, which is still popular in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are very good advantages to using RB system. The advantages are mentioned
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Availability: Availability of the system for the user is not an issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cost efficient: This system is cost efficient and accurate in terms of its
    end result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Speed: You can optimize the system as you know all the parts of the system.
    So to provide output in a few seconds is not a big issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accuracy and less error rate: Although coverage for different scenarios is
    less, whatever scenarios are covered by the RB system will provide high accuracy.
    Because of these predefined rules, the error rate is also less'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reducing risk: We are reducing the amount of risk in terms of system accuracy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Steady response: Output which has been generated by the system is dependent
    on rules so the output responses are stable, which means it cannot be vague'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same cognitive process as a human: This system provides you with the same
    result as a human, as it has been handcrafted by humans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modularity: The modularity and good architecture of the RB system can help
    the technical team to maintain it easily. This decreases human efforts and time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uniformity: The RB system is much uniformed in its implementation and its output.
    This makes life easy for the end user because the output of the system can be
    easily understood by humans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easy to implement: This approach mimics the human thought process, so the implementation
    of rules is comparatively easy for developers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The disadvantages of the RB system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lot of manual work: The RB system demands deep knowledge of the domain as well
    as a lot of manual work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time consuming: Generating rules for a complex system is quite challenging
    and time consuming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Less learning capacity: Here, the system will generate the result as per the
    rules so the learning capacity of the system by itself is much less'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complex domains: If an application that you want to build is too complex, building
    the RB system can take lot of time and analysis. Complex pattern identification
    is a challenging task in the RB approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges for the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some of the challenges in the RB approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not easy to mimic the behavior of a human.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting or designing architecture is the critical part of the RB system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to develop the RB system, you need to be an expert of the specific
    domain which generates rules for us. For NLP we need linguists who know how to
    analyze language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural language is itself a challenging domain because it has so many exception
    cases and covering those exceptions using rules is also a challenging task, especially
    when you have a large amount of rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arabic, Gujarati, Hindi, and Urdu are difficult to implement in the RB system
    because finding a domain expert for these languages is a difficult task. There
    are also less tools available for the described languages to implement the rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time consumption of human effort is too high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding word-sense disambiguation basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Word-sense disambiguation** (**WSD**) is a well-known problem in NLP. First
    of all, let''s understand what WSD is. WSD is used in identifying what the sense
    of a word means in a sentence when the word has multiple meanings. When a single
    word has multiple meaning, then for the machine it is difficult to identify the
    correct meaning and to solve this challenging issue we can use the rule-based
    system or machine learning techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, our focus area is the RB system. So, we will see the flow
    of how WSD is solved. In order to solve this complex problem using the RB system,
    you can take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When you are trying to solve WSD for any language you need to have a lot of
    data where you can find the various instances of words whose meaning can be different
    from sentence to sentence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have this kind of dataset available, then human experts come into the
    picture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Human experts are used to tag the meaning of a word or words and usually the
    tags have some predefined IDs. Now, let''s take an example: I have the sentences:
    I went to river bank, and I went to bank to deposit my money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding sentences, the word bank has multiple meanings and the meaning
    changes as per the overall sentence. So, the human expert is used to tag these
    kinds of words. Here, our word is bank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the human expert tags the word bank in the river bank sense by using a predefined
    ID. Assume for now that the ID is 100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second sentence, the word bank is tagged as a financial institution by
    using the predefined ID. Assume for now that ID is 101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this tag has been given then the next stage has been started, which is
    either to choose rule-based engine or supervised machine learning techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we decide to go with the rule-based system then human experts need to come
    up with a certain pattern or rules which help us to disambiguate the sense of
    the words. Sometimes, for some words, the expert can find the rule by using a
    parsing result or by using POS tags, but in most case they can't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So nowadays, once tagging has been done, the tagged data is used as input to
    develop a supervised machine learning model which helps humans to identify the
    senses of the words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes only the rule-based system cannot work in the same way only the machine
    learning approach alone sometimes can't help you. Here is the same kind of case
    according to my experience. I think the hybrid approach will give you a better
    result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After tagging the data, we should build the RB system which handles known situations
    very well and we also have a situation where we can't define rules. To solve that
    situation, we need to build a machine learning model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the vectorization concept and deep learning model to solve
    WSD problems. Your findings on WSD by using deep learning can be a research topic
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing recent trends for the rule-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a discussion about how the current market is using the RB system.
    So many people are asking many questions on different forums and they want to
    know about the future of the RB system, so I want to discuss with you one important
    question which will help you to learn the future trends of the NLP market and
    RB system. I have some of the questions that we will look at.
  prefs: []
  type: TYPE_NORMAL
- en: Are RB systems outdated in the NLP domain? I would like to answer this with
    NO. The RB system has been used majorly in all NLP applications, grammar correction,
    speech recognition, machine translation, and so on! This approach is the first
    step when you start making any new NLP application. If you want to experiment
    on your idea, then prototypes can be easily developed with the help of the RB
    approach. For prototyping, you need domain knowledge and basic coding skills.
    You don't need to know high-level mathematics or ML techniques. For basic prototyping,
    you should go with the RB system.
  prefs: []
  type: TYPE_NORMAL
- en: Can deep learning and ML-based approaches replace the RB based system? This
    question is quite an open-ended question. I would like to present some facts at
    this point which will help you to derive your question. Nowadays, we are flooded
    with data and we have cheap computation power available to us. The AI industry
    and AI-based projects are creating a lot of buzz. The preceding two points help
    deep learning and ML approaches to derive accurate results for NLP as well as
    other AI applications. These approaches need less human effort compared to the
    RB system. This is the reason why so many people think that the RB system will
    not be replaced by the deep learning and ML-based systems. I would argue that
    the RB system is not going to be replaced totally, but it will complement these
    approaches. Now you ask, how? So, the answer is, I think I would like to go with
    hybrid approaches which are much more beneficial for us. We can find patterns
    or predictions with the help of the ML system and then give those predictions
    to the RB system, and the RB system can validate the prediction and choose the
    best one for the users. This will actually help us to overcome one major challenge
    of the RB system, which is the reduction of human effort and time.
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding questions, there is not any right or wrong answers. It is
    all about how you can see the questions and NLP domain. I just want to leave a
    thought for you. Think by yourself and try to come up with your own answer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen all the details related to the rule-based system
    and how the rule-based approach helps us to develop rapid prototypes for complex
    problems with high accuracy. We have seen the architecture of the rule-based system.
    We have learned about the advantages, disadvantages, and challenges for the rule-based
    system. We have seen how this system is helpful to us for developing NLP applications
    such as grammar correction systems, chatbots, and so on. We have also discussed
    the recent trends for the rule-based system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the other main approaches called machine
    learning, to solve NLP applications. The upcoming chapter will give you all the
    details about which machine learning algorithms you need to use for developing
    NLP applications. We will see supervised ML, semi-supervised ML, and unsupervised
    ML techniques. We will also develop some of the applications from scratch. So
    keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: This self-driving car exam
  prefs: []
  type: TYPE_NORMAL
