<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a Feedforward Neural Network</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter we will cover the following recipes:</p>
<ul>
<li>Feed-forward propagation from scratch in Python</li>
<li>Building back-propagation from scratch in Python</li>
<li>Building a neural network in Keras</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>A neural network is a supervised learning algorithm that is loosely inspired by the way the brain functions. Similar to the way neurons are connected to each other in the brain, a neural network takes input, passes it through a function, certain subsequent neurons get excited, and consequently the output is produced.</span></p>
<p>In this chapter, you will learn the following:</p>
<ul>
<li>Architecture of a neural network</li>
<li>Applications of a neural network</li>
<li>Setting up a <span>feedforward </span>neural network</li>
<li>How forward-propagation works</li>
<li>Calculating loss values</li>
<li>How gradient descent works in back-propagation</li>
<li>The concepts of epochs and batch size</li>
<li>Various loss functions</li>
<li>Various activation functions</li>
<li>Building a neural network from scratch</li>
<li>Building a neural network in Keras</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Architecture of a simple neural network</h1>
                </header>
            
            <article>
                
<p>An artificial neural network is loosely inspired by the way the human brain functions. Technically, it is an improvement over linear and logistic regression as neural networks introduce multiple non-linear measures in estimating the output. Additionally, neural networks provide a great flexibility in modifying the network architecture to solve the problems across multiple domains leveraging structured and unstructured data.</p>
<p>The more complex the function, the greater<span> the chance that the network has to tune to the data that is given as input,</span><span><span> </span></span>hence the better the accuracy of the predictions.</p>
<p>The typical structure of a feed-forward neural network is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1076 image-border" src="Images/838c8087-2c87-495b-9064-13c3d634e009.png" style="width:27.50em;height:21.50em;" width="949" height="742"/></p>
<p>A layer is a collection of one or more nodes (computation units), where each node in a layer is connected to every other node in the next immediate layer. The input level/layer is constituted of the input variables that are required to predict the output values.</p>
<p>The number of nodes in the output layer depends on whether we are trying to predict a continuous variable or a categorical variable. If the output is a continuous variable, the output has one unit.</p>
<p>If the output is categorical with <em>n</em> possible classes, there will be <em>n</em> nodes in the output layer. The hidden level/layer is used to transform the input layer values into values in a higher-dimensional space, so that we can learn more features from the input. The hidden layer transforms the output as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1074 image-border" src="Images/7ae13d98-43f6-4c6a-83e8-687365e00a27.png" style="width:34.08em;height:18.50em;" width="944" height="513"/></p>
<p>In the preceding diagram, <em>x<sub>1</sub></em>,<em>x</em><sub><em>2</em>, </sub>..., <em>x<sub>n</sub></em> are the independent variables, and <em>x<sub>0</sub></em> is the bias term (similar to the way we have bias in linear/logistic regression).</p>
<p>Note that <em>w<sub>1</sub></em>,<em>w<sub>2</sub></em>, ..., <em>w<sub>n</sub></em> are the weights given to each of the input variables. If <em>a</em> is one of the units in the hidden layer, it will be equal to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/96089758-dfe2-470f-99c0-79f087b84c7b.png" style="width:9.17em;height:4.17em;" width="990" height="450"/></p>
<p class="mce-root"><span>The <em>f</em> function is the activation function that is used to apply non-linearity on top of the sum-product of the input and their corresponding weight values.</span> Additionally, higher non-linearity can be achieved by having more than one hidden layer.</p>
<p>In sum, a neural network is a collection of weights assigned to nodes with layers connecting them. The collection is organized into three main parts: the input layer, the hidden layer, and the output layer. Note that you can have <em>n</em> hidden layers, with the term deep learning implying multiple hidden layers. Hidden layers are necessary when the neural network has to make sense of something really complicated, contextual, or not obvious, such as image recognition. The intermediate layers (layers that are not input or output) are known as hidden, since they are practically not visible (there's more on how to visualize the intermediate layers in <a href="750fdf81-d758-47c9-a3b3-7cae6aae1576.xhtml" target="_blank">Chapter 4</a>, <em>Building a Deep Convolutional Neural Network</em>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Training a neural network</h1>
                </header>
            
            <article>
                
<p>Training a neural network basically means calibrating all of the weights in a neural network by repeating two key steps: forward-propagation and back-propagation.</p>
<p>In forward-propagation, we apply a set of weights to the input data, pass it through the hidden layer, perform the<span> </span>nonlinear<span> </span>activation on the hidden layer output, and then connect the hidden layer to the output layer by multiplying the hidden layer node values with another set of weights. For the first forward-propagation, the values of the weights are initialized randomly.</p>
<p>In back-propagation, we try to decrease the error by measuring the margin of error of output and then adjust weight accordingly. Neural networks repeat both forward- and back-propagation to predict an output until the weights are calibrated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applications of a neural network</h1>
                </header>
            
            <article>
                
<p>Recently, we have seen a huge adoption of neural networks in a variety of applications. In this section, let's try to understand the reason why adoption might have increased considerably. Neural networks can be architected in multiple ways. Here are some of the possible ways:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1084 image-border" src="Images/78c3e0dd-0c85-40a9-ada6-5193ad120167.png" style="width:127.00em;height:42.92em;" width="1524" height="515"/></p>
<p>The box at the bottom is the input, followed by the hidden layer (the middle box), and the box at the top is the output layer. The one-to-one architecture is a typical neural network with a hidden layer between the input and output layer. Examples of different architectures are as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 22.0443%"><strong>Architecture</strong></td>
<td style="width: 77.2167%"><strong>Example</strong></td>
</tr>
<tr>
<td style="width: 22.0443%">One-to-many</td>
<td style="width: 77.2167%">The input is an image and the output is a caption for the image</td>
</tr>
<tr>
<td style="width: 22.0443%">Many-to-one</td>
<td style="width: 77.2167%">The input is a movie review (multiple words) and the output is the sentiment associated with the review</td>
</tr>
<tr>
<td style="width: 22.0443%">Many-to-many</td>
<td style="width: 77.2167%">Machine translation of a sentence in one language to a sentence in another language</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Apart from the preceding points, neural networks are also in a position to understand the content in an image and detect the position where the content is located using an architecture named <strong>Convolutional Neural Network</strong> (<strong>CNN</strong>), which looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1067 image-border" src="Images/2ad769ae-ff98-4ed7-bd58-c9284e1c25f6.png" style="width:138.42em;height:38.75em;" width="1661" height="465"/></p>
<p>Here, we saw examples of recommender systems, image analysis, text analysis, and audio analysis, and we can see that neural networks give us the flexibility to solve a problem using multiple architectures, resulting in increased adoption as the number of applications increases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Feed-forward propagation from scratch in Python</h1>
                </header>
            
            <article>
                
<p><span>In order to build a strong foundation of how feed-forward propagation works, we'll go through a toy example of training a neural network where the input to the neural network is (1, 1) and the corresponding output is 0.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The strategy that we'll adopt is as follows: our neural network will have one hidden layer (with neurons) connecting the input layer to the output layer. Note that we have more neurons in the hidden layer than in the input layer, as we want to enable the input layer to be represented in more dimensions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1068 image-border" src="Images/ede5ca3a-46a3-4e12-a031-089dd2e8c3da.png" style="width:24.42em;height:15.17em;" width="923" height="578"/></p>
<p><strong>Calculating the hidden layer unit values</strong></p>
<p>We now assign weights to all of the connections. Note that these weights are selected randomly (based on Gaussian distribution) since it is the first time we're forward-propagating. In this specific case, let's start with initial weights that are between 0 and 1, but note that the final weights after the training process of a neural network don't need to be between a specific set of values:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1069 image-border" src="Images/12b639fb-0830-4075-b072-57b0d0d97885.png" style="width:25.75em;height:16.17em;" width="923" height="578"/></p>
<p>In the next step, we perform the multiplication of the input with weights to calculate the values of hidden units in the hidden layer. </p>
<p>The hidden layer's unit values are obtained as follows:</p>
<p class="CDPAlignCenter CDPAlign"><em><img class="fm-editor-equation" src="Images/c1c88e58-271f-4993-9e05-96a7f4bec990.png" style="width:12.33em;height:1.17em;" width="2020" height="190"/></em></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/624d72e6-fad9-46b7-a852-de01b0dedb17.png" style="width:13.25em;height:1.17em;" width="2160" height="190"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/3662b621-8504-4f08-ad28-46f825de99cc.png" style="width:12.33em;height:1.08em;" width="2160" height="190"/></p>
<p>The hidden layer's unit values are also shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1070 image-border" src="Images/3b453e27-b9e7-4527-94a3-c32a3022c51f.png" style="width:28.17em;height:17.67em;" width="924" height="578"/></p>
<p>Note that in the preceding output we calculated the hidden values. For simplicity, we excluded the bias terms that need to be added at each unit of a hidden layer.</p>
<p>Now, we will pass the hidden layer values through an activation function so that we attain non-linearity in our output.</p>
<div class="packt_tip">If we do not apply the activation function in the hidden layer, the neural network becomes a giant linear connection from input to output.</div>
<p><strong>Applying the activation function</strong></p>
<p>Activation functions are applied at multiple layers of a network. They are used so that we achieve high non-linearity in input, which can be useful in modeling complex relations between the input and output.</p>
<p>The different activation functions are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/12df72e4-af1b-4ce8-bca4-b125b185f18a.png" style="width:38.67em;height:45.25em;" width="628" height="734"/></p>
<p>For our example, let’s use the sigmoid function for activation. The sigmoid function looks like this, graphically:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1597 image-border" src="Images/41178e09-6508-41af-bf4d-616d4dbf7674.png" style="width:37.92em;height:23.50em;" width="502" height="311"/></p>
<p>By applying sigmoid activation, <em>S(x)</em>, to the three hidden=layer <em>sums</em>, we get the following:</p>
<p class="CDPAlignCenter CDPAlign"><em>final_h<sub>1</sub> = S(1.0) = 0.73</em></p>
<p class="CDPAlignCenter CDPAlign"><em>final_h<sub>2</sub> = S(1.3) = 0.78</em></p>
<p class="CDPAlignCenter CDPAlign"><em>final_h<sub>3</sub> = S(0.8) = 0.69</em></p>
<p><strong>Calculating the output layered values</strong></p>
<p>Now that we have calculated the hidden layer values, we will be calculating the output layer value. In the following diagram, we have the hidden layer values connected to the output through the randomly-initialized weight values. Using the hidden layer values and the weight values, we will calculate the output values for the following network:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1077 image-border" src="Images/bdd85755-2ae5-4148-b584-46b254589d77.png" style="width:25.50em;height:15.92em;" width="924" height="578"/></p>
<p>We perform the sum product of the hidden layer values and weight values to calculate the output value. <span>For simplicity, we excluded the bias terms that need to be added at each unit of the hidden layer:</span></p>
<p class="mce-root CDPAlignCenter CDPAlign"><em>0.73 * 0.3 + 0.79 * 0.5 + 0.69 * 0.9 = 1.235</em></p>
<p>The values are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5689850e-73e4-4ce8-86b5-3081086f9410.png" style="width:26.58em;height:16.58em;" width="924" height="578"/></p>
<div>
<div>
<p>Because we started with a random set of weights, the value of the output neuron is very different from the target, in this case by +1.235 (since the target is 0).</p>
</div>
</div>
<p><strong>Calculating the loss values</strong></p>
<p>Loss values (alternatively called cost functions) are values that we optimize in a neural network. In order to understand how loss values get calculated, let's look at two scenarios:</p>
<ul>
<li>Continuous variable prediction</li>
<li>Categorical variable prediction</li>
</ul>
<p><strong>Calculating loss during continuous variable prediction</strong></p>
<p>Typically, when the variable is a continuous one, the loss value is calculated as the squared error, that is, we try to minimize the mean squared error by varying the weight values associated with the neural network:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/caeef8ef-a6a7-4b83-b3f8-c9961b637f7b.png" style="width:20.58em;height:4.42em;" width="2000" height="430"/></p>
<p>In the preceding equation, <em>y(i)</em> is the actual value of output, <em>h(x)</em> is the transformation that we apply on the input (<em>x</em>) to obtain a predicted value of <em>y,</em> and <em>m</em> is the number of rows in the dataset.</p>
<p><strong>Calculating loss during categorical variable prediction</strong></p>
<p>When the variable to predict is a discrete one (that is, there are only a few categories in the variable), we typically use a categorical cross-entropy loss function. When the variable to predict has two distinct values within it, the loss function is binary cross-entropy, and when the variable to predict has multiple distinct values within it, the loss function is a categorical cross-entropy.</p>
<p>Here is binary cross-entropy:</p>
<p><em>(ylog(p)+(1−y)log(1−p))</em></p>
<p>Here is categorical cross-entropy: </p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/28b794dc-8596-48ba-8f95-23211716611e.png" style="width:9.17em;height:4.33em;" width="1100" height="520"/></p>
<p><em>y</em> is the actual value of output <em>p,</em> is the predicted value of the output  and n is the total number of data points. For now, let's assume that the outcome that we are predicting in our toy example is continuous. In that case, the loss function value is the mean squared error, which is calculated as follows:</p>
<p><em>error = 1.235<sup>2</sup> = 1.52</em></p>
<p>In the next step, we will try to minimize the loss function value using back-propagation (which we'll learn about in the next section), where we update the weight values (which were initialized randomly earlier) to minimize the loss (error).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned about performing the following steps on top of the input data to come up with error values in forward-propagation (the code file is available as <kbd>Neural_network_working_details.ipynb</kbd> in GitHub):</p>
<ol>
<li>Initialize weights randomly</li>
<li>Calculate the hidden layer unit values by multiplying input values with weights</li>
<li>Perform activation on the hidden layer values</li>
<li>Connect the hidden layer values to the output layer</li>
<li>Calculate the squared error loss</li>
</ol>
<p>A function to calculate the squared error loss values across all data points is as follows:</p>
<pre>import numpy as np<br/>def feed_forward(inputs, outputs, weights):<br/>     pre_hidden = np.dot(inputs,weights[0])+ weights[1]<br/>     hidden = 1/(1+np.exp(-pre_hidden))<br/>     out = np.dot(hidden, weights[2]) + weights[3]<br/>     squared_error = (np.square(pred_out - outputs))<br/>     return squared_error</pre>
<p>In the preceding function, we take the input variable values, weights (randomly initialized if this is the first iteration), and the actual output in the provided dataset as the input to the feed-forward function.</p>
<p>We calculate the hidden layer values by performing the matrix multiplication (dot product) of the input and weights. Additionally, we add the bias values in the hidden layer, as follows:</p>
<pre>pre_hidden = np.dot(inputs,weights[0])+ weights[1]</pre>
<p>The preceding scenario is valid when <kbd>weights[0]</kbd> is the weight value and <kbd>weights[1]</kbd> is the bias value, where the weight and bias are connecting the input layer to the hidden layer.</p>
<p>Once we calculate the hidden layer values, we perform activation on top of the hidden layer values, as follows:</p>
<pre>hidden = 1/(1+np.exp(-pre_hidden))</pre>
<p>We now calculate the output at the hidden layer by multiplying the output of the hidden layer with weights that connect the hidden layer to the output, and then adding the bias term at the output, as follows:</p>
<pre>pred_out = np.dot(hidden, weights[2]) + weights[3]</pre>
<p>Once the output is calculated, we calculate the squared error loss at each row, as follows:</p>
<pre>squared_error = (np.square(pred_out - outputs))</pre>
<p>In the preceding code, <kbd>pred_out</kbd> is the predicted output and <kbd>outputs</kbd> is the actual output.</p>
<p>We are then in a position to obtain the loss value as we forward-pass through the network.</p>
<p>While we considered the sigmoid activation on top of the hidden layer values in the preceding code, let's examine other activation functions that are commonly used.</p>
<p><strong>Tanh</strong></p>
<p><span>The tanh activation of a value (the hidden layer unit value) is calculated as follows:</span></p>
<pre>def tanh(x):<br/>    return (exp(x)-exp(-x))/(exp(x)+exp(-x))</pre>
<p><strong>ReLu</strong></p>
<p>The <strong>Rectified Linear Unit</strong> (<strong>ReLU</strong>) of a value <span>(the hidden layer unit value) </span>is calculated as follows:</p>
<pre>def relu(x):<br/>    return np.where(x&gt;0,x,0)</pre>
<p><strong>Linear</strong></p>
<p>The linear activation of a value is the value itself.</p>
<p><strong>Softmax</strong></p>
<p>Typically, softmax is performed on top of a vector of values. This is generally done to determine the probability of an input belonging to one of the <em>n</em> number of the possible output classes in a given scenario. Let's say we are trying to classify an image of a digit into one of the possible 10 classes (numbers from 0 to 9). In this case, there are 10 output values, where each output value should represent the probability of an input image belonging to one of the 10 classes.</p>
<p>The softmax activation is used to provide a probability value for each class in the output and is calculated explained in the following sections:</p>
<pre>def softmax(x):<br/>    return np.exp(x)/np.sum(np.exp(x))</pre>
<p>Apart from the preceding activation functions, the loss functions that are generally used while building a neural network are as follows.</p>
<p><strong>Mean squared error</strong></p>
<p>The error is the difference between the actual and predicted values of the output. We take a square of the error, as the error can be positive or negative (when the predicted value is greater than the actual value and vice versa). Squaring ensures that positive and negative errors do not offset each other. We calculate the mean squared error so that the error over two different datasets is comparable when the datasets are not the same size.</p>
<p>The mean squared error between predicted values (<kbd>p</kbd>) and actual values (<kbd>y</kbd>) is calculated as follows:</p>
<pre>def mse(p, y):<br/>    return np.mean(np.square(p - y))</pre>
<p>The mean squared error is typically used when trying to predict a value that is continuous in nature.</p>
<p><strong>Mean absolute error</strong></p>
<p>The mean absolute error works in a manner that is very similar to the mean squared error. The mean absolute error ensures that positive and negative errors do not offset each other by taking an average of the absolute difference between the actual and predicted values across all data points.</p>
<p>The mean absolute error between the predicted values (<kbd>p</kbd>) and actual values (<kbd>y</kbd>) is implemented as follows:</p>
<pre>def mae(p, y):<br/>    return np.mean(np.abs(p-y))</pre>
<p>Similar to the mean squared error, the mean absolute error is generally employed on continuous variables.</p>
<p><strong>Categorical cross-entropy</strong></p>
<p>Cross-entropy is a measure of the difference between two different distributions: actual and predicted. It is applied to categorical output data, unlike the previous two loss functions that we discussed.</p>
<p>Cross-entropy between two distributions is calculated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/37b30e1e-0e2d-47e7-b9d5-cdfab9cbc8a0.png" style="width:17.58em;height:1.58em;" width="2550" height="220"/></p>
<p><em>y</em> is the actual outcome of the event and <em>p</em> is the predicted outcome of the event.</p>
<p><span>Categorical cross-entropy between the predicted values (<kbd>p</kbd>) and actual values (<kbd>y</kbd>) is implemented as follows:</span></p>
<pre>def cat_cross_entropy(p, y):<br/>     return -np.sum((y*np.log2(p)+(1-y)*np.log2(1-p)))</pre>
<p>Note that categorical cross-entropy loss has a <span><span>high value</span></span> when the predicted value is far away from the actual value and a low value when the values are close.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building back-propagation from scratch in Python</h1>
                </header>
            
            <article>
                
<p>In forward-propagation, we connected the input layer to the hidden layer to the output layer. In back-propagation, we take the reverse approach.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We change each weight within the neural network by a small amount <span>–</span> one at a time. A change in the weight value will have an impact on the final loss value (either increasing or decreasing loss). We'll update the weight in the direction of decreasing loss.</p>
<p>Additionally, in some scenarios, for a small change in weight, the error increases/decreases considerably, while in some cases the error decreases by a small amount.</p>
<p>By updating the weights by a small amount and measuring the change in error that the update in weights leads to, we are able to do the following:</p>
<ul>
<li>Determine the direction of the weight update</li>
<li>Determine the magnitude of the weight update</li>
</ul>
<p>Before implementing back-propagation, let's understand one additional detail of neural networks: the learning rate.</p>
<p>Intuitively, the learning rate helps us to build trust in the algorithm. For example, when deciding on the magnitude of the weight update, we would potentially not change it by a huge amount in one go, but take a more careful approach in updating the weights more slowly.</p>
<p>This results in obtaining stability in our model; we will look at how the learning rate helps with stability in the next chapter.</p>
<p>The whole process by which we update weights to reduce error is called a gradient-descent technique.</p>
<p><strong>Stochastic gradient descent</strong> is the means by which error is minimized in the preceding scenario. More intuitively, <strong>gradient</strong> stands for difference (which is the difference between actual and predicted) and <strong>descent</strong> means reduce. <strong>Stochastic</strong> stands for the selection of number of random samples based on which a decision is taken.</p>
<p>Apart from stochastic gradient descent, there are many other optimization techniques that help to optimize for the loss values; the different optimization techniques will be discussed in the next <span>chapter</span>.</p>
<p>Back-propagation works as follows:</p>
<ul>
<li>Calculates the overall cost function from the feedforward process.</li>
<li>Varies all the weights (one at a time) by a small amount.</li>
<li>Calculates the impact of the variation of weight on the cost function.</li>
<li>Depending on whether the change has an increased or decreased the cost (loss) value, it updates the weight value in the direction of loss decrease. And then repeats this step across all the weights we have.</li>
</ul>
<p>If the preceding steps are performed <em>n</em> number of times, it essentially results in <em>n</em> <strong>epochs</strong>. </p>
<p>In order to further cement our understanding of back-propagation in neural networks, let's start with a known function and see how the weights could be derived:</p>
<p>For now, we will have the known function as<span> </span><em>y = 2x</em><span>, </span>where we try to come up with the weight value and bias value, which are 2 and 0 in this specific case:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>x</strong></p>
</td>
<td>
<p><strong>y</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>4</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>6</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If we formulate the preceding dataset as a linear regression,<span> </span><em>(y = a*x+b)</em>, where we are trying to calculate the values of<span> </span><em>a</em><span> </span>and<span> </span><em>b</em><span> </span>(which we already know are 2 and 0, but are checking how those values are obtained using gradient descent), let's randomly initialize the<span> </span><em>a</em><span> </span>and<span> </span><em>b</em><span> parameters </span>to values of 1.477 and 0 (the ideal values of which are 2 and 0).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In this section, we will build the back-propagation algorithm by hand so that we clearly understand how weights are calculated in a neural network. In this specific case, we will build a simple neural network where there is no hidden layer (thus we are solving a regression equation). <span>The code file is available as </span><kbd>Neural_network_working_details.ipynb</kbd> in GitHub.</p>
<ol>
<li>Initialize the dataset as follows:</li>
</ol>
<pre style="padding-left: 60px">x = [[1],[2],[3],[4]]<br/>y = [[2],[4],[6],[8]]</pre>
<ol start="2">
<li>Initialize the weight and bias values randomly (we have only one weight and one bias value as we are trying to identify the optimal values of <em>a</em> and <em>b</em> in the <em>y = a*x + b</em> equation):</li>
</ol>
<pre style="padding-left: 60px">w = [[[1.477867]], [0.]]</pre>
<ol start="3">
<li>Define the feed-forward network and calculate the squared error loss value: </li>
</ol>
<pre style="padding-left: 60px">import numpy as np<br/>def feed_forward(inputs, outputs, weights):<br/>     out = np.dot(inputs,weights[0]) + <span>weights[1]</span><br/>     squared_error = (np.square(out - outputs))<br/>     return squared_error</pre>
<p style="padding-left: 60px">In the preceding code, we performed a matrix multiplication of the input with the randomly-initialized weight value and summed it up with the randomly-initialized bias value.</p>
<p style="padding-left: 60px">Once the value is calculated, we calculate the squared error value of the difference between the actual and predicted values.</p>
<ol start="4">
<li>Increase each weight and bias value by a very small amount (0.0001) and calculate the squared error loss value one at a time for each of the weight and bias updates.</li>
</ol>
<p style="padding-left: 60px">If the squared error loss value decreases as the weight increases, the weight value should be increased. The magnitude by which the weight value should be increased is proportional to the amount of loss value the weight change decreases by.</p>
<p style="padding-left: 60px">Additionally, ensure that you do not increase the weight value as much as the loss decrease caused by the weight change, but weigh it down with a factor called the learning rate. This ensures that the loss decreases more smoothly (there's more on how the learning rate impacts the model accuracy in the next chapter).</p>
<p style="padding-left: 60px">In the following code, we are creating a function named <kbd>update_weights</kbd>, which performs the back-propagation process to update weights that were obtained in <em>step 3</em>. We are also mentioning that the function needs to be run for <kbd>epochs</kbd> number of times (where <kbd>epochs</kbd> is a parameter we are passing to <kbd>update_weights</kbd> function):</p>
<pre style="padding-left: 60px">def update_weights(inputs, outputs, weights, epochs): <br/>     for epoch in range(epochs):</pre>
<ol start="5">
<li>Pass the input through a feed-forward network to calculate the loss with the initial set of weights:</li>
</ol>
<pre>        org_loss = feed_forward(inputs, outputs, weights)</pre>
<ol start="6">
<li>Ensure that you<span> </span><kbd>deepcopy</kbd><span> </span>the list of weights, as the weights will be manipulated in further steps, and hence <kbd>deepcopy</kbd> takes care of any issues resulting from the change in the child variable impacting the parent variable that it is pointing to:</li>
</ol>
<pre>        wts_tmp = deepcopy(weights)<br/>        wts_tmp2 = deepcopy(weights)</pre>
<ol start="7">
<li>Loop through all the weight values, one at a time, and change them by a small value (0.0001):</li>
</ol>
<pre>        for i in range(len(weights)):<br/>             wts_tmp[-(i+1)] += 0.0001</pre>
<ol start="8">
<li><span>Calculate the updated feed-forward loss when the weight is updated by a small amount. Calculate the change in loss due to the small change in input. Divide the change in loss by the number of input, as we want to calculate the mean squared error across all the input samples we have:</span></li>
</ol>
<pre>            loss = feed_forward(inputs, outputs, wts_tmp)<br/>            delta_loss = np.sum(org_loss - loss)/(0.0001*len(inputs))</pre>
<div class="packt_infobox">Updating the weight by a small value and then calculating its impact on loss value is equivalent to performing a derivative with respect to change in weight.</div>
<ol start="9">
<li>Update the weights by the change in loss that they are causing. Update the weights slowly by multiplying the change in loss by a very small number (0.01), which is the learning rate parameter (more about the learning rate parameter in the next chapter):</li>
</ol>
<pre>            wts_tmp2[-(i+1)] += delta_loss*0.01 <br/>            wts_tmp = deepcopy(weights)</pre>
<ol start="10">
<li><span>The updated weights and bias value are returned:</span></li>
</ol>
<pre style="padding-left: 60px">    weights = deepcopy(wts_tmp2)<br/> return wts_tmp2</pre>
<p>One of the other parameters in a neural network is the batch size considered in calculating the loss values. </p>
<p>In the preceding scenario, we considered all the data points in order to calculate the loss value. However, in practice, when we have thousands (or in some cases, millions) of data points, the incremental contribution of a greater number of data points while calculating loss value would follow the law of diminishing returns and hence we would be using a batch size that is much smaller compared to the total number of data points we have.</p>
<p>The typical batch size considered in building a model is anywhere between 32 and 1,024.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In the previous section, we built a regression formula <em>(Y = a*x + b)</em> where we wrote a function to identify the optimal values of <em>a</em> and <em>b</em>. In this section, we will build a simple neural network with a hidden layer that connects the input to the output on the same toy dataset that we worked on in the previous section.</p>
<p>We define the model as follows (the code file is available as <kbd>Neural_networks_multiple_layers.ipynb</kbd> in GitHub):</p>
<ul>
<li>The input is connected to a hidden layer that has three units</li>
<li>The hidden layer is connected to the output, which has one unit in output layer</li>
</ul>
<p>Let us go ahead and code up the strategy discussed above, as follows:</p>
<ol>
<li>Define the dataset and import the relevant packages:</li>
</ol>
<pre style="padding-left: 60px">from copy import deepcopy<br/>import numpy as np<br/><br/>x = [[1],[2],[3],[4]]<br/>y = [[2],[4],[6],[8]]</pre>
<p style="padding-left: 60px">We use <kbd>deepcopy</kbd> so that the value of the original variable does not change when the variable to which the original variable's values are copied has its values changed.</p>
<ol start="2">
<li>Initialize the weight and bias values randomly. The hidden layer has three units in it. Hence, there are a total of three weight values and three bias values <span>–</span> one corresponding to each of the hidden units.</li>
</ol>
<p style="padding-left: 60px">Additionally, the final layer has one unit that is connected to the three units of the hidden layer. Hence, a total of three weights and one bias dictate the value of the output layer.</p>
<p style="padding-left: 60px">The randomly-initialized weights are as follows:</p>
<pre style="padding-left: 60px">w = [[[-0.82203424, -0.9185806 , 0.03494298]], [0., 0., 0.], [[ 1.0692896 ],[ 0.62761235],[-0.5426246 ]], [0]]</pre>
<ol start="3">
<li>Implement the feed-forward network where the hidden layer has a ReLU activation in it:</li>
</ol>
<pre style="padding-left: 60px">def feed_forward(inputs, outputs, weights):<br/>     pre_hidden = np.dot(inputs,weights[0])+ weights[1]<br/>     hidden = np.where(pre_hidden&lt;0, 0, pre_hidden) <br/>     out = np.dot(hidden, weights[2]) + weights[3]<br/>     squared_error = (np.square(out - outputs))<br/>     return squared_error</pre>
<ol start="4">
<li>Define the back-propagation function similarly to what we did in the previous section. The only difference is that we now have to update the weights in more layers.</li>
</ol>
<p style="padding-left: 60px"><span>In the following code, we are calculating the original loss at the start of an e</span>poch:</p>
<pre style="padding-left: 60px">def update_weights(inputs, outputs, weights, epochs): <br/>     for epoch in range(epochs):<br/>         org_loss = feed_forward(inputs, outputs, weights)</pre>
<p style="padding-left: 60px"><span>In the following code, we are copying weights into two sets of weight variables so that they can be reused in a later c</span>ode:</p>
<pre style="padding-left: 60px">        wts_new = deepcopy(weights)<br/>        wts_new2 = deepcopy(weights)</pre>
<p style="padding-left: 60px"><span>In the following code, we are updating each weight value by a small amount and then calculating the loss value corresponding to the updated weight value (while every other weight is kept unchanged). Additionally, we are ensuring that the weight update happens across all weights and also across all layers in a network.</span></p>
<p style="padding-left: 60px">The change in the squared loss (<kbd>del_loss</kbd>) is attributed to the change in the weight value. We repeat the preceding step for all the weights that exist in the network:</p>
<pre style="padding-left: 30px">         for i, layer in enumerate(reversed(weights)):<br/>            for index, weight in np.ndenumerate(layer):<br/>                wts_tmp[-(i+1)][index] += 0.0001<br/>                loss = feed_forward(inputs, outputs, wts_tmp)<br/>                del_loss = np.sum(org_loss - loss)/(0.0001*len(inputs))</pre>
<p style="padding-left: 60px"><span>The weight value is updated by weighing down by the learning rate parameter – a </span>greater<span> decrease in loss will update weights by a lot, while a lower decrease in loss will update the weight by a small amo</span>unt:</p>
<pre class="mce-root">               wts_tmp2[-(i+1)][index] += del_loss*0.01<br/>               wts_tmp = deepcopy(weights)</pre>
<div class="packt_tip">Given that the weight values are updated one at a time in order to estimate their impact on the loss value, there is a potential to parallelize the process of weight updates. Hence, GPUs come in handy in such scenarios as they have more cores than a CPU and thus more weights can be updated using a GPU in a given amount of time compared to a CPU.</div>
<p style="padding-left: 60px" class="mce-root"><span>Finally, we return the updated weights:</span></p>
<pre class="mce-root">                    <br/>          weights = deepcopy(wts_tmp2)<br/> return wts_tmp2</pre>
<ol start="5">
<li>Run the function an epoch number of times to update the weights an epoch number of times:</li>
</ol>
<pre style="padding-left: 60px">update_weights(x,y,w,1)</pre>
<p>The output (updated weights) of preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/64c4ca0f-bfe2-4130-91a2-777979b04a6c.jpg" style="width:40.25em;height:8.50em;" width="502" height="106"/></p>
<p>In the preceding steps, we learned how to build a neural network from scratch in Python. In the next section, we will learn about building a neural network in Keras.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a neural network in Keras</h1>
                </header>
            
            <article>
                
<p>In the previous section, we built a neural network from scratch, that is, we wrote functions that perform forward-propagation and back-propagation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will be building a neural network using the Keras library, which provides utilities that make the process of building a complex neural network much easier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Keras</h1>
                </header>
            
            <article>
                
<p>Tensorflow and Keras are implemented in Ubuntu, using the following commands:</p>
<pre><strong>$pip install --no-cache-dir tensorflow-gpu==1.7</strong></pre>
<p>Note that it is preferable to install a GPU-compatible version, as neural networks work considerably faster when they are run on top of a GPU. <span>Keras is a high-level neural network API, written in Python, and capable of running on top of </span>TensorFlow<span>, </span>CNTK<span>, or </span>Theano<span>.</span></p>
<p><span>It was developed with a focus on enabling fast experimentation, </span>and it can be installed as follows:</p>
<pre><strong>$pip install keras</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building our first model in Keras</h1>
                </header>
            
            <article>
                
<p>In this section, let's understand the process of building a model in Keras by using the same toy dataset that we worked on in the previous sections <span>(the code file is available as</span> <kbd>Neural_networks_multiple_layers.ipynb</kbd> in GitHub):</p>
<ol>
<li>Instantiate a model that can be called sequentially to add further layers on top of it. The <kbd>Sequential</kbd> method enables us to perform the model initialization exercise:</li>
</ol>
<pre>from keras.models import Sequential<br/>model = Sequential()</pre>
<ol start="2">
<li>Add a dense layer to the model. A dense layer ensures the connection between various layers in a model. In the following code, we are connecting the input layer to the hidden layer:</li>
</ol>
<pre style="padding-left: 60px">model.add(Dense(3, activation='relu', input_shape=(1,)))</pre>
<p style="padding-left: 60px">In the dense layer initialized with the preceding code, we ensured that we provide the input shape to the model (we need to specify the shape of data that the model has to expect as this is the first dense layer).</p>
<p style="padding-left: 60px">Additionally, we mentioned that there will be three connections made to each input (three units in the hidden layer) and also that the activation that needs to be performed in the hidden layer is the ReLu activation.</p>
<ol start="3">
<li>Connect the hidden layer to the output layer:</li>
</ol>
<pre style="padding-left: 60px">model.add(Dense(1, activation='linear'))</pre>
<p style="padding-left: 60px">Note that in this dense layer, we don't need to specify the input shape, as the model would already infer the input shape from the previous layer. </p>
<p style="padding-left: 60px">Also, given that each output is one-dimensional, our output layer has one unit and the activation that we are performing is the linear activation.</p>
<p style="padding-left: 60px">The model summary can now be visualized as follows:</p>
<pre style="padding-left: 60px">model.summary()</pre>
<p style="padding-left: 60px">A summary of model is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1199 image-border" src="Images/dc9ae0ff-7a5e-4f4a-9234-fbd8c877225f.png" style="width:38.25em;height:12.33em;" width="520" height="168"/></p>
<p style="padding-left: 60px">The preceding output confirms our discussion in the previous section: that there will be a total of six parameters in the connection from the input layer to the hidden layer—three weights and three bias terms—we have a total of six parameters corresponding to the three hidden units. In addition, three weights and one bias term connect the hidden layer to the output layer.</p>
<ol start="4">
<li>Compile the model. This ensures that we define the loss function and the optimizer to reduce the loss function and the learning rate corresponding to the optimizer (we will look at different optimizers and loss functions in next chapter):</li>
</ol>
<pre style="padding-left: 60px">from keras.optimizers import sgd<br/>sgd = sgd(lr = 0.01)</pre>
<p style="padding-left: 60px">In the preceding step, we specified that the optimizer is the stochastic gradient descent that we learned about in the previous section and the learning rate is 0.01. <span>Pass the predefined optimizer and its corresponding learning rate as a parameter and reduce the mean squared error value:</span></p>
<pre style="padding-left: 60px">model.compile(optimizer=sgd,loss='mean_squared_error')</pre>
<ol start="5">
<li>Fit the model. Update the weights so that the model is a better fit:</li>
</ol>
<pre style="padding-left: 60px">model.fit(np.array(x), np.array(y), epochs=1, batch_size = 4, verbose=1)</pre>
<p style="padding-left: 60px">The <kbd>fit</kbd> method expects that it receives two NumPy arrays: an input array and the corresponding output array. Note that <kbd>epochs</kbd> represents the number of times the total dataset is traversed through, and <kbd>batch_size</kbd> represents the number of data points that need to be considered in an iteration of updating the weights. Furthermore, <kbd>verbose</kbd> specifies that the output is more detailed, with information about losses in training and test datasets as well as the progress of the model training process.</p>
<ol start="6">
<li>Extract the weight values. The order in which the weight values are presented is obtained by calling the weights method on top of the model, as follows:</li>
</ol>
<pre style="padding-left: 60px">model.weights</pre>
<p style="padding-left: 60px">The order in which weights are obtained is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1198 image-border" src="Images/faaaee67-07e8-49fa-bd86-10ec8aafd9f8.png" style="width:37.75em;height:5.75em;" width="511" height="78"/></p>
<p style="padding-left: 60px">From the preceding output, we see that the order of weights is the three weights (<kbd>kernel</kbd>) and three bias terms in the <kbd>dense_1</kbd> layer (which is the connection between the input to the hidden layer) and the three weights (<kbd>kernel</kbd>) and one bias term connecting the hidden layer to the <kbd>dense_2</kbd> layer (the output layer).</p>
<p style="padding-left: 60px">Now that we understand the order in which weight values are presented, let's extract the values of these weights:</p>
<pre style="padding-left: 60px">model.get_weights()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">Notice that the weights are presented as a list of arrays, where each array corresponds to the value that is specified in the <kbd>model.weights</kbd> output.</p>
<p style="padding-left: 60px">The output of above lines of code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7a280532-11b9-456d-b37c-311c31731327.jpg" width="502" height="106"/></p>
<p style="padding-left: 60px">You should notice that the output we are observing here matches with the output we obtaining while hand-building the neural network</p>
<ol start="7">
<li>Predict the output for a new set of input using the <kbd>predict</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">x1 = [[5],[6]]<br/>model.predict(np.array(x1))</pre>
<p style="padding-left: 60px">Note that <kbd>x1</kbd> is the variable that holds the values for the new set of examples for which we need to predict the value of the output. Similarly to the <kbd>fit</kbd> method, the <kbd>predict</kbd> method also expects an array as its input.</p>
<p style="padding-left: 60px">The output of preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3c287bfb-ee6c-4bf3-a301-f201cb71cbb2.jpg" width="284" height="40"/></p>
<p>Notice that, while the preceding output is incorrect, the output when we run for 100 epochs is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/39ac7491-ac09-432f-af83-1e6a4d3dec01.jpg" width="274" height="37"/></p>
<p>The preceding output will match the expected output (which are 10, 12) as we run for even higher number of epochs.</p>


            </article>

            
        </section>
    </div>



  </body></html>