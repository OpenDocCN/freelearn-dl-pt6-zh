<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Artificial Intelligence Concepts and Fundamentals</h1>
                </header>
            
            <article>
                
<p>This chapter acts as a prelude<span> </span>to the entire book and the concepts<span> </span>within it. We will understand these concepts at a level high enough for us to appreciate what we will be building throughout the book.</p>
<p>We will start by getting our head around the general structure of <strong>Artificial Intelligence</strong> (<strong>AI</strong>) and its building blocks by comparing AI, machine learning, and deep learning, as these terms can be used interchangeably. Then, we will skim through the history, evolution, and principles behind<span> </span><strong>Artificial Neural Networks </strong>(<strong>ANNs</strong>). Later, we will dive into the fundamental concepts and terms of ANNs and deep learning that will be used throughout the book. After that, we take a brief look at the TensorFlow Playground to reinforce our understanding of ANNs. Finally, we will finish off the chapter with thoughts on where to get a deeper theoretical reference for the high-level concepts of the AI and ANN principles covered in this chapter, which will be as follows:<br/></p>
<ul>
<li>AI versus machine learning versus deep learning</li>
<li>Evolution of AI</li>
<li>The mechanics behind ANNs</li>
<li>Biological neurons</li>
<li>Working of artificial neurons</li>
<li>Activation and cost functions</li>
<li>Gradient descent, backpropagation, and softmax</li>
<li>TensorFlow Playground</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI versus machine learning versus deep learning</h1>
                </header>
            
            <article>
                
<p><strong>AI</strong> is no new term given the plethora of articles we read online and the many movies based on it. So, before we proceed any further, let's take a step back and understand AI and the terms that regularly accompany it from a practitioner's point of view. We will get a clear distinction of what machine learning, deep learning, and AI are, as these terms are often used interchangeably:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-163 image-border" src="assets/d60ec346-e3a6-4851-bab9-25e39508cbcd.png" style="width:37.50em;height:23.83em;"/></p>
<p>AI is the capability that can be embedded into machines that allows machines to perform tasks that are characteristic of human intelligence. These tasks include seeing and recognizing objects, listening and distinguishing sounds, understanding and comprehending language, and other similar tasks.</p>
<p><strong>Machine learning</strong> (<strong>ML</strong>) is a subset of AI that encompasses techniques used to make these human-like tasks possible. So, in a way, ML is what is used to achieve AI.</p>
<p>In essence, if we did not use ML to achieve these tasks, then we would actually be trying to write millions of lines of code with complex loops, rules, and decision trees.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>ML gives machines the ability to learn without being explicitly programmed. So, instead of hardcoding rules for every possible scenario to a task, we simply provide examples of how the task is done versus how it should not be done. ML then trains the system on this provided data so it can learn for itself.</p>
<p>ML is an approach to AI where we can achieve tasks such as grouping or clustering, classifying, recommending, predicting, and forecasting data. Some common examples of this are classifying spam mail, stock market predictions, weather forecasting, and more.</p>
<p><strong>Deep learning</strong> is a special technique in ML that emulates the human brain's biological structure and works to accomplish human-like tasks. This is done by building a network of neurons just like in the brain through an algorithmic approach using ANNs, which are stack of algorithms that can solve problems at human-like efficiency or better.</p>
<p>These layers are commonly referenced as<span> <strong>d</strong></span><strong>eepnets<span> </span></strong>(deep architectures) and each has a specific problem that it can be trained to solve. The deep learning space is currently at the cutting edge of what we see today, with applications such as autonomous driving, Alexa and Siri, machine vision, and more.</p>
<p>Throughout this book, we will be executing tasks and building apps that are built using these deepnets, and we will also solve use cases by building our very own deepnet architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evolution of AI</h1>
                </header>
            
            <article>
                
<p>To appreciate what we can currently do with AI, we need to get a basic understanding of how the idea of emulating the human brain was born, and how this idea evolved to a point where we can easily solve tasks in vision and language with human-like capability through machines.</p>
<p>It all started in 1959 when a couple of Harvard scientists, Hubel and Wiesel, were experimenting with a cat's visual system by monitoring the primary visual cortex in the cat's brain.</p>
<p>The <strong>primary visual cortex</strong> is a collection of neurons in the brain placed at the back of the skull and is responsible for processing vision. It is the first part of the brain that receives input signals from the eye, very much like how a human brain would process vision.</p>
<p><span>The scientists started by showing complex pictures such as those of fish, dogs, and humans to the cat and observed its primary visual cortex. To their disappointment, they got no reading from the primary visual cortex initially. Consequently, to their surprise on one of the trials, as they were removing the slides, dark edges formed, causing some neurons to fire in the primary visual cortex:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-164 image-border" src="assets/8abe3823-b8a6-47b1-a11a-ac88a98fd276.png" style="width:43.92em;height:24.33em;"/></p>
<p>Their serendipitous discovery was that these individual neurons or brain cells in the primary visual cortex were responding to bars or dark edges at various specific orientations. This led to the understanding that the mammalian brain processes a very small amount of information at every neuron, and as the information is passed from neuron to neuron, more complex shapes, edges, curves, and shades are comprehended. So, all these independent neurons holding very basic information need to fire together to comprehend a complete complex image.</p>
<p>After that, there was<span> </span>a lull<span> </span>in the progress of how to emulate the mammalian brain until<span> </span>1980,<span> </span>when<span> </span>Fukushima<span> </span>proposed neocognitron.<span> </span><strong>Neocognitron</strong> is inspired by the idea that we should be able to create an increasingly complex representation using a lot of very simplistic representations – just like the mammalian brain!</p>
<p>The following is a representation of how neocognitron works, by Fukushima:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-165 image-border" src="assets/739593e1-54e0-414c-944d-30ddee2d1473.png" style="width:162.50em;height:82.08em;"/></p>
<p>He proposed that to identify your grandmother, there are a lot of neurons that are triggered in the primary visual cortex, and each cell or neuron understands an abstract part of the final image of your grandmother. All of these neurons work in sequence, parallel, and tandem, and then finally hits a grandmother cell or neuron which fires only when it sees your grandmother.</p>
<p>Fast forward to today (2010-2018), with contributions from Yoshua Bengio, Yann LeCun, and Geoffrey Hinton, who are commonly known as the <em>fathers of deep learning</em>. They contribute massively to the AI space we work in today. They have given rise to a whole new approach to machine learning where feature engineering is automated.</p>
<p>The idea of not explicitly telling the algorithm what it should be looking for and letting it figure this out by itself by feeding it a lot of examples is the latest development.<span> </span>The analogy to this principle would be that of teaching a child to distinguish between an apple and an orange. We would show the child pictures of apples and oranges rather than only describing the two fruits' features, such as shape, color, size, and so on. </p>
<p class="mce-root">The following diagram shows the difference between ML and deep learning:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-166 image-border" src="assets/bdfe861e-68f8-4f48-bdf4-a2be37b1ae07.png" style="width:26.00em;height:14.67em;"/></p>
<p>This is the primary difference between traditional ML and ML using neural networks (deep learning).<span> </span>In traditional ML, we provide features along with labels, but using ANNs, we let the algorithm decipher the features.</p>
<p>We live in an exciting time, an era we share with the fathers of deep learning, so much so that there are exchanges online in places such as Stack Exchange, where we can see contributions even from Yann LeCun and Geoffrey Hinton. This is analogous to living in the time of, and writing to, Nicholas Otto, the father of the internal combustion engine, who started the automobile revolution that we see evolving even to this day. The automobile revolution will be dwarfed by what could be possible with AI in the future. Exciting times, indeed!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The mechanics behind ANNs</h1>
                </header>
            
            <article>
                
<p>In this section, we will understand the nuts and bolts that are required to start building our own AI projects. We will get to grips with the common terms that are used in deep learning techniques.</p>
<p>This section aims to provide the essential theory at a high level, giving you enough insight so that you're able to build your own deep neural networks, tune them, and understand what it takes to make state-of-the-art neural networks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Biological neurons</h1>
                </header>
            
            <article>
                
<p>We previously discussed how the biological brain has been an inspiration behind ANNs. The brain is made up of hundreds of billions of independent units or cells called <strong>neurons</strong>.</p>
<p><span>The following diagram depicts a <strong>neuron</strong>, and it has multiple inputs going into it, called <strong>d</strong></span><strong>endrites</strong><span>. There is also an output going out of the cell body, called the <strong>a</strong></span><strong>xon</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-826 image-border" src="assets/78c9025b-fe58-45e9-8559-f948bf0fa9f3.png" style="width:34.33em;height:34.08em;"/></p>
<p>The dendrites carry information into the neuron and the axon allows the processed information to flow out of the neuron. But in reality, there are thousands of dendrites feeding input into the neuron body as small electrical charges. If these small electrical charges that are carried by the dendrites have an effect on the overall charge of the body or cross over some threshold, then the axon will fire.</p>
<p>Now that we know how a biological neuron functions, we will understand how an artificial neuron works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working of artificial neurons</h1>
                </header>
            
            <article>
                
<p>Just like the biological brain, ANNs are made up of independent units called neurons. Like the biological<span> </span>neuron<span>, </span>the artificial neuron has a body that does some computation and has many inputs that are feeding into the cell body or neuron:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-167 image-border" src="assets/823f3760-3563-4a25-bea7-485f97fd83ea.png" style="width:36.83em;height:25.17em;"/></p>
<p><span>For example, let's assume we have three inputs to the neuron. Each input carries a binary value of 0 or 1. We have an output flowing out of the body, which also carries a binary value of 0 or 1. For this example, the neuron decides whether I should eat a cake today or not. That is, the neuron should fire an output of 1 if I should eat a cake or fire 0 if I shouldn't:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-874 image-border" src="assets/3646d7fd-ccd3-47cc-a909-2ade266b8aa1.png" style="width:48.67em;height:26.42em;"/></p>
<p>In our example, the three inputs represent the three factors that determine whether I should eat the cake or not. Each factor is given a<span> </span>weight of importance; for instance, the first factor is <strong>I did cardio yesterday</strong> and it has a weight of 2. The second factor is <strong>I went to the gym yesterday</strong> and weighs 3. The third factor is <strong>It is an occasion for cake</strong> and weighs 6.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The body of the neuron does some calculation to inputs, such as taking the sum of all of these inputs and checking whether it is over some threshold:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-838 image-border" src="assets/ace25c8d-9dd4-434e-b9e1-c8914bf0d60d.png" style="width:59.08em;height:32.83em;"/></p>
<p><span>So, for this example, let's set our threshold as 4. If the sum of the input weights is above the threshold, then the neuron fires an output of 1, indicating that I can eat the cake.</span></p>
<p>This can be expressed as an equation:</p>
<p class="CDPAlignCenter CDPAlign"><strong> <img class="fm-editor-equation" src="assets/6d3e02c1-3c31-484c-af2a-516841aeed6f.png" style="width:24.75em;height:2.50em;"/></strong></p>
<p>Here, the following applies:</p>
<ul>
<li><em>Xi</em> is the first input factor,<span> </span><em>I did cardio yesterday.</em></li>
<li><em>W<span>i</span></em><span> </span>is the weight of the first input factor, <em>X<span>i</span></em>. In our example, <em>W<span>i </span>= 2</em>.</li>
<li><em>X<span>ii</span></em> is the second input factor, <em>I went to the gym yesterday</em>.</li>
<li><em>W<span>ii</span></em> is the weight of the second input factor, <em>X<span>ii</span></em>. In our example, <em>W<span>ii</span> = 3</em>.</li>
<li><em>Xiii</em> is the third input factor, <em>It is an occasion for cake</em>.</li>
<li><em>W<span>iii</span></em> is the weight of the third input factor, <em>X<span>iii</span></em>. In our example, <em>Wiii<sub> </sub>= 6</em>.</li>
<li><em>threshold</em> is 4.</li>
</ul>
<p>Now, let's use this neuron to decide whether I can eat a cake for three different scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 1</h1>
                </header>
            
            <article>
                
<p>I want to eat a cake and I went to the gym yesterday, but I did not do cardio, nor is it an occasion for cake:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-840 image-border" src="assets/b48ff741-766f-4233-8e04-ddcadf19ae0e.jpg" style="width:47.17em;height:27.08em;"/></p>
<p>Here, the following applies:</p>
<ul>
<li><em>X<span>i</span></em> is the first input factor, <em>I did cardio yesterday</em>. Now, <em>Xi<sub> </sub>= 0,</em> as this is false.</li>
<li><em>W<span>i</span></em> is the weight of the first input factor, <em>X<span>i</span></em>. In our example, <em>Wi<sub> </sub>= 2</em>.</li>
<li><em>X<span>ii</span></em> is the second input factor, <em>I went to the gym yesterday</em>. Now, <em>X<span>ii</span> = 1,</em> as this is true.</li>
<li><em>W<span>ii</span></em> is the weight of the second input factor, <em>X<span>ii</span></em>. In our example, <em>W<span>ii</span></em> = 3.</li>
<li><em>X<span>iii</span></em> is the third input factor, <em>It is an occasion for cake</em>. Now, <em>Xiii<sub> </sub>= 0,</em> as this is false.</li>
<li><em>W<span>iii</span></em> is the weight of the third input factor, <em>X<span>iii</span></em>. In our example, <em>W<span>iii</span></em> = 6.</li>
<li><em>threshold</em> is 4.</li>
</ul>
<p>We know that the neuron computes the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f1cfb10c-000e-46eb-b95e-eca2430d94a0.png" style="width:20.50em;height:1.58em;"/></p>
<p>For scenario 1, the equation will translate to this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/eea9930f-44c4-49bc-ab8a-1175b1b98d9b.png" style="width:12.67em;height:1.58em;"/></p>
<p>This is equal to this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c72373a8-0c4a-4348-a339-a1bb34dee2ac.png" style="width:9.58em;height:1.83em;"/></p>
<p><em>3 ≥ 4</em> is false, so it fires 0, which means I should not eat the cake.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 2</h1>
                </header>
            
            <article>
                
<p>I want to eat a cake and it's my birthday, but I did not do cardio, nor did I go to the gym yesterday:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-839 image-border" src="assets/c3b90c6b-70fb-4205-ae37-f004f3859436.png" style="width:49.17em;height:28.42em;"/></p>
<p>Here, the following applies:</p>
<ul>
<li><em>X<span>i</span></em> is the first input factor, <em>I did cardio yesterday</em>. Now,<span> </span><em>Xi<sub> </sub>= 0,</em><span> </span>as this factor is false.</li>
<li><em>W<span>i</span></em> is the weight of the first input factor, <em>X<span>i</span></em>. In our example, <em>Wi<sub> </sub>= 2</em>.</li>
<li><em>X<span>ii</span></em> is the second input factor, <em>I went to the gym yesterday</em>. Now, <em>X<span>ii</span> = 0,</em><span> </span>as this factor is false.</li>
<li><em>W<span>ii</span></em> is the weight of the second input factor, <em>X<span>ii</span></em>. In our example, <em>W<span>ii</span></em> = 3.</li>
<li><em>X<span>iii</span></em> is the third input factor, <em>It is an occasion for cake</em>. Now,<span> </span><em>Xiii<sub> </sub>= 1,</em><span> this factor</span> is true.</li>
<li><em>W<span>iii</span></em> is the weight of the third input factor, <em>X<span>iii</span></em>. In our example, <em>W<span>iii</span></em> = 6.</li>
<li><em>threshold</em> is 4.</li>
</ul>
<p>We know that the neuron computes the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/2f874d55-53b7-4829-a9be-6b010448f7ba.png" style="width:23.75em;height:1.83em;"/></p>
<p>For scenario 2, the equation will translate to this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5a277032-ef63-4868-b8d3-0e9101a89af3.png" style="width:16.67em;height:2.08em;"/></p>
<p>It gives us the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b326d771-dc1f-4461-acc1-976ccc80bcaa.png" style="width:9.17em;height:1.75em;"/></p>
<p><em>6 ≥ 4</em> is true, so this fires 1, which means I can eat the cake.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 3</h1>
                </header>
            
            <article>
                
<p>I want to eat a cake and I did cardio and went to the gym yesterday, but it is also not an occasion for cake:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-837 image-border" src="assets/9719159c-ae4d-4d84-bd40-40e2b9419f06.png" style="width:49.33em;height:29.00em;"/></p>
<p>Here, the following applies:</p>
<ul>
<li><em>X<span>i</span></em> is the first input factor, <em>I did cardio yesterday</em>. Now,<span> </span><em>Xi<sub> </sub>= 1,</em><span> </span>as this factor is true.</li>
<li><em>W<span>i</span></em> is the weight of the first input factor, <em>X<span>i</span></em>. In our example, <em>Wi<sub> </sub>= 2</em>.</li>
<li><em>X<span>ii</span></em> is the second input factor, <em>I went to the gym yesterday</em>. Now, <em>X<span>ii</span> = 1,</em><span> </span>as this factor is true.</li>
<li><em>W<span>ii</span></em> is the weight of the second input factor, <em>X<span>ii</span></em>. In our example, <em>W<span>ii</span></em> = 3.</li>
<li><em>X<span>iii</span></em> is the third input factor, <em>It is an occasion for cake</em>. Now,<span> </span><em>Xiii<sub> </sub>= 0,</em><span> as this factor</span> is false.</li>
<li><em>W<span>iii</span></em> is the weight of the third input factor, <em>X<span>iii</span></em>. In our example, <em>W<span>iii</span></em> = 6.</li>
<li><em>threshold</em> is 4.</li>
</ul>
<p>We know that the neuron computes the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d1697414-06e7-4cf0-8b74-ac1759983538.png" style="width:19.42em;height:1.50em;"/></p>
<p>For scenario 3, the equation will translate to this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0e09f54b-fd7a-4f76-9c68-da19d034fefc.png" style="width:14.67em;height:1.83em;"/></p>
<p>This gives us the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/920fd23a-247e-47fe-a27f-827f2a80209e.png" style="width:8.58em;height:1.67em;"/></p>
<p><em>5 ≥ 4</em> is true, so this fires 1, which means I can eat the cake.</p>
<p>From the preceding three scenarios, we saw how a single artificial neuron works. This single unit is also called a <strong>perceptron</strong>. A perceptron essentially handles binary inputs, computes the sum, and then compares with a threshold to ultimately give a binary output.</p>
<p><span>To better appreciate how a perceptron works, we can translate our preceding equation into a more generalized form for the sake of explanation.</span></p>
<p><span>Let's assume there is just one input factor, for simplicity:</span></p>
<p class="CDPAlignCenter CDPAlign"><strong><img class="fm-editor-equation" src="assets/bec404cd-2afa-4e53-9147-ccf45328046c.png" style="width:18.75em;height:1.67em;"/></strong></p>
<p>Let's also assume that <em>threshold = b</em>. Our equation was as follows:</p>
<p class="CDPAlignCenter CDPAlign"><strong><img class="fm-editor-equation" src="assets/9b74e4cc-32e8-4628-bef0-98d523e06c5d.png" style="width:28.08em;height:2.83em;"/></strong></p>
<p>It now becomes this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/41971681-10e2-4ff7-a7b5-a7906f788a70.png" style="width:12.08em;height:2.92em;"/></p>
<p>It can also be written as <img class="fm-editor-equation" src="assets/d3f7ba54-6bfa-4cc9-a9b2-6ab7de85e569.png" style="width:8.58em;height:1.25em;"/>, then output<span> </span><em>1</em><strong> </strong>else <em>0</em><em>.</em></p>
<p>Here, the following applies:</p>
<ul>
<li><em>w</em> is the weight of the input</li>
<li><em>b</em> is the threshold and is referred to as the bias</li>
</ul>
<p class="mce-root"/>
<p>This rule summarizes how a perceptron neuron works.</p>
<p>Just like the mammalian brain, an ANN is made up of many such perceptions that are stacked and layered together. In the next section, we will get an understanding of how these neurons work together within an ANN.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ANNs</h1>
                </header>
            
            <article>
                
<p>Like biological neurons, artificial neurons also do not exist on their own. They exist in a network with other neurons. Basically, the neurons exist by feeding information to each other; the outputs of some neurons are inputs to some other neurons.</p>
<p>In any ANN, the<span> </span>first layer is called the <strong>Input Layer</strong>. These inputs are real values, such as the factors with weights (<em>w.x</em>) in our previous example. The sum values from the input layer are propagated to each neuron in the next layer. The neurons of that layer do the computation and pass their output to the next layer, and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-827 image-border" src="assets/d40f5cee-3ac8-47b8-8d00-5c206d33504a.png" style="width:51.33em;height:28.67em;"/></p>
<p>The layer that receives input from all previous neurons and passes its output to all of the neurons of the next layer is<span> </span>called a <strong>Dense<span> </span></strong>layer. As this layer is connected to all of the neurons of the previous and next layer, it is also commonly referred to as a<span> </span><strong>Fully Connected Layer</strong>.</p>
<p>The input and computation flow from layer to layer and finally end at the<span> </span><strong>Output Layer</strong>, which gives the end estimate of the whole ANN.</p>
<p>The layers in-between the input and the output layers are called the<span> </span><strong>Hidden Layers</strong>, as the values of the neurons within these hidden layers are unknown and a complete black box to the practitioner.</p>
<p>As you increase the number of layers, you increase the abstraction of the network, which in turn increases the ability of the network to solve more complex problems. When there are over three hidden layers, then it is referred to as a deepnet.</p>
<p>So, if this was a machine vision task, then the first hidden layer would be looking for edges, the next would look for corners, the next for curves and simple shapes, and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-828 image-border" src="assets/a0dcb8f4-d1c7-41a7-b083-14c5f9e374e1.png" style="width:51.25em;height:33.67em;"/></p>
<p>Therefore, the complexity of the problem can determine the number of layers that are required; more layers lead to more abstractions. These layers can be very deep, with 1,000 or more layers, to very shallow, with just about half a dozen layers. Increasing the number of hidden layers does not necessarily give better results as the abstractions may be redundant.</p>
<p>So far, we have seen how artificial neurons can be stacked together to form a neural network. But we have seen that the perceptron neuron takes <span>only</span> binary input and gives <span>only </span>binary output. But in practice, there is a problem in doing things based on the perceptron's idea. This problem is addressed by activation functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activation functions</h1>
                </header>
            
            <article>
                
<p>We now know that an ANN is created by stacking individual computing units called perceptrons. We have also seen how a perceptron works and have summarized it as <em>Output<span> </span>1,<span> </span>IF</em><span><em>  </em><strong><img class="fm-editor-equation" src="assets/87250af0-6998-4cbb-b723-de4fc5b87ba3.png" style="width:8.08em;height:1.50em;"/></strong>.</span></p>
<p>That is, it either outputs a <em>1</em> or a <em>0</em> depending on the values of the weight, <em>w</em>, and bias, <em>b</em>.</p>
<p>Let's look at the following diagram to understand why there is a problem with just outputting either a <em>1</em> or a <em>0</em>. The following is a diagram of a simple perceptron with just a single input, <em>x</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-734 image-border" src="assets/b59c88c9-dbea-4dc0-8ef5-99ade5565357.png" style="width:32.58em;height:10.67em;"/></p>
<p>For simplicity, let's call  <img class="fm-editor-equation" src="assets/9105c1c0-e7e4-4706-8721-579dc2c88c01.png" style="width:8.00em;height:1.42em;"/><span>, where the following applies:</span></p>
<ul>
<li><em>w</em> is the weight of the input, <em>x,</em> and <em>b</em> is the bias</li>
<li><em>a</em> is the output, which is either <em>1</em> or <em>0</em></li>
</ul>
<p>Here, as the value of <em>z</em> changes, at some point, the output, <em>a</em>, changes from <em>0</em> to <em>1</em>. As you can see, the change in output <em>a</em> is sudden and drastic:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-735 image-border" src="assets/0609f818-9b0f-4e5e-a00a-f2a2399e8303.jpg" style="width:18.92em;height:18.58em;"/></p>
<p>What this means is that for some small change, <img class="fm-editor-equation" src="assets/3f95d5b7-7f37-417f-8d51-d3e966dd1a9f.png" style="width:1.75em;height:1.17em;"/> , we get a dramatic change in the output, <em>a</em>. This is not particularly helpful if the perceptron is part of a network, because if each perceptron has such drastic change, it makes the network unstable and hence the network fails to learn.</p>
<p>Therefore, to make the network more efficient and stable, we need to slow down the way each perceptron learns. In other words, we need to eliminate this sudden change in output from <em>0</em> to <em>1</em> to a more gradual change:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-736 image-border" src="assets/558d13a2-28ee-4578-a130-9118cf059004.jpg" style="width:20.92em;height:20.58em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is made possible by activation functions. Activation functions are functions that are applied to a perceptron so that instead of outputting a <em>0</em> or a <em>1</em>, it outputs any value between <em>0</em> and <em>1</em>.</p>
<p>This means that each neuron can learn slower and at a greater level of detail by using smaller changes, <img src="assets/660fdf4e-3332-4f80-a224-575de3824318.png" style="width:2.08em;height:1.42em;"/>.  Activation functions can be looked at as transformation functions that are used to transform binary values in to a sequence of smaller values between a given minimum and maximum.</p>
<p>There are a number of ways to transform the binary outcomes to a sequence of values, namely the sigmoid function, the<span> t</span>anh<span> </span>function, and the ReLU function. We will have a quick look at each of these activation functions now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sigmoid function</h1>
                </header>
            
            <article>
                
<p>The <strong>sigmoid function</strong> is a function in mathematics that outputs a value between 0 and 1 for any input:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c0adb54a-93c5-414f-988e-c067850e6eb4.png" style="width:9.83em;height:1.50em;"/></p>
<p>Here, <img class="fm-editor-equation" src="assets/60bb9873-524f-45a9-84ba-8ac74caac355.png" style="width:5.67em;height:1.17em;"/> and<span> </span><span><img class="fm-editor-equation" src="assets/f5076aa3-efc1-47e4-a41f-6ee338e6bfd8.png" style="width:6.17em;height:1.33em;"/>.</span></p>
<p>Let's understand sigmoid functions better with the help of some simple code. If you do not have Python installed, no problem: we will use an online alternative for now at <a href="https://www.jdoodle.com/python-programming-online" target="_blank">https://www.jdoodle.com/python-programming-online</a>. We will go through a complete setup from scratch in <a href="eb50909d-69fb-4228-967b-af2f58c543c3.xhtml">Chapter 2</a>, <em>Creating a Real-Estate Price Prediction Mobile App</em>. Right now, let's quickly continue with the online alternative.</p>
<p>Once we have the page at<span> </span><a href="https://www.jdoodle.com/python-programming-online" target="_blank">https://www.jdoodle.com/python-programming-online</a><span> </span>loaded, we can go through the code step by step and understand sigmoid functions:</p>
<ol>
<li>First, let's import the <kbd>math</kbd> library so that we can use the exponential function:</li>
</ol>
<pre style="padding-left: 60px"><span class="kn">from</span><span class="kn"> </span><span> </span><span class="nn"> </span><span class="nn">math </span><span> </span><span class="k"> import </span><span> </span><span class="n">e</span></pre>
<ol start="2">
<li>Next, let's define a function called <kbd>sigmoid</kbd>, based on the earlier formula:</li>
</ol>
<pre style="padding-left: 60px"><span class="k">def<span> </span></span><span class="nf">sigmoid</span><span> </span><span class="p">(</span><span> </span><span class="n">x</span><span> </span><span class="p">):</span><span class="k">    <br/>    return<span> </span></span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span>(</span><span> </span><span class="mi">1</span><span> </span><span class="o">+</span><span> </span><span class="n">e</span><span> </span><span class="o">**-</span><span> </span><span class="n">x</span><span> </span><span>)</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Let's take a scenario where our <em>z</em> is very small, <kbd>-10</kbd>. Therefore, the function outputs a number that is very small and close to 0:</li>
</ol>
<pre style="padding-left: 60px"><span class="n">sigmoid</span><span class="p">(</span><span class="o">-10</span><span class="p">)</span> <br/>4.539786870243442e-05</pre>
<ol start="4">
<li>If <em>z</em> is very large, such as <kbd>10000</kbd>, then the function<span> will </span>output<span> </span>the maximum<span> </span>possible<span> </span>value, 1:</li>
</ol>
<pre style="padding-left: 60px"><span class="n">sigmoid</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>  <br/>1.0</pre>
<p>Therefore, the sigmoid function transforms any value, <em>z</em>, to a value between 0 and 1. When the sigmoid activation function is used on a neuron instead of the traditional perceptron algorithm, we get what is called a <strong>sigmoid neuron</strong>:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tanh function</h1>
                </header>
            
            <article>
                
<p>Similar to the sigmoid neuron, we can apply<span> </span>an activation function called<span> t</span>anh(<em>z</em>), which transforms any value to a value between -1 and 1.</p>
<p>The neuron that uses this activation function is called a<span> <strong>t</strong></span><strong>anh<span> </span>neuron</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-737 image-border" src="assets/2161bec9-1aae-4b92-91f7-21d0ee1ca56d.png" style="width:20.00em;height:17.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ReLU function </h1>
                </header>
            
            <article>
                
<p>Then there is an<span> </span>activation function called the <strong>Rectified Linear Unit</strong>, <strong>ReLU(z)</strong>, that transforms any value, <em>z</em>, to 0 or a value above 0. In other words, it outputs any value below 0 as 0 and any value above 0 as the value itself:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-738 image-border" src="assets/af0454a7-3151-4abf-a1af-da3be88ab020.png" style="width:18.50em;height:15.50em;"/></p>
<p>Just to summarize our understanding so far,<span> </span>the perceptron is the traditional and outdated neuron that is rarely used in real implementations. They are great to get a simplistic understanding of the underlying principle; however, they had the problem of fast learning due to the drastic changes in output values.</p>
<p>W<span>e use activation functions t</span>o reduce the learning speed and determine finer changes in <em>z</em> or  <img class="fm-editor-equation" src="assets/2469dc05-58c0-4c3f-848c-ab28a70b8385.png" style="width:5.25em;height:1.42em;"/>. Let's sum up these activation functions:</p>
<ul>
<li>The<span> </span><strong>sigmoid neuron</strong><span> </span>is the neuron that uses the sigmoid activation function to transform the output to a value between 0 and 1.</li>
<li>The<span> <strong>t</strong></span><strong>anh<span> </span>neuron</strong><span> </span>is the neuron that uses the<span> t</span>anh<span> </span>activation function to transform the output to a value between -1 and 1.</li>
<li>The<span> </span><strong>ReLU neuron</strong><span> </span>is the neuron that uses the ReLU activation function to transform the output to a value of either 0 or any value above 0.</li>
</ul>
<p>The sigmoid function is used in practice but is slow compared to the<span> t</span>anh<span> </span>and ReLU functions. The<span> t</span>anh<span> </span>and ReLU functions are commonly used activation functions. The ReLU function is also considered state of the art and is usually the first choice of activation function that's used to build ANNs.</p>
<p>Here is a list of commonly used activation functions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-739 image-border" src="assets/67a40589-04e2-4744-b539-5d814a516ef2.jpg" style="width:31.67em;height:31.50em;"/></p>
<p>In the projects within this book, we will be primarily using either the sigmoid,<span> t</span>anh,<span> </span>or the ReLU neurons to build our ANN.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cost functions</h1>
                </header>
            
            <article>
                
<p>To quickly recap, we know how a basic perceptron works and its pitfalls. We then saw how activation functions overcame the perceptron's pitfalls, giving rise to other neuron types that are in use today.</p>
<p>Now, we are going to look at how we can tell when the neurons are wrong. For any type of neuron to learn, it needs to know when it outputs the wrong value and by what margin. The most common way to measure how wrong the neural network is, is to use a cost function.</p>
<p>A <strong>cost function</strong> quantifies the difference between the output we get from a neuron to an output that we need from that neuron.<span> </span>There are two common types of cost functions that are used: mean squared error and cross entropy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mean squared error</h1>
                </header>
            
            <article>
                
<p>The <strong>mean squared error</strong> (<strong>MSE</strong>) is also called a quadratic cost function as it uses the squared difference to measure the magnitude of the error:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9f61fab8-dc30-44bd-9b79-a6b70a6ca878.png" style="width:9.42em;height:1.50em;"/></p>
<p class="mce-root">Here, the following applies:</p>
<ul>
<li><em>a</em> is the output from the ANN</li>
<li><em>y</em> is the expected output</li>
<li><em>n</em> is the number of samples used</li>
</ul>
<p>The cost function is pretty<span> </span>straightforward. For<span> </span>example<span>, </span>consider a single neuron with just one sample, (<em>n=1</em>). If the expected output is 2 (<em>y=2</em>) and the neuron outputs 3 (<em>a=3</em>), then the MSE is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c18a1923-6add-41b7-a4ae-43a0943bdb46.png" style="width:9.42em;height:1.50em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c7b65bad-5cd3-4ce3-b65a-70b26c4d8bbb.png" style="width:6.50em;height:1.33em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d14ec931-b364-4688-97ed-3661cdae3063.png" style="width:4.67em;height:1.00em;"/></p>
<p>Similarly, if the expected output is 3 (<em>y=3</em>) and the neuron outputs 2 (<em>a=2</em>), then the MSE is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1cbaaf60-0a6c-4b58-9fb8-cbbbc36a0acc.png" style="width:9.83em;height:1.58em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4d35819d-c83d-4b5a-8f39-c195161ac485.png" style="width:6.42em;height:1.50em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/39b26616-25dc-4fdf-b431-4b1762ed882a.png" style="width:5.50em;height:1.17em;"/></p>
<p>Therefore, the MSE quantifies the magnitude of the error made by the neuron. One of the issues with MSE is that when the values in the network get large, the learning becomes slow. In other words, when the weights (<em>w</em>) and bias (<em>b</em>) or <em>z</em> get large, the learning becomes very slow. Keep in mind that we are talking about thousands of neurons in an ANN, which is why the learning slows down and eventually stagnates with no further learning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross entropy</h1>
                </header>
            
            <article>
                
<p><strong>Cross entropy</strong> is a derivative-based function as it uses the derivative of a specially designed equation, which is given as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d7e1d48b-f68b-4431-974a-dba3b24e7c85.png" style="width:27.92em;height:1.33em;"/></p>
<p>Cross entropy allows the network to learn faster when the difference between the expected and actual output is greater. In other words, the bigger the error, the faster it helps the network learn. We will get our heads around this using some simple code.</p>
<p>Like before, for now, you can use an online alternative if you do not have Python already installed, at<span> </span><a href="https://www.jdoodle.com/python-programming-online">https://www.jdoodle.com/python-programming-online</a>. We will cover the installation and setup in <a href="eb50909d-69fb-4228-967b-af2f58c543c3.xhtml" target="_blank">Chapter 2</a>, <em>Creating a Real-Estate Price Prediction</em> <em>Mobile App</em>. Follow these steps to see how a network learns using cross entropy:</p>
<ol>
<li>First, let's import the <kbd>math</kbd> library so that we can use the <kbd>log</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">from numpy import log  </pre>
<ol start="2">
<li>Next, let's define a function called <kbd>cross_enrtopy</kbd>, based on the preceding formula:</li>
</ol>
<pre style="padding-left: 60px"><span class="k">def c</span><span class="nf">ross_entropy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">a</span><span class="p">):</span> <br/><span class="k">    return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">log</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">a</span><span class="p">))</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>For example, consider a single neuron with just one sample, (<em>n=1</em>). Say the expected output is <kbd>0</kbd> (<em>y=0</em>) and the neuron outputs <kbd>0.01</kbd> (<em>a=0.01</em>):</li>
</ol>
<pre style="padding-left: 60px">cross_entropy(0, 0.01)</pre>
<p style="padding-left: 60px">The output is as follows:</p>
<pre style="padding-left: 60px">0.010050335853501451</pre>
<p>Since the expected and actual output values are very small, the resultant cost is very small.</p>
<p>Similarly, if the expected and actual output values are very large, then the resultant cost is still small:</p>
<pre><span class="n">cross_entropy</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">999.99</span><span class="p">)</span> </pre>
<p><span>The output is as follows:</span></p>
<pre>0.010050335853501451</pre>
<p>Similarly, if the expected and actual output values are far apart, then the resultant cost is large:</p>
<pre><span class="n">cross_entropy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.9</span><span class="p">)</span> </pre>
<p><span>The output is as follows:</span></p>
<pre>2.3025850929940459</pre>
<p>Therefore, the larger the difference in expected versus actual output, the faster the learning becomes. Using cross entropy, we can get the error of the network, and at the same time, the magnitude of the weights and bias is irrelevant, helping the network learn faster.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gradient descent</h1>
                </header>
            
            <article>
                
<p>Up until now, we have covered the different kind of neurons based on the activation functions that are used. We have covered the ways to quantify inaccuracy in the output of a neuron using cost functions. Now, we need a mechanism to take that inaccuracy and remedy it.</p>
<p>The mechanism through which the network can learn to output values closer to the expected or desired output is<span> </span>called <strong>gradient descent</strong>. Gradient descent<span> </span>is a common approach in machine learning for finding the lowest cost possible.</p>
<p class="mce-root"/>
<p>To understand gradient descent, let's use the single neuron equation we have been using so far:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c8dd1e82-570f-42cd-920e-4395ad993c09.png" style="width:7.08em;height:1.33em;"/></p>
<p class="mce-root">Here, the following applies:</p>
<ul>
<li><em>x</em> is the input</li>
<li><em>w</em> is the weight of the input</li>
<li><em>b</em> is the bias of the input</li>
</ul>
<p>Gradient descent can be represented as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-830 image-border" src="assets/a9278133-1d21-4301-b560-08a75e14b516.png" style="width:37.75em;height:19.33em;"/></p>
<p>Initially, the neuron starts by assigning random values for <em>w</em> and <em>b</em>. From that point onward, the neuron needs to adjust the values of <em>w</em> and <em>b</em> so<em> </em>that it lowers or decreases the error or cost (cross entropy).</p>
<p>Taking the derivative of the cross entropy (cost function) results in a step-by-step change in <em>w</em> and <em>b</em> in the direction of the lowest cost possible. In other words, <strong>gradient descent</strong><span> </span>tries to find the finest line between the network output and expected output.</p>
<p>The weights are adjusted based on a parameter called the<span> <strong>l</strong></span><strong>earning rate.</strong><span> </span>The learning rate is the value that is adjusted to the weight of the neuron to get an output closer to the expected output.</p>
<p class="mce-root"/>
<p>Keep in mind that here, we have used only a single parameter; this is only to make things easier to comprehend. In reality, there are thousands upon millions of parameters that are taken into consideration to lower the cost.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backpropagation – a method for neural networks to learn</h1>
                </header>
            
            <article>
                
<p>Great! We have come a long way, from looking at the biological neuron, to the types of neuron, to determining accuracy, and correcting the learning of the neuron. Only one question remains: <em>how can the whole network of neurons learn together?</em></p>
<p><strong>Backpropagation</strong> is an incredibly smart approach to making gradient descent happen throughout the network across all layers.<span> </span>Backpropagation leverages the chain rule from calculus to make it possible to transfer information back and forth through the network:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-741 image-border" src="assets/2347ee42-e9b4-4236-8b0c-8dafa257cf50.jpg" style="width:37.67em;height:25.08em;"/></p>
<p>In principle, the information from the input parameters and weights is propagated through the network to make a guess at the expected output and then the overall inaccuracy is backpropagated through the layers of the network so that the weights can be adjusted and the output can be guessed again.</p>
<p>This single cycle of learning is called a<span> <strong>t</strong></span><strong>raining step</strong> or<span> <strong>i</strong></span><strong>teration</strong>. Each iteration is performed on a batch of the input training samples. The number of samples in a batch is called<span> <strong>b</strong></span><strong>atch size</strong>. When all of the input samples have been through an iteration or training step, then it is called an<span> </span><strong>epoch</strong>.</p>
<p>For example, let's say there are 100 training samples and in every iteration or training step, there are 10 samples being used by the network to learn. Then, we can say that the batch size is 10 and it will take 10 iterations to complete a single epoch. Provided each batch has unique samples, that is, if every sample is used by the network at least once, then it is a single epoch. </p>
<p>This back-and-forth propagation of the predicted output and the cost through the network is how the network learns.</p>
<p>We will revisit training step, epoch, learning rate, cross entropy, batch size, and more during our hands-on sections. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Softmax</h1>
                </header>
            
            <article>
                
<p>We have reached our final conceptual topic for this chapter. We've covered types of neurons, cost functions, gradient descent, and finally a mechanism to apply gradient descent across the network, making it possible to learn over repeated iterations.</p>
<p>Previously, we saw the input layer and dense or hidden layers of an ANN:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-742 image-border" src="assets/a8dbb075-44b2-41c1-9380-a3ea3f8dd76d.jpg" style="width:29.25em;height:21.92em;"/></p>
<p><strong>Softmax</strong> is a special kind of neuron that's used in the output layer to describe the probability of the respective output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4f904f31-079f-4eee-b8da-a970c52f121c.png" style="width:14.25em;height:1.92em;"/></p>
<p>To understand the softmax equation and its concepts, we will be using some code. Like before, for now, you can use any online Python editor to follow the code.</p>
<p>First, import the exponential methods from the <kbd>math</kbd> library:</p>
<pre class="mce-root">     from math import exp </pre>
<p>For the sake of this example, let's say that this network is designed to classify three possible labels: <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd>. Let's say that there are three signals going into the softmax from the previous layers (-1, 1, 5):</p>
<pre>    <span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">]<br/></span></pre>
<p>The explanation is as follows:</p>
<ul>
<li>The first signal indicates that the output should be <kbd>A</kbd>, but is weak and is represented with a value of -1</li>
<li>The second signal indicates that the output should be <kbd>B</kbd> and is slightly stronger and represented with a value of 1</li>
<li>The third signal is the strongest, indicating that the output should be <kbd>C</kbd> and is represented with a value of 5</li>
</ul>
<p>These represented values are confidence measures of what the expected output should be.</p>
<p>Now, let's take the numerator of the softmax for the first signal, guessing that the output is <kbd>A</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a354238f-684e-4657-b6b2-326b60172ab6.png" style="width:14.83em;height:1.58em;"/></p>
<p>Here, <em>M</em> is the output signal strength indicating that the output should be <kbd>A</kbd>:</p>
<pre><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]) # taking the first element of a[-1,1,5] </span><span class="p">which represents A<br/><br/></span>0.36787944117144233</pre>
<p class="CDPAlignLeft CDPAlign">Next, there's the numerator of the softmax for the second signal, guessing that the output is <kbd>B</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a354238f-684e-4657-b6b2-326b60172ab6.png" style="width:14.83em;height:1.58em;"/></p>
<p>Here, <kbd>M</kbd> is the output signal strength indicating that the output should be <kbd>B</kbd>:</p>
<pre><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]) # taking the second element of a[-1,1,5] </span><span class="p">which represents B<br/><br/></span>2.718281828459045</pre>
<p>Finally, there's the numerator of the softmax for the second signal, guessing that the output is <kbd>C</kbd>: </p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dc4b8b76-9465-424c-95f0-a7814745c5c7.png" style="width:14.08em;height:1.50em;"/></p>
<p>Here, <kbd>M</kbd> is the output signal strength indicating that the output should be<span> </span><kbd>C</kbd>:</p>
<pre><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]) <br/># taking the third element of a[-1,1,5] which represents C<br/><br/></span>148.4131591025766</pre>
<p>We can observe that the represented confidence values are always placed above 0 and that the resultant is made exponentially larger.</p>
<p>Now, let's interpret the denominator of the softmax function, which is a sum of the exponential of each signal value:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/75d8dee4-c88e-40b4-9a49-dc4e732088e8.png" style="width:17.67em;height:1.75em;"/></p>
<p>Let's write some code for softmax function:</p>
<pre><span class="n">sigma</span><span> </span><span class="o">=</span><span> </span><span class="n">exp</span><span> </span><span class="p">(</span><span> </span><span class="n">a</span><span> </span><span class="p">[</span><span> </span><span class="mi">0</span><span> </span><span class="p">])</span><span> </span><span class="o">+</span><span> </span><span class="n">exp</span><span> </span><span class="p">(</span><span> </span><span class="n">a</span><span> </span><span class="p">[</span><span> </span><span class="mi">1</span><span> </span><span class="p">])</span><span> </span><span class="o">+</span><span> </span><span class="n">exp</span><span> </span><span class="p">(</span><span> </span><span class="n">a</span><span> </span><span class="p">[</span><span> </span><span class="mi">2</span><span> </span><span class="p">]) <br/></span>sigma<br/><br/>151.49932037220708</pre>
<p>Therefore, the probability that the first signal is correct is as follows:</p>
<pre><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">sigma<br/><br/></span>0.0024282580295913376</pre>
<p>This is less than a 1% chance that it is <kbd>A</kbd>.</p>
<p>Similarly, the probability that the third signal is correct is as follows:</p>
<pre><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">[2</span><span class="p">])</span><span class="o">/</span><span class="n">sigma<br/><br/></span>0.9796292071670795</pre>
<p>This means there is over a 97% chance that the expected output is indeed <kbd>C</kbd>.</p>
<p>Essentially, the<span> </span>softmax<span> </span>accepts a weighted signal that indicates the confidence of some class prediction and outputs a probability score between 0 to 1 for all of those classes.</p>
<p>Great! We have made it through the essential high-level theory that's required to get us hands on with our projects. Next up, we will summarize our understanding of these concepts by exploring the TensorFlow Playground.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TensorFlow Playground</h1>
                </header>
            
            <article>
                
<p>Before we get started with the TensorFlow Playground, let's recap the essential concepts quickly. It will help us appreciate the TensorFlow Playground better.</p>
<p>The inspiration for neural networks is the biological brain, and the smallest unit in the brain is a<span> </span><strong>neuron</strong>.</p>
<p>A <strong>P</strong><strong>erceptron</strong><span> </span>is a neuron based on the idea of the biological neuron. The perceptron basically deals with binary inputs and outputs, making it impractical for actual pragmatic purposes. Also, because of its binary nature, it learns too fast due to the drastic change in output for a small change in input, and so does not provide fine details.</p>
<p><strong>Activation </strong><strong>functions</strong><span> </span>were used to negate the issue with perceptrons. This gave rise to other types of neurons that deal with values between ranges of 0 to 1, -1 to 1, and so on, instead of just a 0 or a 1.</p>
<p><strong>ANNs</strong> are made up of these neurons stacked in layers. There is an input layer, a dense or fully connected layer, and an output layer.</p>
<p><strong>Cost functions</strong>,<span> </span>such as MSE and cross entropy, are ways to measure the magnitude of error in the output of a neuron.</p>
<p><strong>Gradient descent</strong> is a mechanism through which a neuron can learn to output values closer to the expected or desired output.</p>
<p><strong>Backpropagation </strong>is<span> </span>an incredibly smart approach to making gradient descent happen throughout the network across all layers.</p>
<p>Each back and forth propagation or iteration of the predicted output and the cost through the network is called a <strong>training step</strong>.</p>
<p>The<span> </span><strong>learning rate</strong><span> </span>is the value that is adjusted to the weight of the neuron at each training step to get an output that's closer to the expected output.</p>
<p><strong>Softmax</strong> is<span> </span>a special kind of neuron that accepts a weighted signal indicating the confidence of some class prediction and outputting a probability score between 0 to 1 for all of those classes.</p>
<p>Now, we can proceed to TensorFlow Playground at<span> </span><a href="https://playground.tensorflow.org">https://Playground.tensorflow.org</a>. TensorFlow Playground is an online tool to visualize an ANN or deepnet in action, and is an excellent place to reiterate what we have learned conceptually in a visual and intuitive way.</p>
<p>Now, without further ado, let's get on with TensorFlow Playground. Once the page is loaded, you will see a dashboard to create your own neural network for predefined classification problems. Here is a screenshot of the default page and its sections:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-831 image-border" src="assets/b9d0dbd1-00ed-4a54-9bfb-2740326d4a34.png" style="width:50.17em;height:26.33em;"/></p>
<p>Let's look at each of the sections from this screenshot:</p>
<ul>
<li><span class="packt_screen">Section 1</span>:<span> </span>The data section shows choices of the pre-built problems to build and visualize the network. The first problem is chosen, which is basically to distinguish between the blue an orange dots. Below that, there are controls to divide the data into training and testing subsets. There is also a parameter to set the batch size. The<span> </span><span class="packt_screen">Batch size</span><span> </span>is the number of samples that are taken into the network for learning during each training step.</li>
<li><span class="packt_screen">Section 2</span>:<span> </span>The features section indicates the number of input parameters. In this case, there are two features chosen as the input features.</li>
<li><span class="packt_screen">Section 3</span>:<span> </span>The hidden layer section is where we can create hidden layers to increase complexity. There are also controls to increase and decrease the number of neurons within each hidden or dense layer. In this example, there are two hidden layers with four and two neurons, respectively.</li>
<li><span class="packt_screen">Section 4</span>:<span> </span>The output section is where we can see the loss or the cost graph, along with a visualization of how well the network has learned to separate the red and blue dots.</li>
<li><span class="packt_screen">Section 5</span>:<span> </span>This section is the control panel for adjusting the tuning parameters of the network. It has a widget to start, pause, and refresh the training of the network. Next to it, there is a counter indicating the number of epochs elapsed. Then there is <span class="packt_screen">Learning rate</span>, the constant by which the weights are adjusted. That is followed by the choice of activation function to use within the neurons. Finally, there is an option to indicate the kind of problem to visualize, that is classification, or regression. In this example, we are visualizing a classification task.</li>
<li>We will ignore the <span class="packt_screen">Regularization</span> and <span class="packt_screen">Regularization rate</span> for now, as we have not covered these terms in a conceptual manner as of yet. We will visit these terms in later in the book when it is ideal for appreciating its purpose.</li>
</ul>
<p>We are now ready to start fiddling around with TensorFlow Playground. We will start with the first dataset, with the following settings on the tuning parameters:</p>
<ul>
<li><span class="packt_screen">Learning rate</span> = <span class="packt_screen">0.01</span></li>
<li><span class="packt_screen">Activation</span> = <span class="packt_screen">Tanh</span></li>
<li><span class="packt_screen">Regularization</span> = <span class="packt_screen">None</span></li>
<li><span class="packt_screen">Regularization rate</span> = <span class="packt_screen">0</span></li>
<li><span class="packt_screen">Problem type</span> = <span class="packt_screen">Classification</span></li>
<li><span class="packt_screen">DATA</span> = Circle</li>
<li><span class="packt_screen">Ratio of training to test data</span> = <span class="packt_screen">50%</span></li>
<li><span class="packt_screen">Batch size</span> = <span class="packt_screen"><span class="packt_screen">10</span></span></li>
<li><span class="packt_screen">FEATURES</span> = <span class="packt_screen">X<sub>1</sub></span> and <span class="packt_screen">X<sub>2</sub></span></li>
<li><span>Two</span> hidden/dense layers; the first layer with <span class="packt_screen">4 neurons</span>, and the second layer with <span class="packt_screen">2 neurons</span></li>
</ul>
<p>Now start training by clicking the play button on the top-left corner of the dashboard. Moving right from the play/pause button, we can see the number of epochs that have elapsed. At about 200 epochs, pause the training and observe the output section:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-744 image-border" src="assets/ee92aba1-9adb-4172-a92b-0fa2bbd9c4b0.jpg" style="width:50.08em;height:27.75em;"/></p>
<p>The key observations from the dashboard are as follows:</p>
<ul>
<li>We can see the performance graph of the network on the right section of the dashboard. The test and training loss is the cost of the network during testing and training, respectively. As discussed previously, the idea is to minimize cost.</li>
<li>Below that, you will observe that there is a visualization of how the network has separated or classified the blue dots from the orange ones.</li>
<li>If we hover the mouse pointer over any of the neurons, we can see what the neuron has learned to separate the blue and orange dots. Having said this, let's take a closer look at both of the neurons from the second layer to see what they have learned about the task.</li>
<li>When we hover over the first neuron in the second layer, we can see that this neuron has done a good job of learning the task at hand. In comparison, the second neuron in the second layer has learned less about the task.</li>
<li>That brings us to the dotted lines coming out of the neurons: they are the corresponding weights of the neuron. The blue dotted lines indicate positive weights while the orange dotted ones indicate negative weights. They are commonly called<span> </span><strong>tensors.</strong></li>
</ul>
<p>Another key observation is that the first neuron in the second layer has a stronger tensor signal coming out of it compared to the second one. This is indicative of the influence this neuron has in the overall task of separating the blue and orange dots, and it is quite apparent when we see what it has learned compared to the overall end results visual.</p>
<p>Now, keeping in mind all the terms we have learned in this chapter, we can play around by changing the parameters and seeing how this affects the overall network. It is even possible to add new layers and neurons.</p>
<p>TensorFlow Playground is an excellent place to reiterate the fundamentals and essential concepts of ANNs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>So far, we have covered the essential concepts at a high level, enough for us to appreciate the things we are going to be doing practically in this book. Having a conceptual understanding is good enough to get us rolling with building AI models, but it is also handy to have a deeper understanding.</p>
<p>In the next chapter, we will set up our environment for building AI applications and create a small Android and iOS mobile app that can use a model built on Keras and TensorFlow to predict house prices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Here is a list of resources that can be referenced to appreciate and dive deeper into the concepts of AI and deep learning:</p>
<ul>
<li><em>Neural Networks and deep learning</em>, <a href="http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a></li>
<li>Michael Taylor's<span> </span><em>Make Your Own Neural Network: An In-depth Visual Introduction For Beginners</em>,<span> </span><a href="https://www.amazon.in/Machine-Learning-Neural-Networks-depth-ebook/dp/B075882XCP" target="_blank">https://www.amazon.in/Machine-Learning-Neural-Networks-depth-ebook/dp/B075882XCP</a></li>
<li>Tariq Rashid's<span> </span><em>Make Your Own Neural Network</em>, <a href="https://www.amazon.in/Make-Your-Own-Neural-Network-ebook/dp/B01EER4Z4G">https://www.amazon.in/Make-Your-Own-Neural-Network-ebook/dp/B01EER4Z4G</a><a href="https://www.amazon.in/Make-Your-Own-Neural-Network-ebook/dp/B01EER4Z4G"/></li>
<li>Nick Bostrom's<span> </span><em>Superintelligence</em>,<span> </span><a href="https://en.wikipedia.org/wiki/Superintelligence:_Paths,_Dangers,_Strategies">https://en.wikipedia.org/wiki/Superintelligence:_Paths,_Dangers,_Strategies</a></li>
<li>Pedro Domingos's <em>The Master Algorithm</em>, <a href="https://en.wikipedia.org/wiki/The_Master_Algorithm" target="_blank">https://en.wikipedia.org/wiki/The_Master_Algorithm</a></li>
<li><em>Deep Learning Book</em>,<span> </span><a href="http://www.deeplearningbook.org/">http://www.deeplearningbook.org/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>