- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your First AI Model – Beware the Bandits!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll get to grips with your very first AI model! You're going
    to make a model that will solve the very well-known multi-armed bandit problem.
    This is a classic problem in AI, and it's also widely encountered in many real-world
    business problems.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-armed bandit problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are in Las Vegas, in your favorite casino. You are in a room containing
    five slot machines. For each of them the game is the same: you bet a certain amount
    of money, say 1 dollar, you pull the arm, and then the machine will either take
    your money, or give you twice your money back. Remember the rewards we talked
    about in the previous chapter? Let''s say that if the machine takes your money,
    your reward is -1, and if the machine returns you twice your money, your reward
    is +1.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you're already starting to define an AI environment, which I'll
    remind you is absolutely fundamental when solving a problem with AI. So far, the
    AI isn't there, but it will come soon. You always start by defining the environment.
  prefs: []
  type: TYPE_NORMAL
- en: You've defined the rewards; you'll define the states (inputs) and actions (outputs)
    later. Now, still in the process of defining the environment, let's say that you
    know, somehow, that one of these machines has a higher probability of giving you
    a +1 reward than the others when you pull its arm. It doesn't matter how you know
    this info, but it must be part of the problem assumptions. Rest assured, this
    assumption is always naturally verified in the real-world business problems mentioned
    above where the multi-armed bandit problem can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your goal, as in any AI environment, is to obtain the highest accumulated reward
    during your time of play. Let''s say you are going to bet 1,000 dollars in total,
    meaning that you are going to bet 1 dollar, 1,000 times, each time by pulling
    the arm of any of these five slot machines. The question is:'
  prefs: []
  type: TYPE_NORMAL
- en: What should be your strategy, so that after having played 1,000 times, you get
    the maximum amount of money to take home with you?
  prefs: []
  type: TYPE_NORMAL
- en: The first step of your strategy must be to figure out, in the minimum number
    of plays, which of these five slot machines has the highest chance of giving you
    a 1 reward. In other words, you have to quickly figure out the slot machine with
    the highest success rate. Then, as soon as you figure it out, you simply need
    to keep playing on that most successful slot machine.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the most successful slot machine is not hard; one simple strategy could
    be to play 100 times on each of these five slot machines and then, at the end,
    look at which of them gave you more money. Statistically, this gives you a good
    chance of finding that most generous slot machine.
  prefs: []
  type: TYPE_NORMAL
- en: All the challenge is in "quickly". The hardest part is to find the best slot
    machine **in a minimum number of trials**. This is where your first AI model comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: The Thompson Sampling model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You're going to build this model straight away. Right now, you'll build a simple
    implementation of this method, and later you will be shown the theory behind it.
    Let's get right into it!
  prefs: []
  type: TYPE_NORMAL
- en: As we defined previously, our problem is trying to find the best slot machine
    with the highest winning chance out of many. A not-so-optimal solution would be
    to play 100 rounds on each of our slot machines and see which one has the highest
    winning rate. A better solution is a method called Thompson Sampling.
  prefs: []
  type: TYPE_NORMAL
- en: I won't go too deeply into the theory behind it; we'll cover that later. For
    now, it is enough to say that Thompson Sampling uses a distribution function (distributions
    will be explained further in this chapter), called Beta, that takes two arguments.
    For simplicity's sake, let's say that the higher the first argument is, the better
    our slot machine is, and the higher the second argument is, the worse our slot
    machine is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can define this function as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* – a random choice from our Beta distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_002.png) – our Beta function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*a* – the first argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*b* – the second argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry if you don't understand this entirely quite yet; you'll read all
    about it later.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start coding our solution. All this code is also available on the GitHub
    page of this book in the `Chapter 05` folder. Here we go with the first code section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll only need one library, called NumPy. This is a very useful library, helping
    when we are dealing with multi-dimensional arrays and lists in general. Give it
    the abbreviation `np`, which is the industry standard, so that it will be easier
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to understand something very important. You are creating a simulation
    whose aim is to simulate real-life situations. In reality, every slot machine
    gives us some chance of winning, and some machines have it higher than others.
    Therefore, when simulating this environment, you have to do the same thing. It
    is important to remember, however, that our AI will not know these predefined
    winning rates. It cannot just read them and judge, based on these rates, which
    machine is the best.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let's call this list of winning chances `conversionRates`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have five slot machines. They have some win chance; for example, slot
    machine no. 1 offers a 15% chance of a win. Then you create a number of samples,
    `N`. Remember, you are performing a simulation, so you need to have a predefined
    dataset that will tell you whether you won or not when you're playing. You also
    introduce a variable, `d`, which is the length of your conversion rates list;
    that is, the number of slot machines. It's useful to use short variable names
    like that, because the code would be longer and less readable otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have an idea of what you should do next? You are running a simulation,
    so you need to have a predefined set of wins and losses for every slot machine
    for every sample. I highly recommend that you try to do this on your own. You
    need to have a set that will tell you if at some timestep `i` you have won or
    not by playing a certain slot machine. The answer is in the next snippet of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, you create a 2d-array full of zeros, of size `N * d`. This
    means that you've created an array with `N` (in this case `10000`) rows and `d`
    (in this case `5`) columns. Then, in a `for` loop, you iterate through every row
    in that 2d-array `X`. In a nested `for` loop, you iterate through each column
    in that row. In line 5 of the preceding code snippet, for each slot machine (each
    column), we check if a random float number from range (0,1) is smaller than the
    conversion rate for the corresponding slot machine.
  prefs: []
  type: TYPE_NORMAL
- en: That's just like playing the slot machine; since there is an equal chance of
    getting any float number from this range, the chances of getting a number smaller
    than `x` (where `x` is also in range (0,1)) is equal to `x`. For example, for
    `d` = 0.15, there are 15 instances out of 100 of getting a smaller float number
    than 0.15, and thus a 15% chance of returning a high reward for slot machine 1\.
    In other words, if the random float is smaller, then that means you will win if
    you play this certain machine at this certain timestep.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure you understand, if one of the `N` samples from your dataset `X`
    looks like this: `[0, 1, 0, 0, 1]`, you would win at that point in time by playing
    slot machine no. 2 or no. 5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to create two arrays that will count how many times you have
    lost and won by playing each slot machine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Name them `nPosReward` (number of wins) and `nNegReward` (number of losses).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have made a simulation set and these two counters, you can start
    coding some Thompson Sampling. Keep in mind that the theory, as well as another
    example, will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, initialize a `for` loop that will iterate through every sample in our
    dataset and choose the best slot machine. Initially, only create two variables,
    one called `selected`, which will tell you which slot machine was chosen, and
    `maxRandom`, which you will use to get the highest Beta distribution guess across
    all slot machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So now you can get to the core of Thompson Sampling. You'll take random guesses
    from our Beta distribution and find the highest value across all your slot machines.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a method taken from NumPy, called `np.random.beta(a,b)`, that returns
    this random guess. Knowing that, try to find the highest guess and the best machine
    on your own! It is totally fine if you fail—we haven't covered the theory yet—and
    I will provide you with an answer. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you''ve given it a try. Whether it''s worked out for you or not, here''s
    my answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You haven't missed anything—this is all the code needed for this task. You create
    a `for` loop to iterate through every slot machine and find the best one. For
    each slot machine of index `j` (remember that you are still in the bigger `for`
    loop with index `i`), you take a random draw, called `randomBeta`, from our Beta
    distribution, and check if it is greater than `maxRandom`.
  prefs: []
  type: TYPE_NORMAL
- en: If it is, then you reassign `maxRandom` to be equal to `randomBeta`, and set
    `selected` to be equal to the index of this new highest-guess slot machine `j`.
    It is also worth mentioning what the `a` and `b` arguments of the Beta function
    are in this case; they're the number of wins and losses we've had on the specific
    slot machine. Remember, the bigger the first argument, the better, and the higher
    our random guess will be; the bigger the second argument, the worse, and the lower
    our random guess will be.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have selected the best slot machine, what do you think you should
    do next?
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to update your `nPosReward` or `nNegReward` depending on whether you
    have won or not. We can do that with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the use of the `X` array you created earlier. You check if
    you have won this round by checking if there's a `1` in the appropriate place
    in your `X` array. If you win, you update the index corresponding to the selected
    machine in `nPosReward` by adding `1`. If you lose, however, you update `nNegReward`
    by adding `1` in the same index there. You can clearly see that if you win, next
    time, your random guess from the Beta distribution for that machine will be higher;
    and if you lose, it will be lower.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works already, although it is worth adding a few lines of code to
    display which slot machine your code considers the best:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, you simply display how many times each slot machine was chosen by your
    algorithm. To get these numbers you can add together the lists `nPosReward` and
    `nNegReward`. In the final line, you show which machine was chosen the highest
    number of times, making it the slot machine that is considered the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can just run your code and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, your algorithm **quickly** found out that machine no. 1 is the
    best. It did it in around 2,000 rounds (2,000 samples in your `X` set).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thompson Sampling is, by far, the best model for this kind of problem; at the
    end of this chapter, you will see a comparison with another method. Here''s how
    it works its magic. The first thing we do, when finding the best slot machine,
    is obviously to play the arm of each of the five slot machines one by one. So
    here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 1**: We play the arm of slot machine number 1\. Let''s say we get reward
    0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 2**: We play the arm of slot machine number 2\. Let''s say we get reward
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 3**: We play the arm of slot machine number 3\. Let''s say we get reward
    0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 4**: We play the arm of slot machine number 4\. Let''s say we get reward
    0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 5**: We play the arm of slot machine number 5\. Let''s say we get reward
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, why do you think we had to do this? We only did that to collect some starting
    information from each of the slot machines. This information will be needed in
    future rounds.
  prefs: []
  type: TYPE_NORMAL
- en: Now, things start to get interesting. What are we going to do at round 6? Which
    arm are we going to play?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we need to look back at what happened during the first five rounds. For
    each slot machine, we introduce two new variables, one that counts the number
    of times the slot machine returned a 0 reward, and another one that counts the
    number of times the slot machine returned a 1 reward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s denote these variables as ![](img/B14110_05_003.png) and ![](img/B14110_05_004.png),
    where ![](img/B14110_05_005.png) is the number of times slot machine number *i*
    returned reward 0 up to round *n*, and ![](img/B14110_05_006.png) is the number
    of times slot machine number *i* returned reward 1 up to round *n*. These two
    variables are denoted by `nNegReward` and `nPosReward` in our code. So, based
    on what we''ve obtained so far at round 5, let''s give some values examples of
    these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_007.png) means that slot machine 1 has returned 1 loss over
    1 round.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_008.png) means that slot machine 1 has returned 0 wins over
    1 round.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_009.png) means that slot machine 2 has returned 0 losses
    over 1 round.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_010.png) means that slot machine 2 has returned 1 win over
    1 round.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_011.png) means that slot machine 5 has returned 0 losses
    over 4 rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_012.png) means that slot machine 5 has returned 0 wins over
    4 rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_013.png) means that slot machine 5 has returned 0 losses
    over 5 rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_014.png) means that slot machine 5 has returned 1 win over
    5 rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that was the easy part. The good news is that we've created all the
    variables we needed for our AI. The bad news is that now comes the hard part,
    the math. If you think math is good news, I like your spirit; but don't worry
    if you don't like math, I won't let you down.
  prefs: []
  type: TYPE_NORMAL
- en: What is a distribution?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step of our AI journey is to introduce distributions in mathematics.
    For this, I''ll give you a simple definition with my own words, not the very formal
    ones you find in math books. I want to make sure everybody understands. Here it
    is: the distribution of a variable is a function that will give, for each value
    in the possible range of values the variable could take, the probability that
    this variable is equal to that value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s really understand what it is through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding graph, you can see an example of a distribution. Now, remember
    in the definition I gave you, I mentioned two measures: "range of values the variable
    could take", and "probability that this variable is equal to that value". In any
    distribution, on the *x*-axis you have the range of values the variable could
    take, and on the *y*-axis you have the probability that the variable is equal
    to each value.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if this isn't clear yet. To extend our example, let's say that on
    the preceding graph, this variable is the annual salary people have in a specific
    country.
  prefs: []
  type: TYPE_NORMAL
- en: On the *x*-axis, we would have the range of annual salaries from the minimum
    wage to the maximum wage, let's say from 15,000 dollars to 150,000 dollars. And
    on the *y*-axis, we would have the probabilities that a person would have that
    salary.
  prefs: []
  type: TYPE_NORMAL
- en: Now it should make more sense. For the low salaries, the curve is low, meaning
    that the probability that an individual earns a salary of around 15,000 dollars
    is low.
  prefs: []
  type: TYPE_NORMAL
- en: Then, up to the center of the *x*-axis, marked as ![](img/B14110_05_015.png),
    which is the average of the salaries, the probabilities of people's salaries increase.
    Let's say that ![](img/B14110_05_016.png) is equal to 45,000 dollars. We intuitively
    understand that the probability that an individual in a specific country earns
    45,000 dollars per year is the highest, simply because the majority of people
    earn something in the region of 45,000 dollars per year. And that's exactly why
    the distribution in the graph is the highest at this salary.
  prefs: []
  type: TYPE_NORMAL
- en: The higher we go above an annual salary of 45,000 dollars, the fewer people
    we'll find earning such salaries, and therefore the probability of people earning
    such salaries will decrease, until we go beyond an annual salary of 150,000 dollars,
    where very few people earn that much, therefore leading to a close-to-zero probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, that was the distribution explained intuitively. Now, you have to
    know that there are many types of distributions: Gaussian distributions (that
    look like the preceding graph), normal distributions (Gaussian distribution of
    mean 0 and variance 1), Beta distributions, and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the next step: **Beta distributions**. The Beta distribution is at
    the heart of the AI we built to solve our bandit problem. Here are what Beta distributions
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Three Beta distributions'
  prefs: []
  type: TYPE_NORMAL
- en: Let's do some practice to make sure you understand how distributions work. Imagine
    these three distributions correspond to three different countries, and again let's
    say that they are the distributions of salaries in these countries. Which country
    has the highest salaries? Is it the purple one, the green one, or the yellow one?
    The answer is the yellow one, of course! It is in this country that we have positive
    probabilities for the highest salaries (remember, the salaries are on the *x*-axis,
    and the probabilities are on the *y*-axis).
  prefs: []
  type: TYPE_NORMAL
- en: That was just a quick test to make sure you were with me. Now, you don't have
    to remember the exact formula of a Beta distribution, but you do have to know
    that it has two parameters and how they impact the distribution. Don't forget
    that this was already mentioned when we solved the problem in practice, now it
    is explained in much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we denote these two parameters as *a* and *b* again, we can denote the Beta
    distribution with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_0011.png)'
  prefs: []
  type: TYPE_IMG
- en: You might be asking what just happened—Why did ![](img/B14110_05_018.png) appear?
    Don't worry, we will demystify all this. In the formula above, ![](img/B14110_05_019.png)
    is the probability, ![](img/B14110_05_020.png) is a function of ![](img/B14110_05_021.png)
    only, ![](img/B14110_05_022.png) is the salary, and ![](img/B14110_05_023.png)
    are the two parameters present in any Beta distribution. Again, you don't have
    to know the exact definition of the function ![](img/B14110_05_024.png), but just
    keep in mind the shape of its curve as given in the preceding graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what is really important for you to understand now is the role of
    the two parameters ![](img/B14110_05_025.png) and ![](img/B14110_05_026.png).
    Following are the two points that you must know and visualize in your head:'
  prefs: []
  type: TYPE_NORMAL
- en: Given two Beta distributions with the same parameter ![](img/B14110_05_027.png),
    the one having a larger parameter ![](img/B14110_05_028.png) will be shifted more
    to the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given two Beta distributions with the same parameter ![](img/B14110_05_029.png),
    the one having a larger parameter ![](img/B14110_05_030.png) will be shifted more
    to the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! That's enough to have an intuitive understanding of how our AI will
    solve the Bandit problem. In other words, the larger the parameter ![](img/B14110_05_031.png),
    the more it will shift the Beta distribution to the right, and the larger the
    parameter ![](img/B14110_05_032.png), the more it will shift the Beta distribution
    to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s practice this! If I give you the following three Beta distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_033.png)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![](img/B14110_05_034.png)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![](img/B14110_05_035.png)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: Could you tell me which of the three Beta distributions in the following graph
    they would approximately look like?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Three Beta distributions'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the two statements above, ![](img/B14110_05_036.png) is the purple
    one, ![](img/B14110_05_037.png) is the yellow one, and ![](img/B14110_05_038.png)
    is the green one. Congratulations to you if you guessed that right!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you are ready to solve our bandit problem. But let me ask you a question
    first, which might lead you to understand the magic faster than this book:'
  prefs: []
  type: TYPE_NORMAL
- en: If, instead of the salaries in a country, the *x*-axis contained the success
    rates of the machines in the casino, and if each of the three Beta distributions
    represented one particular slot machine, which one would you choose to bet your
    1,000 dollars?
  prefs: []
  type: TYPE_NORMAL
- en: You would choose the yellow one!
  prefs: []
  type: TYPE_NORMAL
- en: Of course! This distribution has positive probabilities for the highest conversion
    rates, since it is the one most shifted to the right.
  prefs: []
  type: TYPE_NORMAL
- en: This was already discussed in the previous code section of this chapter; I told
    you there that the higher the first parameter, the better the slot machine. Indeed,
    the Beta distribution will be shifted more to the right, meaning that this slot
    machine has a higher chance of giving us a win. Additionally, the higher the second
    parameter, the worse the slot machine is and now, the Beta distribution will be
    shifted to the left, meaning that this machine has a lower chance of us winning.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now another question, before we solve our bandit problem. Remembering that
    you have five slot machines to play with, try to answer this question: if the
    five slot machines are associated with the following five Beta distributions of
    success rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_039.png), ![](img/B14110_05_040.png), ![](img/B14110_05_041.png),
    ![](img/B14110_05_042.png), and ![](img/B14110_05_043.png),'
  prefs: []
  type: TYPE_NORMAL
- en: Which one would you pick to bet your 1,000 dollars?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is ![](img/B14110_05_044.png)!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, again! Because it is the one with the largest parameter ![](img/B14110_05_045.png)
    and the lowest parameter ![](img/B14110_05_046.png), therefore the most shifted
    to the right, and hence the one having the positive probabilities for the highest
    conversion rates.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still with me, you are definitely ready to understand the AI magic.
    If not, please read through this section again. In the next section, I will finally
    reveal what happens next after Round 5.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling the MABP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we are going to do from now on before playing each round is to associate
    each slot machine with a specific Beta distribution. At each round *n*, the slot
    machine number *i* (*i*=1,2,3,4,5) will be associated with the following Beta
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_048.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you should recall the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_049.png) is the number of times the slot machine number ![](img/B14110_05_050.png)
    returned a 1 reward up to round ![](img/B14110_05_051.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_052.png) is the number of times the slot machine number ![](img/B14110_05_053.png)
    returned a 0 reward up to round ![](img/B14110_05_054.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember, in the Beta distribution ![](img/B14110_05_055.png), the higher the
    parameter ![](img/B14110_05_056.png), the more that shifts the distribution to
    the right. The higher the parameter ![](img/B14110_05_057.png), the more that
    shifts the distribution to the left. Therefore, since at each round ![](img/B14110_05_058.png)
    and for each slot machine, the parameter ![](img/B14110_05_059.png) is the number
    of times (plus 1) it returned 1 up to round ![](img/B14110_05_060.png), and the
    parameter ![](img/B14110_05_061.png) is the number of times (plus 1) it returned
    0 up to round ![](img/B14110_05_062.png), then that means the following: the more
    the slot machine returns 1 (success), the more its distribution will be shifted
    to the right; and the more the slot machine returns 0 (failure), the more its
    distribution will be shifted to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations if you figured out what ![](img/B14110_05_063.png) and ![](img/B14110_05_064.png)
    should be on your own. We already used them in the practical tutorial above; we
    had two arrays, `nPosReward` and `nNegReward`, that correspond to ![](img/B14110_05_065.png)
    and ![](img/B14110_05_066.png) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand this, try to figure out the strategy before I give you the
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, you are about to see the magic. What we are going to do, before playing
    the arm at each round, is take a random draw from each of the five distributions
    corresponding to the five slot machines. In case you''re not clear what that means,
    I''ll explain. Let me show you again the graph of the three Beta distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Three Beta distributions'
  prefs: []
  type: TYPE_NORMAL
- en: What did I mean by taking a random draw? First, remember that for our bandit
    problem, on the *x*-axis, we have the success rates from 0 to 1\. For example,
    *x* = 0.25 means that the machine returns a 1 reward (success) 25% of the time.
    Then, on the *y*-axis, we still have the probabilities to have these success rates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on one distribution, for example, the purple one. What would it
    mean to take a random draw from that distribution? That would mean very simply
    that we randomly pick a value on the *x*-axis where the distribution is positive,
    such that the *x* values where the probability is the highest will get the highest
    chance to be picked. For example, let's say the top of the purple curve corresponds
    to *x* = 0.2 and *y* = 0.35.
  prefs: []
  type: TYPE_NORMAL
- en: Then, taking a random draw from that purple distribution means that we will
    have a 35% chance to pick a success rate of 20%. To generalize this, let's say
    that ![](img/B14110_05_067.png) is the function associated with the purple distribution,
    so taking a random draw from that purple distribution means that for each success
    rate *x* on the *x*-axis, we will have ![](img/B14110_05_068.png) chance of picking
    *x*. That is what "to take a random draw from a distribution" means, and this
    is also called "to sample a distribution".
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand this, let's see where we left off. We said that before
    playing the arm at each round, we were going to take a random draw from each of
    the five distributions corresponding to the five slot machines. We thus obtain
    five values on the *x*-axis, each one corresponding to each of the five slot machines.
    Then, here comes the crucial question, the one that will tell whether you have
    the right intuition about the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '**According to you, which slot machine are you going to play, based on the
    observation of these five values?** I really want you to take some time to answer
    this question, because right now, we are at the heart of the strategy (you can
    also have a look at our previously written code). The answer can be found in the
    next paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I really hope you tried figuring this out by yourself: the slot machine that
    you are going to play next is the one for which we got the highest of the five
    random draws. Why? Because the highest random draws correspond to the highest
    success rate, and for this highest success rate, the Beta distribution associated
    with the slot machine picked has positive probabilities around that highest success
    rate.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to maximize the success rate of the machines we play (because
    we want to make money), we must pick the slot machine for which the Beta distribution
    has positive probabilities around the highest success rates. In the following
    graph, that's the yellow distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Three Beta distributions'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must take a step back. I've been in your situation many times when I
    am learning something new and technical, which sometimes felt overwhelming. In
    that case, the best move is to take a step back, which is exactly what we are
    going to do now by giving a recap of the strategy and its intuition.
  prefs: []
  type: TYPE_NORMAL
- en: The Thompson Sampling strategy in three steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we play each of the five slot machines over the first five rounds, here''s
    what the AI will do at each round ![](img/B14110_05_069.png):'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each slot machine *i* (*i*=1,2,3,4,5), we take a random draw ![](img/B14110_05_070.png)
    from its Beta distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_071.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'where:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_072.png) is the number of times the slot machine number ![](img/B14110_05_073.png)
    returned a 1 reward up to round ![](img/B14110_05_074.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_075.png) is the number of times the slot machine number ![](img/B14110_05_076.png)
    returned a 0 reward up to round ![](img/B14110_05_062.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We pull the arm of the slot machine ![](img/B14110_05_078.png) that has the
    highest sampled ![](img/B14110_05_079.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_080.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We don''t forget to update ![](img/B14110_05_081.png) or ![](img/B14110_05_082.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the played slot machine ![](img/B14110_05_083.png) returned a 1 reward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_084.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If the played slot machine ![](img/B14110_05_085.png) returned a 0 reward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_086.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Then, we repeat these three steps at each round until we spend our 1,000 dollars.
    This strategy, called Thompson Sampling, is a basic but powerful model of a specific
    branch of AI, called Reinforcement Learning.
  prefs: []
  type: TYPE_NORMAL
- en: The final touch of shaping your Thompson Sampling intuition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your intuition about why and how this works should be as follows (try to keep
    it in mind or visualize it on the graphic):'
  prefs: []
  type: TYPE_NORMAL
- en: Each slot machine has its own Beta distribution. Over the rounds, the Beta distribution
    of the slot machine with the highest conversion rate will be progressively shifted
    to the right, and the Beta distributions of the strategies with lower conversion
    rates will be progressively shifted to the left (Steps 1 and 3). Therefore, because
    of Step 2, the slot machine with the highest conversion rate will be selected
    more and more.
  prefs: []
  type: TYPE_NORMAL
- en: And voilà! Congratulations—you just learned about a powerful AI model, a massive
    step in your journey. To see Thompson Sampling in action and check that it indeed
    works, I won't force you to go to a casino and try it out; We'll apply it to another
    real-life model in *Chapter 6*, *AI for Sales and Advertising – Sell like the
    Wolf of AI Street*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let me finish this theory tutorial with a question for you. Remember
    earlier in the book I told you that any AI we build today takes as input a state,
    returns as output an action to play, and, after playing the action, gets a reward
    (positive or negative). **For this particular bandit problem, what are the input
    states, the actions played, and the rewards received?** Think about this before
    reading the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we go with the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: The input state is the exact round we've reached, including the information
    of the two parameters ![](img/B14110_05_087.png) and ![](img/B14110_05_088.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output action is the arm we pull from the selected slot machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reward is 1 or 0, 1 if the slot machine returns twice our dollar invested,
    and 0 if we lose our dollar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations to you if you answered that one correctly, and for tackling
    this first AI model, Thompson Sampling. And don't forget, in *Chapter 6*, *AI
    for Sales and Advertising – Sell like the Wolf of AI Street*, we put this into
    practice to solve a real-world business problem.
  prefs: []
  type: TYPE_NORMAL
- en: Thompson Sampling against the standard model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When I learned Thompson Sampling for the first time, I had one main question
    in my mind: is it really that good? In fact, if you were to run the standard model
    (by "standard model" I mean playing every slot machine a certain number of times)
    and Thompson Sampling separately you might not see much difference; you would
    likely come to the conclusion that they work pretty much as well as each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether it is true that Thompson Sampling isn''t any better, I implemented
    a code to test both solutions on many different scenarios. The changes included:
    number of samples (200 or 1,000 or 5,000), number of slot machines (from 3 to
    20), and conversion rate ranges (ranges in which conversion rates could be set:
    0-0.1; 0-0.3; 0-0.5).'
  prefs: []
  type: TYPE_NORMAL
- en: Every scenario was tested 100 times to compute the accuracy of each model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results and the code used are provided in the `resultsModified.xlsx` and
    `comparison.py` files, respectively, in `Chapter 05` of this book''s GitHub page.
    Here, you can see some graphs taken from this Excel file that show the performance
    of both models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Accuracy vs. Number of slot machines (200 samples)'
  prefs: []
  type: TYPE_NORMAL
- en: This first graph in *Figure 6* illustrates the accuracy of both models depending
    on the number of slot machines. The number of samples was set to 200 and the conversion
    rate ranges were set to 0-0.1, meaning that the differences between these rates
    were minor. This is the toughest setting for this comparison. Overall, Thompson
    Sampling performed better than the standard model (22% better).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Accuracy vs. Number of slot machines (5,000 samples)'
  prefs: []
  type: TYPE_NORMAL
- en: This second graph in *Figure 7* shows the performance under the easiest conditions.
    The number of samples was set to 5,000 and the conversion rate ranges were set
    to 0-0.5, meaning that the differences were clearly visible. The overall drop
    of accuracy for Thompson Sampling is smaller than the drop in accuracy for the
    standard solution. Thompson Sampling performed significantly better this time
    (41% better).
  prefs: []
  type: TYPE_NORMAL
- en: Taking all scenarios into consideration, Thompson Sampling achieved a mean accuracy
    of 57% and the standard model achieved 43% accuracy. This is a significant difference
    taking into account the fact that very tough scenarios were tested (for example,
    only 200 samples, a range of 0-0.1, and 20 slot machines).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thompson Sampling is a powerful sampling technique that enables you to quickly
    figure out the highest of a number of unknown conversion rates. It is always applied
    in the same frame, called the multi-armed bandit problem, which in the classic
    sense is composed of several slot machines, each one having a different conversion
    rate of positive outcomes. We had a first glance at how this AI solves this problem
    better and faster than standard methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will perform a full practical activity where we will
    see how the multi-armed bandit frame can easily model a business problem—online
    advertising—and how Thompson Sampling can bring significant added value.
  prefs: []
  type: TYPE_NORMAL
