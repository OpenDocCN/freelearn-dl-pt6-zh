- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your First AI Model – Beware the Bandits!
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll get to grips with your very first AI model! You're going
    to make a model that will solve the very well-known multi-armed bandit problem.
    This is a classic problem in AI, and it's also widely encountered in many real-world
    business problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The multi-armed bandit problem
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are in Las Vegas, in your favorite casino. You are in a room containing
    five slot machines. For each of them the game is the same: you bet a certain amount
    of money, say 1 dollar, you pull the arm, and then the machine will either take
    your money, or give you twice your money back. Remember the rewards we talked
    about in the previous chapter? Let''s say that if the machine takes your money,
    your reward is -1, and if the machine returns you twice your money, your reward
    is +1.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you're already starting to define an AI environment, which I'll
    remind you is absolutely fundamental when solving a problem with AI. So far, the
    AI isn't there, but it will come soon. You always start by defining the environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: You've defined the rewards; you'll define the states (inputs) and actions (outputs)
    later. Now, still in the process of defining the environment, let's say that you
    know, somehow, that one of these machines has a higher probability of giving you
    a +1 reward than the others when you pull its arm. It doesn't matter how you know
    this info, but it must be part of the problem assumptions. Rest assured, this
    assumption is always naturally verified in the real-world business problems mentioned
    above where the multi-armed bandit problem can be applied.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Your goal, as in any AI environment, is to obtain the highest accumulated reward
    during your time of play. Let''s say you are going to bet 1,000 dollars in total,
    meaning that you are going to bet 1 dollar, 1,000 times, each time by pulling
    the arm of any of these five slot machines. The question is:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: What should be your strategy, so that after having played 1,000 times, you get
    the maximum amount of money to take home with you?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The first step of your strategy must be to figure out, in the minimum number
    of plays, which of these five slot machines has the highest chance of giving you
    a 1 reward. In other words, you have to quickly figure out the slot machine with
    the highest success rate. Then, as soon as you figure it out, you simply need
    to keep playing on that most successful slot machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Finding the most successful slot machine is not hard; one simple strategy could
    be to play 100 times on each of these five slot machines and then, at the end,
    look at which of them gave you more money. Statistically, this gives you a good
    chance of finding that most generous slot machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: All the challenge is in "quickly". The hardest part is to find the best slot
    machine **in a minimum number of trials**. This is where your first AI model comes
    into play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Thompson Sampling model
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You're going to build this model straight away. Right now, you'll build a simple
    implementation of this method, and later you will be shown the theory behind it.
    Let's get right into it!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将立即构建这个模型。现在，你将实现这个方法的一个简单版本，之后会展示其背后的理论。我们开始吧！
- en: As we defined previously, our problem is trying to find the best slot machine
    with the highest winning chance out of many. A not-so-optimal solution would be
    to play 100 rounds on each of our slot machines and see which one has the highest
    winning rate. A better solution is a method called Thompson Sampling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前定义的，我们的问题是要从多个老虎机中找到中奖概率最高的那个。一个不太理想的解决方案是对每台老虎机玩100轮，看看哪台的中奖率最高。一个更好的解决方案是使用一种叫做汤普森采样（Thompson
    Sampling）的方法。
- en: I won't go too deeply into the theory behind it; we'll cover that later. For
    now, it is enough to say that Thompson Sampling uses a distribution function (distributions
    will be explained further in this chapter), called Beta, that takes two arguments.
    For simplicity's sake, let's say that the higher the first argument is, the better
    our slot machine is, and the higher the second argument is, the worse our slot
    machine is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讲解其背后的理论，稍后我们会讨论。现在，只需要知道，汤普森采样（Thompson Sampling）使用一个分布函数（分布的相关内容将在本章中进一步解释），这个函数叫做Beta，它接受两个参数。为了简化，我们可以假设，第一个参数越大，我们的老虎机就越好；第二个参数越大，我们的老虎机就越差。
- en: 'Therefore, we can define this function as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将这个函数定义为：
- en: '![](img/B14110_05_001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_05_001.png)'
- en: 'where:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*x* – a random choice from our Beta distribution'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* – 从我们的Beta分布中随机选择的一个值'
- en: '![](img/B14110_05_002.png) – our Beta function'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_05_002.png) – 我们的Beta函数'
- en: '*a* – the first argument'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a* – 第一个参数'
- en: '*b* – the second argument'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*b* – 第二个参数'
- en: Don't worry if you don't understand this entirely quite yet; you'll read all
    about it later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不完全理解这些内容，别担心；你之后会读到相关内容。
- en: Coding the model
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模型
- en: 'Let''s start coding our solution. All this code is also available on the GitHub
    page of this book in the `Chapter 05` folder. Here we go with the first code section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写解决方案的代码。所有这些代码也可以在本书的GitHub页面的`Chapter 05`文件夹中找到。我们从第一段代码开始：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll only need one library, called NumPy. This is a very useful library, helping
    when we are dealing with multi-dimensional arrays and lists in general. Give it
    the abbreviation `np`, which is the industry standard, so that it will be easier
    to use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要一个库，叫做NumPy。这个库非常有用，尤其是在处理多维数组和列表时。将它简写为`np`，这是行业标准，这样使用起来会更方便。
- en: Now we have to understand something very important. You are creating a simulation
    whose aim is to simulate real-life situations. In reality, every slot machine
    gives us some chance of winning, and some machines have it higher than others.
    Therefore, when simulating this environment, you have to do the same thing. It
    is important to remember, however, that our AI will not know these predefined
    winning rates. It cannot just read them and judge, based on these rates, which
    machine is the best.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须理解一个非常重要的概念。你正在创建一个模拟，其目的是模拟现实生活中的情况。在现实中，每台老虎机都有一定的中奖概率，并且有些机器的中奖概率高于其他机器。因此，在模拟这个环境时，你也需要做同样的事情。然而，需要记住的是，我们的AI并不知道这些预定义的中奖概率。它不能直接读取这些概率，并基于这些概率判断哪个机器是最好的。
- en: For this example, let's call this list of winning chances `conversionRates`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将这个中奖机会的列表称为`conversionRates`。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you have five slot machines. They have some win chance; for example, slot
    machine no. 1 offers a 15% chance of a win. Then you create a number of samples,
    `N`. Remember, you are performing a simulation, so you need to have a predefined
    dataset that will tell you whether you won or not when you're playing. You also
    introduce a variable, `d`, which is the length of your conversion rates list;
    that is, the number of slot machines. It's useful to use short variable names
    like that, because the code would be longer and less readable otherwise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有五台老虎机。它们每台有不同的中奖概率；例如，老虎机编号1的中奖概率是15%。接着你创建一个样本数量`N`。记住，你是在做模拟，所以你需要一个预定义的数据集，告诉你在游戏时是否获胜。你还引入了一个变量`d`，表示你的中奖率列表的长度，也就是老虎机的数量。使用这样的简短变量名非常有用，因为如果不这样做，代码会更长，且不易阅读。
- en: Do you have an idea of what you should do next? You are running a simulation,
    so you need to have a predefined set of wins and losses for every slot machine
    for every sample. I highly recommend that you try to do this on your own. You
    need to have a set that will tell you if at some timestep `i` you have won or
    not by playing a certain slot machine. The answer is in the next snippet of code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道接下来该怎么做了吗？你正在运行一个模拟，因此需要为每个样本的每个老虎机预定义一个胜负结果。我强烈建议你自己先尝试做这一步。你需要有一个集合，告诉你在某个时刻`i`，通过玩某个老虎机你是否获胜。答案在下一个代码片段中。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first line, you create a 2d-array full of zeros, of size `N * d`. This
    means that you've created an array with `N` (in this case `10000`) rows and `d`
    (in this case `5`) columns. Then, in a `for` loop, you iterate through every row
    in that 2d-array `X`. In a nested `for` loop, you iterate through each column
    in that row. In line 5 of the preceding code snippet, for each slot machine (each
    column), we check if a random float number from range (0,1) is smaller than the
    conversion rate for the corresponding slot machine.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你创建了一个充满零的二维数组，大小为`N * d`。这意味着你创建了一个`N`（在这个例子中为`10000`）行和`d`（在这个例子中为`5`）列的数组。然后，在一个`for`循环中，你遍历了这个二维数组`X`中的每一行。在一个嵌套的`for`循环中，你遍历了该行中的每一列。在前面代码片段的第5行，对于每个老虎机（每一列），我们检查从范围(0,1)中得到的随机浮动数是否小于相应老虎机的转换率。
- en: That's just like playing the slot machine; since there is an equal chance of
    getting any float number from this range, the chances of getting a number smaller
    than `x` (where `x` is also in range (0,1)) is equal to `x`. For example, for
    `d` = 0.15, there are 15 instances out of 100 of getting a smaller float number
    than 0.15, and thus a 15% chance of returning a high reward for slot machine 1\.
    In other words, if the random float is smaller, then that means you will win if
    you play this certain machine at this certain timestep.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是在玩老虎机；由于从这个范围中得到任何浮动数的机会是均等的，得到一个小于`x`的数字的机会（其中`x`也在区间(0,1)内）等于`x`。例如，当`d`
    = 0.15时，在100次中有15次会得到一个小于0.15的浮动数，因此老虎机1的高奖励概率是15%。换句话说，如果随机浮动数较小，那么意味着你在某个时刻玩这个特定的机器时会赢。
- en: 'To make sure you understand, if one of the `N` samples from your dataset `X`
    looks like this: `[0, 1, 0, 0, 1]`, you would win at that point in time by playing
    slot machine no. 2 or no. 5.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解，如果你的数据集`X`中的`N`个样本之一看起来像这样：`[0, 1, 0, 0, 1]`，那么在这个时刻，通过玩老虎机编号2或5你会赢。
- en: 'Next, you need to create two arrays that will count how many times you have
    lost and won by playing each slot machine, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建两个数组，用来记录你玩每个老虎机时获胜和失败的次数，像这样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Name them `nPosReward` (number of wins) and `nNegReward` (number of losses).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们命名为`nPosReward`（获胜次数）和`nNegReward`（失败次数）。
- en: Now that you have made a simulation set and these two counters, you can start
    coding some Thompson Sampling. Keep in mind that the theory, as well as another
    example, will be covered later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了一个模拟集合和这两个计数器，你可以开始编写一些Thompson Sampling代码了。请记住，理论和另一个示例稍后会讲解。
- en: 'Next, initialize a `for` loop that will iterate through every sample in our
    dataset and choose the best slot machine. Initially, only create two variables,
    one called `selected`, which will tell you which slot machine was chosen, and
    `maxRandom`, which you will use to get the highest Beta distribution guess across
    all slot machines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化一个`for`循环，遍历数据集中的每个样本并选择最佳老虎机。最初，只需要创建两个变量，一个叫`selected`，它会告诉你选择了哪个老虎机，另一个叫`maxRandom`，你将用它来获得所有老虎机中最高的Beta分布猜测：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So now you can get to the core of Thompson Sampling. You'll take random guesses
    from our Beta distribution and find the highest value across all your slot machines.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以理解Thompson Sampling的核心了。你将从我们的Beta分布中随机猜测，并找出所有老虎机中的最高值。
- en: You can use a method taken from NumPy, called `np.random.beta(a,b)`, that returns
    this random guess. Knowing that, try to find the highest guess and the best machine
    on your own! It is totally fine if you fail—we haven't covered the theory yet—and
    I will provide you with an answer. Good luck!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用NumPy中的方法`np.random.beta(a,b)`来返回这个随机猜测。知道这一点后，试着自己找出最高的猜测和最好的机器吧！即使失败也完全没关系——我们还没讲到理论——我会给你一个答案的。祝你好运！
- en: 'I hope you''ve given it a try. Whether it''s worked out for you or not, here''s
    my answer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经试过了。不管是否成功，这里是我的答案：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You haven't missed anything—this is all the code needed for this task. You create
    a `for` loop to iterate through every slot machine and find the best one. For
    each slot machine of index `j` (remember that you are still in the bigger `for`
    loop with index `i`), you take a random draw, called `randomBeta`, from our Beta
    distribution, and check if it is greater than `maxRandom`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有漏掉任何内容—这就是完成该任务所需的所有代码。你创建了一个`for`循环来遍历每个老虎机并找出最好的一个。对于每个老虎机索引`j`（记住你依然在大的`for`循环中，索引为`i`），你从我们的Beta分布中进行一次随机抽样，叫做`randomBeta`，并检查它是否大于`maxRandom`。
- en: If it is, then you reassign `maxRandom` to be equal to `randomBeta`, and set
    `selected` to be equal to the index of this new highest-guess slot machine `j`.
    It is also worth mentioning what the `a` and `b` arguments of the Beta function
    are in this case; they're the number of wins and losses we've had on the specific
    slot machine. Remember, the bigger the first argument, the better, and the higher
    our random guess will be; the bigger the second argument, the worse, and the lower
    our random guess will be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是的话，那么你将重新分配`maxRandom`的值为`randomBeta`，并将`selected`设置为这个新的最大猜测老虎机`j`的索引。还值得提一下的是，Beta函数的`a`和`b`参数在此处的含义；它们是我们在特定老虎机上获得的胜利和失败次数。记住，第一个参数越大越好，我们的随机猜测也会越高；第二个参数越大越糟，我们的随机猜测也会越低。
- en: Now that you have selected the best slot machine, what do you think you should
    do next?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经选择了最好的老虎机，接下来你认为应该做什么？
- en: 'You have to update your `nPosReward` or `nNegReward` depending on whether you
    have won or not. We can do that with this code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据是否获胜来更新`nPosReward`或`nNegReward`。我们可以通过以下代码来实现：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see the use of the `X` array you created earlier. You check if
    you have won this round by checking if there's a `1` in the appropriate place
    in your `X` array. If you win, you update the index corresponding to the selected
    machine in `nPosReward` by adding `1`. If you lose, however, you update `nNegReward`
    by adding `1` in the same index there. You can clearly see that if you win, next
    time, your random guess from the Beta distribution for that machine will be higher;
    and if you lose, it will be lower.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到你之前创建的`X`数组的使用。你通过检查`X`数组中相应位置是否为`1`来判断是否赢得了这一轮。如果赢了，你就通过在`nPosReward`中相应的索引加`1`来更新该机器的奖励。如果输了，你则在`nNegReward`中同样的位置加`1`。你可以清楚地看到，如果你赢了，下一次你从Beta分布中抽到的该机器的随机猜测值会更高；如果你输了，随机猜测值则会更低。
- en: 'This code works already, although it is worth adding a few lines of code to
    display which slot machine your code considers the best:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码已经能正常工作，虽然值得添加几行代码来展示你的代码认为哪个老虎机是最好的：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, you simply display how many times each slot machine was chosen by your
    algorithm. To get these numbers you can add together the lists `nPosReward` and
    `nNegReward`. In the final line, you show which machine was chosen the highest
    number of times, making it the slot machine that is considered the best.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需展示你的算法选择了多少次每个老虎机。为了得到这些数字，你可以将`nPosReward`和`nNegReward`的列表相加。在最后一行，你展示了选择次数最多的老虎机，从而确定其为被认为最好的老虎机。
- en: 'Now, you can just run your code and see the results:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以直接运行代码并查看结果：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, your algorithm **quickly** found out that machine no. 1 is the
    best. It did it in around 2,000 rounds (2,000 samples in your `X` set).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，你的算法**快速**找到了1号机器是最好的。它在大约2000轮（2000个样本）后找到了答案。
- en: Understanding the model
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解模型
- en: 'Thompson Sampling is, by far, the best model for this kind of problem; at the
    end of this chapter, you will see a comparison with another method. Here''s how
    it works its magic. The first thing we do, when finding the best slot machine,
    is obviously to play the arm of each of the five slot machines one by one. So
    here we go:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Thompson Sampling是目前为止解决这种问题的最佳模型；在本章的结尾，你将看到与另一种方法的对比。它的魔力是这样运作的。首先，我们做的事情显然是依次玩每个老虎机的转盘。我们开始吧：
- en: '**Round 1**: We play the arm of slot machine number 1\. Let''s say we get reward
    0.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1轮**：我们玩的是老虎机1号的转盘。假设我们获得了奖励0。'
- en: '**Round 2**: We play the arm of slot machine number 2\. Let''s say we get reward
    1.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2轮**：我们玩的是老虎机2号的转盘。假设我们获得了奖励1。'
- en: '**Round 3**: We play the arm of slot machine number 3\. Let''s say we get reward
    0.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3轮**：我们玩的是老虎机3号的转盘。假设我们获得了奖励0。'
- en: '**Round 4**: We play the arm of slot machine number 4\. Let''s say we get reward
    0.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4轮**：我们玩的是老虎机4号的转盘。假设我们获得了奖励0。'
- en: '**Round 5**: We play the arm of slot machine number 5\. Let''s say we get reward
    1.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now, why do you think we had to do this? We only did that to collect some starting
    information from each of the slot machines. This information will be needed in
    future rounds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now, things start to get interesting. What are we going to do at round 6? Which
    arm are we going to play?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Well, we need to look back at what happened during the first five rounds. For
    each slot machine, we introduce two new variables, one that counts the number
    of times the slot machine returned a 0 reward, and another one that counts the
    number of times the slot machine returned a 1 reward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s denote these variables as ![](img/B14110_05_003.png) and ![](img/B14110_05_004.png),
    where ![](img/B14110_05_005.png) is the number of times slot machine number *i*
    returned reward 0 up to round *n*, and ![](img/B14110_05_006.png) is the number
    of times slot machine number *i* returned reward 1 up to round *n*. These two
    variables are denoted by `nNegReward` and `nPosReward` in our code. So, based
    on what we''ve obtained so far at round 5, let''s give some values examples of
    these variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_007.png) means that slot machine 1 has returned 1 loss over
    1 round.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_008.png) means that slot machine 1 has returned 0 wins over
    1 round.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_009.png) means that slot machine 2 has returned 0 losses
    over 1 round.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_010.png) means that slot machine 2 has returned 1 win over
    1 round.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_011.png) means that slot machine 5 has returned 0 losses
    over 4 rounds.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_012.png) means that slot machine 5 has returned 0 wins over
    4 rounds.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_013.png) means that slot machine 5 has returned 0 losses
    over 5 rounds.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_014.png) means that slot machine 5 has returned 1 win over
    5 rounds.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that was the easy part. The good news is that we've created all the
    variables we needed for our AI. The bad news is that now comes the hard part,
    the math. If you think math is good news, I like your spirit; but don't worry
    if you don't like math, I won't let you down.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: What is a distribution?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step of our AI journey is to introduce distributions in mathematics.
    For this, I''ll give you a simple definition with my own words, not the very formal
    ones you find in math books. I want to make sure everybody understands. Here it
    is: the distribution of a variable is a function that will give, for each value
    in the possible range of values the variable could take, the probability that
    this variable is equal to that value.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s really understand what it is through an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_01.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The normal distribution'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding graph, you can see an example of a distribution. Now, remember
    in the definition I gave you, I mentioned two measures: "range of values the variable
    could take", and "probability that this variable is equal to that value". In any
    distribution, on the *x*-axis you have the range of values the variable could
    take, and on the *y*-axis you have the probability that the variable is equal
    to each value.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if this isn't clear yet. To extend our example, let's say that on
    the preceding graph, this variable is the annual salary people have in a specific
    country.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: On the *x*-axis, we would have the range of annual salaries from the minimum
    wage to the maximum wage, let's say from 15,000 dollars to 150,000 dollars. And
    on the *y*-axis, we would have the probabilities that a person would have that
    salary.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Now it should make more sense. For the low salaries, the curve is low, meaning
    that the probability that an individual earns a salary of around 15,000 dollars
    is low.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Then, up to the center of the *x*-axis, marked as ![](img/B14110_05_015.png),
    which is the average of the salaries, the probabilities of people's salaries increase.
    Let's say that ![](img/B14110_05_016.png) is equal to 45,000 dollars. We intuitively
    understand that the probability that an individual in a specific country earns
    45,000 dollars per year is the highest, simply because the majority of people
    earn something in the region of 45,000 dollars per year. And that's exactly why
    the distribution in the graph is the highest at this salary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The higher we go above an annual salary of 45,000 dollars, the fewer people
    we'll find earning such salaries, and therefore the probability of people earning
    such salaries will decrease, until we go beyond an annual salary of 150,000 dollars,
    where very few people earn that much, therefore leading to a close-to-zero probability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, that was the distribution explained intuitively. Now, you have to
    know that there are many types of distributions: Gaussian distributions (that
    look like the preceding graph), normal distributions (Gaussian distribution of
    mean 0 and variance 1), Beta distributions, and many more.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the next step: **Beta distributions**. The Beta distribution is at
    the heart of the AI we built to solve our bandit problem. Here are what Beta distributions
    look like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Three Beta distributions'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Let's do some practice to make sure you understand how distributions work. Imagine
    these three distributions correspond to three different countries, and again let's
    say that they are the distributions of salaries in these countries. Which country
    has the highest salaries? Is it the purple one, the green one, or the yellow one?
    The answer is the yellow one, of course! It is in this country that we have positive
    probabilities for the highest salaries (remember, the salaries are on the *x*-axis,
    and the probabilities are on the *y*-axis).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: That was just a quick test to make sure you were with me. Now, you don't have
    to remember the exact formula of a Beta distribution, but you do have to know
    that it has two parameters and how they impact the distribution. Don't forget
    that this was already mentioned when we solved the problem in practice, now it
    is explained in much more detail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'If we denote these two parameters as *a* and *b* again, we can denote the Beta
    distribution with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_0011.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: You might be asking what just happened—Why did ![](img/B14110_05_018.png) appear?
    Don't worry, we will demystify all this. In the formula above, ![](img/B14110_05_019.png)
    is the probability, ![](img/B14110_05_020.png) is a function of ![](img/B14110_05_021.png)
    only, ![](img/B14110_05_022.png) is the salary, and ![](img/B14110_05_023.png)
    are the two parameters present in any Beta distribution. Again, you don't have
    to know the exact definition of the function ![](img/B14110_05_024.png), but just
    keep in mind the shape of its curve as given in the preceding graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what is really important for you to understand now is the role of
    the two parameters ![](img/B14110_05_025.png) and ![](img/B14110_05_026.png).
    Following are the two points that you must know and visualize in your head:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Given two Beta distributions with the same parameter ![](img/B14110_05_027.png),
    the one having a larger parameter ![](img/B14110_05_028.png) will be shifted more
    to the right.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given two Beta distributions with the same parameter ![](img/B14110_05_029.png),
    the one having a larger parameter ![](img/B14110_05_030.png) will be shifted more
    to the left.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! That's enough to have an intuitive understanding of how our AI will
    solve the Bandit problem. In other words, the larger the parameter ![](img/B14110_05_031.png),
    the more it will shift the Beta distribution to the right, and the larger the
    parameter ![](img/B14110_05_032.png), the more it will shift the Beta distribution
    to the left.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s practice this! If I give you the following three Beta distributions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_033.png)'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![](img/B14110_05_034.png)'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![](img/B14110_05_035.png)'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: Could you tell me which of the three Beta distributions in the following graph
    they would approximately look like?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Three Beta distributions'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Based on the two statements above, ![](img/B14110_05_036.png) is the purple
    one, ![](img/B14110_05_037.png) is the yellow one, and ![](img/B14110_05_038.png)
    is the green one. Congratulations to you if you guessed that right!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you are ready to solve our bandit problem. But let me ask you a question
    first, which might lead you to understand the magic faster than this book:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: If, instead of the salaries in a country, the *x*-axis contained the success
    rates of the machines in the casino, and if each of the three Beta distributions
    represented one particular slot machine, which one would you choose to bet your
    1,000 dollars?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: You would choose the yellow one!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Of course! This distribution has positive probabilities for the highest conversion
    rates, since it is the one most shifted to the right.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！这个分布具有最高转化率的正概率，因为它是最偏右的那个。
- en: This was already discussed in the previous code section of this chapter; I told
    you there that the higher the first parameter, the better the slot machine. Indeed,
    the Beta distribution will be shifted more to the right, meaning that this slot
    machine has a higher chance of giving us a win. Additionally, the higher the second
    parameter, the worse the slot machine is and now, the Beta distribution will be
    shifted to the left, meaning that this machine has a lower chance of us winning.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在本章之前的代码部分已经讨论过；我在那里告诉你，参数越大的老虎机越好。事实上，Beta分布会更多地偏向右侧，意味着这个老虎机更有可能给我们带来胜利。而第二个参数越大，老虎机就越差，现在，Beta分布会偏向左侧，意味着这个机器给我们带来胜利的机会更小。
- en: 'And now another question, before we solve our bandit problem. Remembering that
    you have five slot machines to play with, try to answer this question: if the
    five slot machines are associated with the following five Beta distributions of
    success rates:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有另一个问题，在解决我们的赌博机问题之前。记住你有五个老虎机可以玩，试着回答这个问题：如果这五个老虎机与以下五个成功率的Beta分布相关联：
- en: '![](img/B14110_05_039.png), ![](img/B14110_05_040.png), ![](img/B14110_05_041.png),
    ![](img/B14110_05_042.png), and ![](img/B14110_05_043.png),'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B14110_05_039.png)、![](img/B14110_05_040.png)、![](img/B14110_05_041.png)、![](img/B14110_05_042.png)
    和 ![](img/B14110_05_043.png)，'
- en: Which one would you pick to bet your 1,000 dollars?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会选择哪一个来下注1,000美元？
- en: The answer is ![](img/B14110_05_044.png)!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 ![](img/B14110_05_044.png)!
- en: Of course, again! Because it is the one with the largest parameter ![](img/B14110_05_045.png)
    and the lowest parameter ![](img/B14110_05_046.png), therefore the most shifted
    to the right, and hence the one having the positive probabilities for the highest
    conversion rates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还是那个！因为它的参数 ![](img/B14110_05_045.png) 最大，且参数 ![](img/B14110_05_046.png)
    最小，所以它最偏向右侧，因此具有最高转化率的正概率。
- en: If you are still with me, you are definitely ready to understand the AI magic.
    If not, please read through this section again. In the next section, I will finally
    reveal what happens next after Round 5.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在跟着我走，那么你绝对准备好理解AI的魔力了。如果没有，请再阅读这一部分。在下一部分，我将最终揭示第5轮之后会发生什么。
- en: Tackling the MABP
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决MABP问题
- en: 'What we are going to do from now on before playing each round is to associate
    each slot machine with a specific Beta distribution. At each round *n*, the slot
    machine number *i* (*i*=1,2,3,4,5) will be associated with the following Beta
    distribution:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在每轮游戏之前，我们将为每个老虎机分配一个特定的Beta分布。在每轮 *n* 中，老虎机编号 *i* (*i*=1,2,3,4,5) 将与以下Beta分布关联：
- en: '![](img/B14110_05_048.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_05_048.png)'
- en: 'Here, you should recall the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该回想以下内容：
- en: '![](img/B14110_05_049.png) is the number of times the slot machine number ![](img/B14110_05_050.png)
    returned a 1 reward up to round ![](img/B14110_05_051.png).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_05_049.png) 是老虎机编号 ![](img/B14110_05_050.png) 在第 ![](img/B14110_05_051.png)
    轮之前返回1奖励的次数。'
- en: '![](img/B14110_05_052.png) is the number of times the slot machine number ![](img/B14110_05_053.png)
    returned a 0 reward up to round ![](img/B14110_05_054.png).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_05_052.png) 是老虎机编号 ![](img/B14110_05_053.png) 在第 ![](img/B14110_05_054.png)
    轮之前返回0奖励的次数。'
- en: 'Remember, in the Beta distribution ![](img/B14110_05_055.png), the higher the
    parameter ![](img/B14110_05_056.png), the more that shifts the distribution to
    the right. The higher the parameter ![](img/B14110_05_057.png), the more that
    shifts the distribution to the left. Therefore, since at each round ![](img/B14110_05_058.png)
    and for each slot machine, the parameter ![](img/B14110_05_059.png) is the number
    of times (plus 1) it returned 1 up to round ![](img/B14110_05_060.png), and the
    parameter ![](img/B14110_05_061.png) is the number of times (plus 1) it returned
    0 up to round ![](img/B14110_05_062.png), then that means the following: the more
    the slot machine returns 1 (success), the more its distribution will be shifted
    to the right; and the more the slot machine returns 0 (failure), the more its
    distribution will be shifted to the left.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations if you figured out what ![](img/B14110_05_063.png) and ![](img/B14110_05_064.png)
    should be on your own. We already used them in the practical tutorial above; we
    had two arrays, `nPosReward` and `nNegReward`, that correspond to ![](img/B14110_05_065.png)
    and ![](img/B14110_05_066.png) respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand this, try to figure out the strategy before I give you the
    solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, you are about to see the magic. What we are going to do, before playing
    the arm at each round, is take a random draw from each of the five distributions
    corresponding to the five slot machines. In case you''re not clear what that means,
    I''ll explain. Let me show you again the graph of the three Beta distributions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_04.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Three Beta distributions'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: What did I mean by taking a random draw? First, remember that for our bandit
    problem, on the *x*-axis, we have the success rates from 0 to 1\. For example,
    *x* = 0.25 means that the machine returns a 1 reward (success) 25% of the time.
    Then, on the *y*-axis, we still have the probabilities to have these success rates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on one distribution, for example, the purple one. What would it
    mean to take a random draw from that distribution? That would mean very simply
    that we randomly pick a value on the *x*-axis where the distribution is positive,
    such that the *x* values where the probability is the highest will get the highest
    chance to be picked. For example, let's say the top of the purple curve corresponds
    to *x* = 0.2 and *y* = 0.35.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Then, taking a random draw from that purple distribution means that we will
    have a 35% chance to pick a success rate of 20%. To generalize this, let's say
    that ![](img/B14110_05_067.png) is the function associated with the purple distribution,
    so taking a random draw from that purple distribution means that for each success
    rate *x* on the *x*-axis, we will have ![](img/B14110_05_068.png) chance of picking
    *x*. That is what "to take a random draw from a distribution" means, and this
    is also called "to sample a distribution".
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand this, let's see where we left off. We said that before
    playing the arm at each round, we were going to take a random draw from each of
    the five distributions corresponding to the five slot machines. We thus obtain
    five values on the *x*-axis, each one corresponding to each of the five slot machines.
    Then, here comes the crucial question, the one that will tell whether you have
    the right intuition about the strategy.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**According to you, which slot machine are you going to play, based on the
    observation of these five values?** I really want you to take some time to answer
    this question, because right now, we are at the heart of the strategy (you can
    also have a look at our previously written code). The answer can be found in the
    next paragraph.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'I really hope you tried figuring this out by yourself: the slot machine that
    you are going to play next is the one for which we got the highest of the five
    random draws. Why? Because the highest random draws correspond to the highest
    success rate, and for this highest success rate, the Beta distribution associated
    with the slot machine picked has positive probabilities around that highest success
    rate.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to maximize the success rate of the machines we play (because
    we want to make money), we must pick the slot machine for which the Beta distribution
    has positive probabilities around the highest success rates. In the following
    graph, that's the yellow distribution.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Three Beta distributions'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must take a step back. I've been in your situation many times when I
    am learning something new and technical, which sometimes felt overwhelming. In
    that case, the best move is to take a step back, which is exactly what we are
    going to do now by giving a recap of the strategy and its intuition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The Thompson Sampling strategy in three steps
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we play each of the five slot machines over the first five rounds, here''s
    what the AI will do at each round ![](img/B14110_05_069.png):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'For each slot machine *i* (*i*=1,2,3,4,5), we take a random draw ![](img/B14110_05_070.png)
    from its Beta distribution:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_071.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'where:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_072.png) is the number of times the slot machine number ![](img/B14110_05_073.png)
    returned a 1 reward up to round ![](img/B14110_05_074.png).'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_075.png) is the number of times the slot machine number ![](img/B14110_05_076.png)
    returned a 0 reward up to round ![](img/B14110_05_062.png).'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We pull the arm of the slot machine ![](img/B14110_05_078.png) that has the
    highest sampled ![](img/B14110_05_079.png):'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14110_05_080.png)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We don''t forget to update ![](img/B14110_05_081.png) or ![](img/B14110_05_082.png):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the played slot machine ![](img/B14110_05_083.png) returned a 1 reward:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_084.png)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If the played slot machine ![](img/B14110_05_085.png) returned a 0 reward:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14110_05_086.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Then, we repeat these three steps at each round until we spend our 1,000 dollars.
    This strategy, called Thompson Sampling, is a basic but powerful model of a specific
    branch of AI, called Reinforcement Learning.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The final touch of shaping your Thompson Sampling intuition
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your intuition about why and how this works should be as follows (try to keep
    it in mind or visualize it on the graphic):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Each slot machine has its own Beta distribution. Over the rounds, the Beta distribution
    of the slot machine with the highest conversion rate will be progressively shifted
    to the right, and the Beta distributions of the strategies with lower conversion
    rates will be progressively shifted to the left (Steps 1 and 3). Therefore, because
    of Step 2, the slot machine with the highest conversion rate will be selected
    more and more.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: And voilà! Congratulations—you just learned about a powerful AI model, a massive
    step in your journey. To see Thompson Sampling in action and check that it indeed
    works, I won't force you to go to a casino and try it out; We'll apply it to another
    real-life model in *Chapter 6*, *AI for Sales and Advertising – Sell like the
    Wolf of AI Street*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let me finish this theory tutorial with a question for you. Remember
    earlier in the book I told you that any AI we build today takes as input a state,
    returns as output an action to play, and, after playing the action, gets a reward
    (positive or negative). **For this particular bandit problem, what are the input
    states, the actions played, and the rewards received?** Think about this before
    reading the next paragraph.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we go with the answer:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The input state is the exact round we've reached, including the information
    of the two parameters ![](img/B14110_05_087.png) and ![](img/B14110_05_088.png).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output action is the arm we pull from the selected slot machine.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reward is 1 or 0, 1 if the slot machine returns twice our dollar invested,
    and 0 if we lose our dollar.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations to you if you answered that one correctly, and for tackling
    this first AI model, Thompson Sampling. And don't forget, in *Chapter 6*, *AI
    for Sales and Advertising – Sell like the Wolf of AI Street*, we put this into
    practice to solve a real-world business problem.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Thompson Sampling against the standard model
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When I learned Thompson Sampling for the first time, I had one main question
    in my mind: is it really that good? In fact, if you were to run the standard model
    (by "standard model" I mean playing every slot machine a certain number of times)
    and Thompson Sampling separately you might not see much difference; you would
    likely come to the conclusion that they work pretty much as well as each other.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether it is true that Thompson Sampling isn''t any better, I implemented
    a code to test both solutions on many different scenarios. The changes included:
    number of samples (200 or 1,000 or 5,000), number of slot machines (from 3 to
    20), and conversion rate ranges (ranges in which conversion rates could be set:
    0-0.1; 0-0.3; 0-0.5).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Every scenario was tested 100 times to compute the accuracy of each model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The results and the code used are provided in the `resultsModified.xlsx` and
    `comparison.py` files, respectively, in `Chapter 05` of this book''s GitHub page.
    Here, you can see some graphs taken from this Excel file that show the performance
    of both models:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_06.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Accuracy vs. Number of slot machines (200 samples)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This first graph in *Figure 6* illustrates the accuracy of both models depending
    on the number of slot machines. The number of samples was set to 200 and the conversion
    rate ranges were set to 0-0.1, meaning that the differences between these rates
    were minor. This is the toughest setting for this comparison. Overall, Thompson
    Sampling performed better than the standard model (22% better).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_05_07.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Accuracy vs. Number of slot machines (5,000 samples)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: This second graph in *Figure 7* shows the performance under the easiest conditions.
    The number of samples was set to 5,000 and the conversion rate ranges were set
    to 0-0.5, meaning that the differences were clearly visible. The overall drop
    of accuracy for Thompson Sampling is smaller than the drop in accuracy for the
    standard solution. Thompson Sampling performed significantly better this time
    (41% better).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Taking all scenarios into consideration, Thompson Sampling achieved a mean accuracy
    of 57% and the standard model achieved 43% accuracy. This is a significant difference
    taking into account the fact that very tough scenarios were tested (for example,
    only 200 samples, a range of 0-0.1, and 20 slot machines).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thompson Sampling is a powerful sampling technique that enables you to quickly
    figure out the highest of a number of unknown conversion rates. It is always applied
    in the same frame, called the multi-armed bandit problem, which in the classic
    sense is composed of several slot machines, each one having a different conversion
    rate of positive outcomes. We had a first glance at how this AI solves this problem
    better and faster than standard methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will perform a full practical activity where we will
    see how the multi-armed bandit frame can easily model a business problem—online
    advertising—and how Thompson Sampling can bring significant added value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
