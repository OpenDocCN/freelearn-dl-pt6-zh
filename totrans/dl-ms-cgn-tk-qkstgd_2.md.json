["```py\ncd ch2\njupyter notebook\n```", "```py\nfrom cntk.layers import Dense\nfrom cntk import input_variable\n\nfeatures = input_variable(100)\nlayer = Dense(50)(features)\n```", "```py\nfrom cntk.layers import Sequential, Dense\nfrom cntk import input_variable\n\nfeatures = input_variable(7)\n\nnetwork = Sequential([\n  Dense(64),\n  Dense(32),\n  Dense(3)\n])(features)\n```", "```py\nfrom cntk.layers import Dense\nfrom cntk.ops import sigmoid\nfrom cntk.initializer import glorot_uniform\n\nlayer = Dense(128, activation=sigmoid, init=glorot_uniform)\n```", "```py\nfrom cntk import default_options\nfrom cntk.layers import Dense, Sequential\nfrom cntk.ops import sigmoid\n\nwith default_options(activation=sigmoid):\n  network = Sequential([\n    Dense(1024),\n    Dense(512),\n    Dense(256)\n  ])\n```", "```py\nfrom cntk import default_options, input_variable\nfrom cntk.layers import Dense, Sequential\nfrom cntk.ops import log_softmax, relu\n```", "```py\nmodel = Sequential([\n    Dense(4, activation=relu),\n    Dense(3, activation=log_softmax)\n])\n```", "```py\nfeatures = input_variable(4)\nz = model(features)\n```", "```py\nlabel = input_variable(3)\nloss = cross_entropy_with_softmax(z, label)\n```", "```py\nerror_rate = classification_error(z, label)\n```", "```py\nfrom cntk.learners import sgd\nfrom cntk.train.trainer import Trainer\n\nlearner = sgd(z.parameters, 0.01)\n\ntrainer = Trainer(z, (loss, error_rate), [learner])\n```", "```py\nimport pandas as pd\n\ndf_source = pd.read_csv('iris.csv', \n    names=['sepal_length', 'sepal_width','petal_length','petal_width', 'species'], \n    index_col=False)\n```", "```py\nX = df_source.iloc[:, :4].values\ny = df_source['species'].values\n```", "```py\nlabel_mapping = {\n    'Iris-setosa': 0,\n    'Iris-versicolor': 1,\n    'Iris-virginica': 2\n}\n```", "```py\ndef one_hot(index, length):\n    result = np.zeros(length)\n    result[index] = 1\n\n    return result\n```", "```py\ny = np.array([one_hot(label_mapping[v], 3) for v in y])\n```", "```py\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.2, stratify=y)\n```", "```py\ntrainer.train_minibatch({ features: X_train, label: y_train })\n```", "```py\nfor _epoch in range(10):\n    trainer.train_minibatch({ features: X_train, label: y_train })\n\n    print('Loss: {}, Acc: {}'.format(\n        trainer.previous_minibatch_loss_average,\n        trainer.previous_minibatch_evaluation_average))\n```", "```py\ntrainer.test_minibatch( {features: X_test, label: y_test })\n```", "```py\nsample_index = np.random.choice(X_test.shape[0])\nsample = X_test[sample_index]\n\ninverted_mapping = {\n    1: 'Iris-setosa',\n    2: 'Iris-versicolor',\n    3: 'Iris-virginica'\n}\n\nprediction = z(sample)\npredicted_label = inverted_mapping[np.argmax(prediction)]\n\nprint(predicted_label)\n```", "```py\nIris-versicolor\n```"]