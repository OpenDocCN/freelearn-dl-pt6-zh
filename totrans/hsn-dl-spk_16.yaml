- en: 'Appendix A: Functional Programming in Scala'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala combines functional programming and object-oriented programming in a single
    high-level language. This appendix contains a reference to the principles of functional
    programming in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming (FP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In FP, functions are first-class citizens—this means that they are treated
    like any other values and can be passed as arguments to other functions or be
    returned as a result of a function. In FP, it is also possible to work with functions
    in the so-called literal form, with no need to name them. Let''s look at the following
    Scala example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`i => i % 2 == 0` is a function literal without a name. It checks whether a
    number is even. It can be passed as another function argument or it can be used
    as a return value.'
  prefs: []
  type: TYPE_NORMAL
- en: Purity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the pillars of functional programming is pure functions. A pure programming
    function is a function that is analogous of a mathematical function. It depends
    only on its input parameters and its internal algorithm and always returns an
    expected result for a given input, since it doesn't rely on anything from outside.
    (This is a big difference compared to the OOP methods.) You can easily understand
    that this makes a function easier to test and maintain. The fact that a pure function
    doesn't rely on anything else from the outside means that it doesn't have side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Purely functional programs work on immutable data. Rather than altering existing
    values, altered copies are created while the originals are preserved. This means
    that they can be shared between the old and new copies because the unchanged parts
    of the structure cannot be modified. An outcome of this behavior is a significant
    saving in terms of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of pure functions in Scala (and Java) include the `size` method of
    `List` ([https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html))
    or the `lowercase` method of `String` ([https://docs.oracle.com/javase/8/docs/api/java/lang/String.html](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)).
    `String` and `List` are both immutable, and, as a consequence, all of their methods
    act like pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: But not all abstractions can be directly implemented with pure functions (some
    such as reading and writing from a database or object storage or logging). FP
    provides two approaches that allow developers to deal with impure abstractions
    in a pure way, therefore making the final code much cleaner and maintainable.
    The first approach, which is used in some other FP languages but not in Scala,
    is to extend the language's purely functional core with side effects. Then, the
    responsibility to avoid using impure functions in situations where only pure functions
    are expected is up to the developers. The second approach, which happens in Scala,
    is by introducing side effects to the pure language simulating them with *monads*
    ([https://www.haskell.org/tutorial/monads.html](https://www.haskell.org/tutorial/monads.html)).
    This way, while the programming language remains pure and referentially transparent,
    the monads can provide implicit state by threading it inside them. The compiler
    doesn't have to know about the imperative features because the language itself
    stays pure, while, usually, the implementations know about them due to efficiency
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Since pure computations are referentially transparent, they can be performed
    at any time while still yielding the same result, making it possible to defer
    the computation of values until they are really needed (lazy computation). This
    lazy evaluation avoids unnecessary computations and allows infinite data structures
    to be defined and used.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing side effects only through monads as in Scala and keeping the language
    pure makes it possible to have a lazy evaluation that doesn't conflict with the
    effects of impure code. While lazy expressions can be evaluated in any order,
    the monad structure forces these effects to be executed in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is heavily used in FP, as it is the canonical, and often the only,
    way to iterate. Functional language implementations will often include optimizations
    based on the so-called **tail recursion** ([https://alvinalexander.com/scala/fp-book/tail-recursive-algorithms](https://alvinalexander.com/scala/fp-book/tail-recursive-algorithms))
    to ensure that heavy recursion doesn''t have a significant or excessive impact
    on memory consumption. Tail recursion is a particular instance of recursion where
    the return value of a function is calculated only as a call to itself*.* Here
    is a Scala example of calculating a Fibonacci sequence recursively. This first
    piece of code represents an implementation of the recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This other piece of code represents an implementation of the same function
    in a tail-recursive way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the return line of the first function contains a call to itself, it also
    does something to its output, so the return value isn't really the recursive call's
    return value. The second implementation is a regular recursive (and in particular
    tail-recursive) function.
  prefs: []
  type: TYPE_NORMAL
