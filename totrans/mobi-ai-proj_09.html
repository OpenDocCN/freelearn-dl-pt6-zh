<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Sentiment Analysis over Text Using LinearSVC</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to build an iOS application to do sentiment analysis over text and image through user input. We will use existing data models that were built for the same purpose by using LinearSVC, and convert those models into core <strong>machine learning</strong> (<strong>ML</strong>) models for ease of use in our application. </p>
<p><span>Sentiment analysis is the process of identifying a feeling or opinion that is inspired by any given data in the form of text, image, audio, or video. There are a lot of use cases for sentiment analysis. Even now, political parties can easily identify the general mindset of the people who are going to elect them and they also have the potential to change that mindset. </span></p>
<p>Let's take a look at building our own ML model on sentiment analysis from an existing dataset.<span> In this chapter, we will look at the following topics: </span></p>
<ul>
<li>Building the ML model using scikit-learn</li>
<li><strong>Linear Support Vector Classification</strong> (<strong>LinearSVC</strong>)</li>
<li>Building an iOS application </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the ML model using scikit–learn</h1>
                </header>
            
            <article>
                
<p>In this section, we will build our own model. There are existing datasets available that are related to Twitter feed data on the topic of product and movie reviews. You can pick a dataset that suits you; in this chapter, we will pick a dataset that has customer reviews.</p>
<div class="packt_infobox">A dataset that contains both positive and negative reviews of customers can be found at <a href="http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/">http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/</a>. You can download the dataset from the following link: <a href="http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/epinions3.zip">http://boston.lti.cs.cmu.edu/classes/95-865-K/HW/HW3/epinions3.zip</a>.</div>
<p>The aforementioned dataset has both positive and negative feedback about a product, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-833 image-border" src="assets/f5643436-bbd4-4559-8af3-aee1844cc3b4.png" style="width:59.00em;height:13.33em;"/></div>
<p>We will train the dataset using the scikit-learn pipeline and LinearSVC. Let's take a closer look at both of these. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scikit-learn</h1>
                </header>
            
            <article>
                
<p>This is a data mining and data analysis Python library built on top of <strong>NumPy</strong>, <strong>SciPy</strong>, and <strong>Matplotlib</strong>. This helps with ML problems related to classification, regression, clustering, and dimensionality reduction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scikit-learn pipeline</h1>
                </header>
            
            <article>
                
<p>The main purpose of the scikit-learn pipeline is to assemble ML steps. This can be cross-validated to set various parameters. Scikit-learn provides a library of transformers that are used for preprocessing data (data cleaning), k<span>ernel approximation (expand), u</span><span>nsupervised dimensionality reduction (reduce),</span> and f<span>eature extraction</span> (generate). The pipeline contains a series of transformers with a final estimator.</p>
<p>The pipeline sequentially applies a list of transforms, followed by a final estimator. In the pipeline, the <kbd>fit</kbd> and <kbd>transform</kbd> methods are implemented during the intermediate steps. The <kbd>fit</kbd> method is implemented only at the end of pipeline operation by the final estimator. To cache the transformers in the pipeline, memory arguments are used.</p>
<div class="packt_tip">An estimator for classification is a Python object that implements the method's fit (<em>x</em>, <em>y</em>) and predict (<em>T</em>) values. An example of this is <kbd>class sklearn.svm.SVC</kbd>, which implements SVC. T<span>he model's parameters are taken as arguments for the</span> estimator's constructor. The <kbd>memory</kbd> class in scikit-learn has the <kbd>class sklearn.utils.Memory(*args, **kwargs)</kbd> signature<span>. This has methods to cache, clear, reduce, evaluate, and format the memory objects. The <kbd>cache</kbd> method is used to compute the return value of the function. The returned object is a <kbd>MemorizedFunc</kbd> object, which behaves like a function and offers additional methods for cache lookup and management. The <kbd>cache</kbd> method takes parameters such as <kbd>func=None, ignore=None, verbose=None, and mmap_mode=False</kbd>.</span></div>
<p>The <kbd>class signature</kbd> pipeline is as follows:</p>
<pre>class sklearn.pipeline.Pipeline(steps, memory=None)</pre>
<p>Let's take a look at another important component in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LinearSVC</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the classes in the scikit-learn library is LinearSVC, which supports both sparse and dense types of input. A one-versus-the-rest scheme is used to handle the multiclass support. LinearSVC is similar to SVC, where the parameter is <kbd>kernel = linear</kbd>, but <span><kbd>liblinear</kbd> is used to implement the parameter in LinearSVC, rather than <kbd>libvsm</kbd>, which is used in SVC. This provides us with more flexibility to choose the penalties and loss functions. It also helps in scaling a large number of samples in a better way.</span></p>
<p>The <kbd>class</kbd> signature is as follows:</p>
<pre>class sklearn.svm.LinearSVC(penalty=’l2’, loss=’squared_hinge’, dual=True, tol=0.0001, C=1.0, multi_class=’ovr’, fit_intercept=True, intercept_scaling=1, class_weight=None, verbose=0, random_state=None, max_iter=1000)</pre>
<p>It's now time to start building our model, as follows:</p>
<ol>
<li>We will start by importing all the necessary libraries, as follows:</li>
</ol>
<pre style="padding-left: 60px;">import re<br/>import coremltools<br/>import pandas as pd<br/>import numpy as np<br/>from nltk.corpus import stopwords<br/>from nltk import word_tokenize<br/>from string import punctuation<br/>from sklearn.feature_extraction import DictVectorizer<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.svm import LinearSVC<br/>from sklearn.model_selection import GridSearchCV</pre>
<p style="padding-left: 60px;">The <kbd>re</kbd> library is the regular expressions library that provides the matching operations that make it easy to handle text data. The <kbd>nltk</kbd> library is used to format the text according to our requirements, while <kbd>sklearn</kbd> offers the ML tools required. The <kbd>coremltools</kbd> library helps us in to convert the <kbd>sklearn</kbd> model to a Core ML model.</p>
<ol start="2">
<li>Now, let's start reading our input, as follows:</li>
</ol>
<pre style="padding-left: 60px;"># Read reviews from CSV<br/>reviews = pd.read_csv('epinions.csv')<br/>reviews = reviews.as_matrix()[:, :]<br/>print "%d reviews in dataset" % len(reviews)</pre>
<p class="graf graf--p graf-after--figure" style="padding-left: 60px;">The preceding code reads the CSV file and then converts it into a <kbd>numpy</kbd> array that includes all the rows and columns. Now that we have the dataset ready, we can start extracting the features from the data. </p>
<ol start="3">
<li class="graf graf--p graf-after--p">Now, let's work on feature selection, as follows:</li>
</ol>
<pre style="padding-left: 60px;"># Create features<br/>def features(sentence):<br/> stop_words = stopwords.words('english') + list(punctuation)<br/> words = word_tokenize(sentence)<br/> words = [w.lower() for w in words]<br/> filtered = [w for w in words if w not in stop_words and not    <br/>             w.isdigit()]<br/> words = {}<br/> for word in filtered:<br/>     if word in words:<br/>         words[word] += 1.0<br/>     else:<br/>         words[word] = 1.0<br/> return words</pre>
<ol start="4">
<li>We will start by vectorizing the <kbd>features</kbd> function. Then, we will extract the features of every sentence in the DataFrame and store them in an <kbd>X</kbd> variable. After this, we will set the target variable. The target variable is going to be the output. In our case, we will get a label for every sentence that indicates the sentiment in it:</li>
</ol>
<pre style="padding-left: 60px;"># Vectorize the features function<br/>features = np.vectorize(features)<br/># Extract the features for the whole dataset<br/>X = features(reviews[:, 1])<br/># Set the targets<br/>y = reviews[:, 0]</pre>
<ol start="5">
<li>In our case, we will create a pipeline with <kbd>DictVectorizer</kbd> and <kbd>LinearSVC</kbd>. <kbd>DictVectorizer</kbd>, as the name suggests, converts the dictionary in to vectors. We have picked <kbd>GridSearchCV</kbd> to select the best model from a family of models, parametrized by a grid of parameters: </li>
</ol>
<pre style="padding-left: 60px;"># Do grid search<br/>clf = Pipeline([("dct", DictVectorizer()), ("svc", LinearSVC())])<br/>params = {<br/> "svc__C": [1e15, 1e13, 1e11, 1e9, 1e7, 1e5, 1e3, 1e1, 1e-1, 1e-3,  <br/>            1e-5]<br/>}<br/>gs = GridSearchCV(clf, params, cv=10, verbose=2, n_jobs=-1)<br/>gs.fit(X, y)<br/>model = gs.best_estimator_</pre>
<ol start="6">
<li>We will then print the results, as follows:</li>
</ol>
<pre style="padding-left: 60px;"># Print results<br/>print model.score(X, y)<br/>print "Optimized parameters: ", model<br/>print "Best CV score: ", gs.best<em>score</em></pre>
<ol start="7">
<li>We can now convert the scikit-learn model into <kbd>mlmodel</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px;"># Convert to CoreML model<br/>coreml_model = coremltools.converters.sklearn.convert(model)<br/>coreml_model.short_description = 'Sentiment analysis AI projects.'<br/>coreml_model.input_description['input'] = 'Features extracted from <br/>                                           the text.'<br/>coreml_model.output_description['classLabel'] = 'The most likely polarity (positive or negative or neutral), for the given input.'<br/>coreml_model.output_description['classProbability'] = 'The probabilities for each class label, for the given input.'<br/>coreml_model.save('Sentiment.mlmodel')</pre>
<p class="mce-root"/>
<p>Once we have our model, we can start building the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the iOS application</h1>
                </header>
            
            <article>
                
<p>Let's start building the iOS application with the model that was built in the previous step. The model will predict the output according to whether the input text is positive, neutral, or negative in nature.</p>
<p>To build this application, Xcode version 10.1 should be used:</p>
<ol>
<li>Create a new project with a <strong>Single View app</strong>, as illustrated in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33d4fee8-f8c2-44fb-b863-da21ec9aecd5.png" style="width:48.50em;height:34.67em;"/></p>
<ol start="2">
<li>Mention the name of our application on the <strong>Next</strong> screen. </li>
<li>On the next wizard screen, pick an appropriate name for your application.</li>
<li>Fill in the rest of the fields, including <span class="packt_screen">Organization Name</span>, as well as <span class="packt_screen">Organization Identifier</span>.</li>
<li>We are not going to use core data in this application, so let's skip that option.</li>
<li>Let's start by creating a new app in Xcode. The following screenshot demonstrates how to create a new project in Xcode:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/81976eeb-5ae5-4f01-bbd5-1246a2f011c6.png" style="width:49.83em;height:35.83em;"/></p>
<ol start="7">
<li>Next, create a storyboard, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-835 image-border" src="assets/d498728f-2fb4-4fab-bf81-5e3b27eb1b43.png" style="width:55.25em;height:41.67em;"/></p>
<ol start="8">
<li>Once you select the file location in which to save your application, you will be able to see the <span class="packt_screen">General</span> tab with information on the new application that has been initialized, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8cfe0a2b-ef16-4717-bab9-7b4ebf6a7790.png" style="width:61.17em;height:31.42em;"/></p>
<ol start="9">
<li>We will create a simple UI with a button at the bottom to display the sentiment:</li>
</ol>
<pre class="p1" style="padding-left: 60px;">//initialize Ui components<br/><span class="s2">private</span> <span class="s2">lazy</span> <span class="s2">var</span> textView: <span class="s3">UITextView</span> = <span class="s2">self</span>.<span class="s4">makeTextView</span>()<span class="Apple-converted-space">   </span><span class="s2">private</span> <span class="s2">lazy</span> <span class="s2">var</span> accessoryView = <span class="s3">UIView</span>()<br/><span class="s2">private</span> <span class="s2">lazy</span> <span class="s2">var</span> resultLabel: <span class="s3">UILabel</span> = <span class="s2">self</span>.<span class="s4">makeResultLabel</span>()<span class="Apple-converted-space">    </span><span class="s2">private</span> <span class="s2">lazy</span> <span class="s2">var</span> clearButton: <span class="s3">UIButton</span> = <span class="s2">self</span>.<span class="s4">makeClearButton</span>()<br/><span class="s2">private</span> <span class="s2">let</span> padding = <span class="s3">CGFloat</span>(<span class="s5">16</span>)<br/><span class="s2">private</span> <span class="s2">var</span> textViewBottomConstraint: <span class="s3">NSLayoutConstraint</span>?</pre>
<ol start="10">
<li>We will define <kbd>sentiments</kbd> as the enumerator, as follows: </li>
</ol>
<pre style="padding-left: 60px;">enum Sentiment {<br/>     case neutral<br/>     case positive<br/>     case negative<br/>    var emoji: String {<br/>        switch self {<br/>         case .neutral:<br/>         return "<img class="alignnone size-full wp-image-939 image-border" src="assets/340f2370-1c66-4c79-887a-64b0b828b98c.png" style="width:1.33em;height:1.42em;"/>"<br/>         case .positive:<br/>         return "<img class="alignnone size-full wp-image-940 image-border" src="assets/f7545fe7-4c0f-4890-b0b3-73d310145af5.png" style="width:1.33em;height:1.42em;"/>"<br/>         case .negative:<br/>         return "<img class="alignnone size-full wp-image-941 image-border" src="assets/2389b482-e8a1-421f-afbc-7b66aac121cd.png" style="width:1.33em;height:1.42em;"/>"<br/>     }<br/> }<br/>    var color: UIColor? {<br/>         switch self {<br/>             case .neutral:<br/>             return UIColor(named: "NeutralColor")<br/>             case .positive:<br/>             return UIColor(named: "PositiveColor")<br/>             case .negative:<br/>             return UIColor(named: "NegativeColor")<br/>         }<br/>     }<br/>}</pre>
<ol start="11">
<li>Let's write the <kbd>ClassificationService</kbd> to fetch the result from the model that we have built:</li>
</ol>
<pre style="padding-left: 60px;">  //variables initialization<br/>  private let options: NSLinguisticTagger.Options = [.omitWhitespace, .omitPunctuation, .omitOther]<br/>  private lazy var tagger: NSLinguisticTagger = .init(<br/>    tagSchemes: NSLinguisticTagger.availableTagSchemes(forLanguage: "en"),<br/>    options: Int(self.options.rawValue)<br/>  )<br/><br/>private extension ClassificationService {<br/> func features(from text: String) -&gt; [String: Double] {<br/>     var wordCounts = [String: Double]()<br/>     tagger.string = text<br/>     let range = NSRange(location: 0, length: text.utf16.count)<br/>     // let's tokenize the input text and count the sentence<br/>     tagger.enumerateTags(in: range, scheme: .nameType, options: options) { _, tokenRange, _, _ in<br/>         let token = (text as NSString).substring(with: tokenRange).lowercased()<br/>         // Skip small words<br/>         guard token.count &gt;= 3 else {<br/>         return<br/>         }<br/>         if let value = wordCounts[token] {<br/>             wordCounts[token] = value + 1.0<br/>         } else {<br/>             wordCounts[token] = 1.0<br/>         }<br/>     }<br/> return wordCounts<br/> }</pre>
<ol start="12">
<li>The input is passed on to the <kbd>prediction</kbd> method to filter the statements into <kbd>positive</kbd>, <kbd>negative</kbd>, or <kbd>neutral</kbd> sentiments:</li>
</ol>
<pre style="padding-left: 60px;">func predictSentiment(from text: String) -&gt; Sentiment {<br/> do {<br/> let inputFeatures = features(from: text)<br/> // Make prediction only with 2 or more words<br/> guard inputFeatures.count &gt; 1 else {<br/> throw Error.featuresMissing<br/> }<br/> let output = try model.prediction(input: inputFeatures)<br/>     switch output.classLabel {<br/>         case "Positive":<br/>             return .positive<br/>         case "Negative":<br/>             return .negative<br/>         default:<br/>             return .neutral<br/>             }<br/> } catch {<br/>     return .neutral<br/>     }<br/> }<br/>}</pre>
<ol start="13">
<li>Let's write <kbd>ViewController</kbd> by initializing the <kbd>view</kbd> components, as follows:</li>
</ol>
<pre style="padding-left: 60px;">override func viewDidLoad() {<br/> super.viewDidLoad()<br/> title = "Sentiment Analysis".uppercased()<br/> view.backgroundColor = UIColor(named: "BackgroundColor")<br/> view.addSubview(textView)<br/> accessoryView.frame = CGRect(x: 0, y: 0, width: view.frame.size.width, height: 60)<br/> accessoryView.addSubview(resultLabel)<br/> accessoryView.addSubview(clearButton)<br/> textView.inputAccessoryView = accessoryView<br/>NotificationCenter.default.addObserver(<br/> self,<br/> selector: #selector(keyboardDidShow(notification:)),<br/> name: .UIKeyboardDidShow,<br/> object: nil<br/> )<br/> setupConstraints()<br/> //Show default sentiment as neutral<br/> show(sentiment: .neutral)<br/> }</pre>
<ol start="14">
<li class="mce-root">The initial <kbd>setupConstraints</kbd> on the buttons and labels are defined as follows:</li>
</ol>
<pre style="padding-left: 60px;">func setupConstraints() {<br/> //input textview <br/> textView.translatesAutoresizingMaskIntoConstraints = false<br/> textView.topAnchor.constraint(equalTo: view.topAnchor, constant: 80).isActive = true<br/> textView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding).isActive = true<br/> textView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -padding).isActive = true<br/> textViewBottomConstraint = textView.bottomAnchor.constraint(equalTo: view.bottomAnchor)<br/> textViewBottomConstraint?.isActive = true<br/><br/>//result label at the bottom<br/> resultLabel.translatesAutoresizingMaskIntoConstraints = false<br/> resultLabel.centerXAnchor.constraint(equalTo: accessoryView.centerXAnchor).isActive = true<br/> resultLabel.centerYAnchor.constraint(equalTo: accessoryView.centerYAnchor).isActive = true<br/><br/>//Clear button at the bottom right<br/> clearButton.translatesAutoresizingMaskIntoConstraints = false<br/> clearButton.trailingAnchor.constraint(<br/> equalTo: accessoryView.trailingAnchor,<br/> constant: -padding<br/> ).isActive = true<br/> clearButton.centerYAnchor.constraint(equalTo: accessoryView.centerYAnchor).isActive = true<br/> }</pre>
<ol start="15">
<li>Define the <kbd>Show()</kbd> method, as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px;"><span class="s1">private</span> <span class="s1">func</span> show(sentiment: <span class="s2">Sentiment</span>) {                                  accessoryView<span>.</span><span class="s3">backgroundColor</span><span> = sentiment.</span><span class="s2">color    <br/>         </span>resultLabel<span>.</span><span class="s3">text</span><span> = sentiment.</span><span class="s2">emoji<br/></span> <span>}</span></pre>
<ol start="16">
<li>Let's run the application on the simulator. You can see the output in the following screenshot: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/251e6987-1989-41b3-844c-fc1bf96f162c.png" style="width:19.58em;height:42.33em;"/></p>
<ol start="17">
<li>Now, let's use different inputs for our application and get the output, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/017d54c1-515d-4d4e-aae4-dceb1ac848b1.png" style="width:17.83em;height:38.58em;"/></p>
<ol start="18">
<li>An example statement of a negative input with the same output is shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c08a356a-a977-4bba-95f4-2152ab7aa4d6.png" style="width:17.92em;height:38.83em;"/></p>
<ol start="19">
<li>An example input using neutral text is shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a79e9403-a408-4265-acbc-46072f9e1a73.png" style="width:18.17em;height:39.33em;"/></p>
<p>Here, we are able to get the sentiment from the given text input. Now, you can go one step further by improving the existing model. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_tip packt_infobox"><span>You can explore finding sentiments on images in further detail in various sources. An example application is </span><em>Fine-tuning CNNs for Visual Sentiment Prediction</em>. You can read about this application at <a href="https://github.com/imatge-upc/sentiment-2017-imavis" rel="noopener noreferrer" target="_blank">https://github.com/imatge-upc/sentiment-2017-imavis</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>At this point, you should be able to build your own TensorFlow model and convert it into a Core ML model so that it can be used in an iOS application. The same TensorFlow model can be converted into a TensorFlow Lite model, which can then be used in an Android application or iOS application. Now, you can take on this task and experiment with the results. That said, we are now ready to move on to the next chapter.</p>
<p>In the next chapter, you will use the knowledge we have acquired in this book to move on and explore how you can build your own application.</p>


            </article>

            
        </section>
    </body></html>