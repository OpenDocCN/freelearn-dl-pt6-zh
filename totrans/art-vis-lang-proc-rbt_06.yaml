- en: '*Chapter 6*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot Operating System (ROS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain Robot Operating System (ROS) essentials and basic concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Robot Operating System packages and work with them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate a virtual robot with information obtained from sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop and implement working programs for robots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter focuses on ROS and the different ways to work with its packages.
    You'll also learn how to operate a virtual robot based on the information received
    from its sensors using ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing software for robots is not as easy as developing any other type of
    software. To build robots, you need methods and functions that enable you to access
    sensor information, control robot parts, and connect with the robot. These methods
    and functions are present in ROS, making it easier to build a virtual robot.
  prefs: []
  type: TYPE_NORMAL
- en: '**ROS** is a framework that is compatible with Ubuntu (Linux) for writing robot
    software. It is a set of libraries and tools through which it is possible to build
    and create various robotic behaviors. One of the most interesting features about
    this framework is that the developed code can be adapted for any other robot.
    ROS also gives you a chance to work on several machines simultaneously; for instance,
    if you want to use a robot to collect apples, you can use a computer to obtain
    the camera information of the apple and process it, another machine to launch
    the movement that commands the robot, and finally the robot will pick up the apple.
    By following this workflow, computers won''t perform too many computational tasks,
    and the execution turns out to be more fluid.'
  prefs: []
  type: TYPE_NORMAL
- en: ROS is the most widely used tool for robotics, both for researchers and companies.
    It is becoming a standard for robotics tasks. Furthermore, ROS is constantly evolving
    to solve new problems and is adapting to different technologies. All these facts
    make it a good topic for studying and practicing.
  prefs: []
  type: TYPE_NORMAL
- en: ROS Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, working with ROS is not easy the first time round. But
    just like any other software, you need to know how ROS works and how to perform
    certain tasks using it. In order to do that and before installing or working with
    the framework, it is important to understand its basic concepts. The key ideas
    behind ROS'' functions that will help you understand its internal processes are
    mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: An ROS node is a process in charge of performing tasks and calculations.
    They can be combined with each other using topics or other more complex tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topic**: Topics can be defined as information channels between nodes that
    work in a unidirectional way. This is considered a unidirectional workflow because
    nodes can subscribe to topics, but a topic would not know which nodes are subscribed
    to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master**: The ROS master is a service that provides a name and registration
    to the remaining nodes. Its main function is to enable individual nodes so that
    they can locate each other and establish peer-to-peer communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package**: Packages are the core of ROS organization. Within these packages,
    you can find nodes, libraries, datasets, or useful components to build a robotics
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack**: An ROS stack is a set of nodes that, all together, provide some
    functionality. It can be useful for dividing tasks between nodes when the functionality
    to develop is too complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the aforementioned concepts, there are many other concepts that
    can be useful when using ROS, but understanding these basic ones will let you
    implement powerful programs for robots. Let''s look at a simple example in order
    to learn how they would be used in a real situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: A schema of a real example system using ROS](img/C13550_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: A schema of a real example system using ROS'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The situation here consists of a robot changing its direction when detecting
    a close obstacle. This is how it works step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The ROS master is enabled. This means the ROS system has been started and can
    have any node run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proximity node starts and extracts information from the laser sensor. It
    advertises the master to publish this obtained information. If there's no problem
    and the information has the expected type, the master will allow the node to publish
    through a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the master allows the node to publish, the information is passed to a topic
    and published. In this case, the proximity node publishes the information in the
    laser topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The movement node asks the master to subscribe to a laser topic. When subscribed,
    it will obtain the published information and work with it to decide the next action
    for the robot to perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To sum up, both nodes can share information using the master service, which
    notifies both nodes about each other's existence.
  prefs: []
  type: TYPE_NORMAL
- en: ROS Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ROS doesn''t have a graphical user interface to work with it; every action
    must be performed on the command line as it is compatible with Ubuntu. However,
    before getting your hands on the ROS, you need to learn about its most common
    commands. Here''s a short list of them and their functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**roscore**: This is the first command to be run when working with ROS. It
    enables the framework and provides support to any ROS program or operation. It
    should be launched in order to allow node communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**roscd**: This command switches to a stack or package directory without entering
    a physical path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rosnode**: These commands manage nodes and obtain information about them.
    Here, you can see the most used rosnode commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rosnode list**: This command prints the information of active nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rosnode info <node_name>**: This informs the user about the entered node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rosnode kill <node_name>**: The function of this command is to stop a node
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rosrun**: Using this command, you can run any application on your system
    without switching to its directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rostopic**: This command allows you to manage and check topic information.
    There are several other types for this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rostopic list**: This type prints the information of active topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rostopic info <topic_name>**: This shows information about a concrete topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rostopic pub <topic_name> [data...]**: The function of this command is to
    publish the given data to the entered topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rqt_graph**: This is a very useful command that can be used to graphically
    observe active nodes and topics that are being published or subscribed to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation and Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to consider before installing ROS is the installed Ubuntu version.
    There are several ROS versions that you will have to choose from depending on
    your operating system version. In this case, we are explaining the installation
    of ROS Kinetic Kame, which is compatible with Ubuntu 16.04 LTS (Xenial Xerus).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If this is not your Ubuntu version, you can head to the ROS website, [http://www.ros.org/](http://www.ros.org/),
    and look for the corresponding distribution.
  prefs: []
  type: TYPE_NORMAL
- en: As happens with almost every other tool, it is recommended to always install
    the latest version, because it may have solved errors or new functionalities;
    but, as mentioned before, don't worry if you're working with an older version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get detailed steps on how to install ROS, refer to the preface on page vi.
  prefs: []
  type: TYPE_NORMAL
- en: Catkin Workspaces and Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the last step before coding your first application and program for robots.
    You have to set up your working environment. To do this, you are going to learn
    what catkin workspaces and packages are and how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: A catkin workspace is a ROS directory where catkin packages can be created,
    compiled, and run. A catkin package is a container for creating ROS nodes and
    applications. Each of these packages work as a single project that can contain
    multiple nodes. It is important to know that the ROS code inside catkin packages
    can only be Python or C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to create the catkin workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Execute these commands in the same terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a standard folder containing a subfolder named "`src`." You can choose
    any location on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the new `catkin_ws` directory and run the `catkin` compilation command
    to initialize the new workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command must be executed every time you want to compile your workspace
    when making changes in any package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By following these simple steps, you will have your catkin workspace ready
    to work with. But, when working on it, you should always remember to enter this
    command first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This lets ROS know that there can be ROS executables in the created catkin workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have successfully completed the preceding process, you can now create
    your catkin packages and work on them. Create a package with the steps mentioned
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the "`src`" folder of your catkin workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use this command to create a package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The dependencies are a set of libraries or tools that the package needs to
    function correctly. For example, in a simple package where you only use Python
    code, the command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Publishers and Subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When explaining basic ROS concepts, we discussed a few nodes used for publishing
    data and some others used for subscribing to that data. Knowing this, it is not
    hard to imagine that nodes can be classified into two groups, depending on the
    kind of action they perform. They can be **publishers** or **subscribers**. Why
    do you think it is important to distinguish between these two types of nodes?
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, publishers are nodes that provide information to other
    nodes. They usually work with sensors to check the environment status and convert
    it into valuable outputs for subscribers that can receive this information.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, subscribers usually get an understandable input and process
    it. They then decide which action will be launched depending on the obtained result.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a rarely used type of programming, it will be interesting to follow
    some examples of how these nodes really work, before starting to use them with
    robots and simulators. So, let's go through some exercises that will help you
    understand nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Publishing and Subscribing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will write a simple publisher and subscriber in Python
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and enter the `roscore` command to start the ROS service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new package in your catkin workspace that contains the solution to
    this exercise. This package will depend on `rospy` and `std_msgs`, so you must
    create it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '`std_msgs` is a package that provides support to ROS primitive data types.
    You can find more information about it, including the concrete types of managed
    data, here: [http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch to the package directory and create a new folder, which will contain
    publisher and subscriber files, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go into the new folder and create a corresponding Python file for each node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide the executable permission to both files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin with the publisher implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the Python environment and import the necessary libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a function to publish the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a publisher that publishes a `String` message into a new topic, no matter
    its name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the created publisher variable to publish any desired `String`. For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, detect the program entry and call the created function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue with the subscriber implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize Python and import libraries as you did for your publisher.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to subscribe to the topic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the node in the same way as you did before:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Subscribe to `publisher_topic` using this function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `callback` function to print a message when it receives any data.
    For this first exercise, let''s kill the subscriber node when receiving the first
    message from the publisher. This can be done with the `signal_shutdown` method,
    which is integrated in `rospy` and only needs the shutdown reason as a parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the created function from the main execution thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the functioning of the created nodes. You can do this as described here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new terminal and switch to your workspace. Then, run the following command
    so that ROS checks it for executable files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the subscriber node. If the implementation is correct, it should remain
    under execution until you run your publisher:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a new terminal and enter the command again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the publisher node:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the nodes are well implemented, the subscriber execution ends after executing
    the publisher node. The output must be the message printed in the callback, in
    this case: `Message received`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: There is no need to compile the workspace in order to run your package nodes
    because they are written in Python. If they were coded in C++, you would have
    to build a package after every change in code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 21: Publishers and Subscribers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise is similar to the previous one but is complex. The publisher created
    before could only send one message per execution. Now, we are going to implement
    a publisher that won't stop sending data until we terminate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to create a number-finding system following these
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The publisher node must publish random numbers into a topic until it is stopped
    by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The subscriber node decides a number to look for and searches for it in the
    received message list. Here, there are two possibilities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is found before 1000 tries, a positive message will be printed
    and the number of tries it took to achieve it too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the number is not found in 1000 tries, a negative message will be printed
    telling the user that it was not possible to find the number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, this can be done in the following way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As mentioned earlier, begin by creating the package and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Begin with the publisher implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the necessary libraries. These libraries are the same as in the preface,
    but this time, you must change the `String` import for `Int32`, as the node is
    going to work with numbers. You should also import a random library to generate
    numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the number generator function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the publisher and initialize the node as you did in the previous exercise.
    Note that, this time, the data type is different and the queue size is set to
    10, which means that it will be possible to have 10 published numbers. When the
    eleventh number is published, the first will be dropped from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the rate at which the program loop will iterate. We are setting a
    rate of 10 (Hz), which is not a very high rate and that will allow us to check
    the generated numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the loop where the numbers will be generated and published. It has
    to iterate until the user stops it, so you can use the `is_shutdown()` function.
    Use the sleep function on the declared rate so it can take effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the created function from the node entry. Use a try directive so that
    the user shutdown doesn''t produce an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue with the subscriber implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the necessary libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class with two attributes: one for establishing the value of the number
    to find and the other one for counting the number of tries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the callback function. The logic of the finder has to be coded in
    this function. There are lots of ways to do this but this is a frequently used
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, it is a simple function that looks for the number and adds one
    to the counter for each failed try. If the number is found, it prints a positive
    message. If the counter reaches 1000, the search is aborted and a negative message
    is shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the function for subscribing. Remember that, this time, the published
    data type is `Int32`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, from the node entry, create a `Finder` class instance and call the
    `finder` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test whether the performed implementation is correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new terminal and run `roscore`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open another terminal and execute the subscriber node:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In another terminal, run the publisher node so that numbers are generated and
    the callback function starts working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the searched number, 50 in this case, is found, the output should be similar
    to this one:![Figure 6.2: Execution example where the number is found](img/C13550_06_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.2: Execution example where the number is found'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Change the searched number to a value higher than 100 when the number is not
    found. You should obtain an output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3: Execution example where the number is not found](img/C13550_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Execution example where the number is not found'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It will be interesting to use the `rqt_graph` command when both nodes are being
    executed; this way, you can see the structure you just created graphically. So,
    open a new terminal and enter the command. The output should be something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Output](img/C13550_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Simulators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simulators are very good tools for developing and testing robotics software.
    They make robotics affordable for everyone. Imagine that you are working on a
    robotics project, where you constantly have to test functionality improvements
    with your robot. It would require connecting the robot for each test, charging
    it many times, and moving it with you. All of this can be avoided with a simulator,
    which can be launched in your computer at any time; it can even simulate the nodes
    and topics generated by the robot. Do you know any simulator for working with
    robots?
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use Gazebo, a simulator included in the ROS full installation.
    In fact, if you chose this option while installing it, you can write "**gazebo**"
    in a terminal and it will launch the simulator. The Gazebo interface is shown
    in Figure 6.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The Gazebo start point](img/C13550_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The Gazebo start point'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next step is to install and set up the robot that we are going to simulate.
    In this case, we will use a **Turtlebot**, a wheelie robot that is equipped with
    sensors such as cameras and lasers. Turtlebot may not be compatible with your
    ROS distribution (we are using Kinetic Kame); but don't worry, there are lots
    of robots that you can simulate in Gazebo. You can look up different robots and
    try to use them with your ROS distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: The Turtlebot configuration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to go through some things you will need to do
    before using Turtlebot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download the `Turtlebot` simulator package in your `catkin` workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, you should be able to use Turtlebot with Gazebo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start ROS services:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch Turtlebot World:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should see the same Gazebo world as before, but with a set of objects,
    including Turtlebot, at the center, as mentioned in figure 6.5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6: The Turtlebot simulation using Gazebo](img/C13550_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The Turtlebot simulation using Gazebo'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once the simulation is correctly running, let's do another exercise for learning
    how to obtain information from sensors and work with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Simulators and Sensors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll create a ROS node that subscribes to the Turtlebot
    camera to obtain corresponding images. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a package with the necessary dependencies and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary libraries. For this exercise, we are going to use `OpenCV`
    to work with the images obtained from the camera:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class and declare an attribute of type `CvBridge`, which will be used
    later to change the image type to `cv2`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code the callback function, where you will have to obtain the image and convert
    it to the cv2 format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: We use the `waitKey()` function so that the image remains on the screen. It
    will disappear when the user presses any key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define and implement the subscriber function. Remember that, now, the required
    data has an Image type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don''t know the name of the topic to which you want to subscribe, you
    can always enter the `rostopic` list command and check the available nodes. You
    should see a list like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7: Output of the rostopic list command](img/C13550_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.7: Output of the rostopic list command'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Call the subscriber function from the program entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the node works fine. To do that, you should run `roscore` command,
    Gazebo with Turtlebot, and created the node in different terminals. Note that
    you may also run the `source devel/setup.bash` source if you didn''t do so earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result should be something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8: The execution example of the exercise node](img/C13550_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The execution example of the exercise node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 6: Simulators and Sensors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following scenario: you are working for a robotics company that
    has recently acquired a new client, a security surveillance company. So, you are
    asked to implement a surveillance system for a robot that guards the store at
    night. The client wants the robot to stay in the middle of the store and to look
    around constantly.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to simulate the system and you have been asked to use Turtlebot and
    Gazebo.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a node that subscribes to the camera and shows all the images it receives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a node for the robot to turn itself on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: To do that, you will have to publish the /mobile_base/commands/velocity topic,
    which works with Twist messages. Twist is a type of message included in the `geometry_msgs`
    library, so you will have to add this as a dependency. To make the robot rotate
    on itself, create an instance of Twist and modify its `angular.z` value. Then,
    publish it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, run both nodes at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of this activity, you will get an output similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.9: The rotating output that shows the images in the virtual environment](img/C13550_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The rotating output that shows the images in the virtual environment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 318.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with ROS, from its installation and
    configuration to the implementation of nodes. You also worked with simulators
    and its sensors, obtaining information from them and making the acquired information
    valuable for solving problems. All the exercises and activities covered in the
    chapter will be useful for you in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will work with natural language processing (NPL) and
    learn how to build a chatbot. If you build a good one, it could be a very interesting
    tool to add to a robot. You could even use ROS to develop it.
  prefs: []
  type: TYPE_NORMAL
