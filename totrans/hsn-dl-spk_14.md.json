["```py\nfrom keras.applications.vgg16 import VGG16\n```", "```py\nfrom keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\nimport numpy as np\nfrom PIL import Image\n```", "```py\nmodel = VGG16(weights='imagenet', include_top=True)\n```", "```py\nimg_path = 'test_image.jpg'\n img = image.load_img(img_path, target_size=(224, 224))\n```", "```py\nx = image.img_to_array(img)\n x = np.expand_dims(x, axis=0)\n x = preprocess_input(x)\n```", "```py\nfeatures = model.predict(x)\n```", "```py\nmodel_json = model.to_json()\n with open('vgg-16.json', 'w') as json_file:\n     json_file.write(model_json)\n```", "```py\nmodel.save_weights(\"vgg-16.h5\")\n```", "```py\nval vgg16Json = new ClassPathResource(\"vgg-16.json\").getFile.getPath\n val vgg16 = new ClassPathResource(\"vgg-16.h5\").getFile.getPath\n val model = KerasModelImport.importKerasModelAndWeights(vgg16Json, vgg16, false)\n```", "```py\nval testImage = new ClassPathResource(\"test_image.jpg\").getFile\n\n val height = 224\n val width = 224\n val channels = 3\n val loader = new NativeImageLoader(height, width, channels)\n```", "```py\nval image = loader.asMatrix(testImage)\n val scaler = new VGG16ImagePreProcessor\n scaler.transform(image)\n```", "```py\nval output = model.output(image)\n```", "```py\nval imagNetLabels = new ImageNetLabels\n val predictions = imagNetLabels.decodePredictions(output(0))\n println(predictions)\n```", "```py\nval modelSaveLocation = new File(\"Vgg-16.zip\")\n ModelSerializer.writeModel(model, modelSaveLocation, true)\n```", "```py\nsudo pip install dist-keras\n```", "```py\nexport SPARK_HOME=/usr/lib/spark\n export PYTHONPATH=\"$SPARK_HOME/python/:$SPARK_HOME/python/lib/py4j-0.9-src.zip:$PYTHONPATH\"\n```", "```py\nfrom keras.optimizers import *\n from keras.models import Sequential\n from keras.layers.core import Dense, Dropout, Activation\n```", "```py\nfrom pyspark import SparkContext\n from pyspark import SparkConf\n```", "```py\nfrom pyspark.ml.feature import StandardScaler\n from pyspark.ml.feature import VectorAssembler\n from pyspark.ml.feature import StringIndexer\n from pyspark.ml.evaluation import MulticlassClassificationEvaluator\n from pyspark.mllib.evaluation import BinaryClassificationMetrics\n```", "```py\nfrom distkeras.trainers import *\n from distkeras.predictors import *\n from distkeras.transformers import *\n from distkeras.evaluators import *\n from distkeras.utils import *\n```", "```py\nconf = SparkConf()\n conf.set(\"spark.app.name\", application_name)\n conf.set(\"spark.master\", master)\n conf.set(\"spark.executor.cores\", num_cores)\n conf.set(\"spark.executor.instances\", num_executors)\n conf.set(\"spark.locality.wait\", \"0\")\n conf.set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\");\n```", "```py\nsc = SparkSession.builder.config(conf=conf) \\\n     .appName(application_name) \\\n     .getOrCreate()\n```", "```py\nraw_dataset = sc.read.format('com.databricks.spark.csv') \\\n                     .options(header='true', inferSchema='true').load(\"data/some_data.csv\")\n```", "```py\nmodel = Sequential()\n model.add(Dense(500, input_shape=(nb_features,)))\n model.add(Activation('relu'))\n model.add(Dropout(0.4))\n model.add(Dense(500))\n model.add(Activation('relu'))\n model.add(Dense(nb_classes))\n model.add(Activation('softmax'))\n```", "```py\ntrainer = SingleTrainer(keras_model=model, worker_optimizer=optimizer,\n                         loss=loss, features_col=\"features_normalized\",\n                         label_col=\"label\", num_epoch=1, batch_size=32)\n trained_model = trainer.train(training_set)\n```", "```py\ngroupId: com.sparkjava\n artifactId: spark-core\n version: 2.7.2\n```", "```py\nget(\"/hello\", (req, res) -> \"Hello VGG16\");\n```", "```py\nhttp://localhost:4567/hello\n```", "```py\nClassLoader classLoader = getClass().getClassLoader();\n File serializedModelFile = new File(classLoader.getResource(\"Vgg-16.zip\").getFile());\n ComputationGraph vgg16 = ModelSerializer.restoreComputationGraph(serializedModelFile);\n```", "```py\nFile uploadDir = new File(\"upload\");\n uploadDir.mkdir();\n```", "```py\nstaticFiles.location(\"/public\");\n```", "```py\nprivate String buildFoundationHeader() {\n     String header = \"<head>\\n\"\n           + \"<link rel='stylesheet' href='foundation-float.min.css'>\\n\"\n           + \"</head>\\n\";\n\n     return header;\n }\n```", "```py\nprivate String buildUploadForm() {\n      String form =\n              \"<form method='post' action='getPredictions' enctype='multipart/form-data'>\\n\" +\n              \" <input type='file' name='uploadedFile'>\\n\" +\n              \" <button class='success button'>Upload picture</button>\\n\" +\n              \"</form>\\n\";\n\n     return form;\n }\n```", "```py\nString header = buildFoundationHeader();\n String form = buildUploadForm();\n get(\"Vgg16Predict\", (req, res) -> header + form);\n```", "```py\npost(\"/doPredictions\", (req, res)\n```", "```py\n// Upload the image file\nPath tempFile = Files.createTempFile(uploadDir.toPath(), \"\", \"\");\n\nreq.attribute(\"org.eclipse.jetty.multipartConfig\", new MultipartConfigElement(\"/temp\"));\n\ntry (InputStream input = req.raw().getPart(\"uploadedFile\").getInputStream()) {\n  Files.copy(input, tempFile, StandardCopyOption.REPLACE_EXISTING);\n}\n\n// Convert file to INDArray\nFile file = tempFile.toFile();\n\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\n// Delete the physical file\nfile.delete();\n\n// Pre-processing the image to prepare it for the VGG-16 model\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\n\n// Do inference\nINDArray[] output = vgg16.output(false,image);\n\n// Get the predictions\nImageNetLabels imagNetLabels = new ImageNetLabels();\nString predictions = imagNetLabels.decodePredictions(output[0]);\n\n// Return the results\nreturn buildFoundationHeader() + \"<h4> '\" + predictions + \"' </h4>\" +\n  \"Would you like to try another image?\" +\n  form;\n```", "```py\nhttp://localhost:4567/Vgg16Predict\n```", "```py\nport(8998);\n```", "```py\nport(8998);\n```", "```py\npost(\"/upload\", (req, res) -> uploadFile(req));\n```", "```py\nprivate String uploadFile(Request req) throws IOException, ServletException {\n    // Upload the image file\n    Path tempFile = Files.createTempFile(uploadDir.toPath(), \"\", \"\");\n\n    req.attribute(\"org.eclipse.jetty.multipartConfig\", new MultipartConfigElement(\"/temp\"));\n\n    try (InputStream input = req.raw().getPart(\"file\").getInputStream()) {\n      Files.copy(input, tempFile, StandardCopyOption.REPLACE_EXISTING);\n    }\n\n    // Convert file to INDArray\n    File file = tempFile.toFile();\n\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    INDArray image = loader.asMatrix(file);\n\n    // Delete the physical file\n    file.delete();\n\n    // Pre-processing the image to prepare it for the VGG-16 model\n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n\n    // Do inference\n    INDArray[] output = vgg16.output(false,image);\n\n    // Get the predictions\n    ImageNetLabels imagNetLabels = new ImageNetLabels();\n    String predictions = imagNetLabels.decodePredictions(output[0]);\n\n    // Return the results\n    return predictions;\n}\n```", "```py\ncurl -s -X POST http://localhost:8998/upload -F 'file=@/home/guglielmo/dlws2/vgg16/src/main/resources/test_image-02.jpg'\n```", "```py\nGson gson = new Gson();\n post(\"/upload\", (req, res) -> uploadFile(req), gson::toJson);\n```"]