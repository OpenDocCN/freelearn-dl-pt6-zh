["```py\noutput[i] = reduce(value[strides * i:strides * i + ksize])  \n```", "```py\n$ find . -type f -name \"._*.jpg\" -exec rm -f {} ;\n```", "```py\nprivate static BufferedImage makeSquare(BufferedImage img) {\n        int w = img.getWidth();\n        int h = img.getHeight();\n        int dim = Math.min(w, h);\n\n        if (w == h) {\n            return img;\n        } else if (w > h) {\n            return Scalr.crop(img, (w - h) / 2, 0, dim, dim);\n        } else {\n            return Scalr.crop(img, 0, (h - w) / 2, dim, dim);\n        }\n    }\n```", "```py\n// resize pixels\n    public static BufferedImage resizeImg(BufferedImage img, int width, int height) {\n        return Scalr.resize(img, Scalr.Method.BALANCED, width, height);\n    }\n```", "```py\nimport javax.imageio.ImageIO;\nimport org.imgscalr.Scalr;\n```", "```py\n<dependency>\n      <groupId>org.imgscalr</groupId>\n      <artifactId>imgscalr-lib</artifactId>\n      <version>4.2</version>\n</dependency>\n<dependency>\n      <groupId>org.datavec</groupId>\n      <artifactId>datavec-data-image</artifactId>\n      <version>${dl4j.version}</version>\n</dependency>\n```", "```py\nprivate static int pixels2Gray(int R, int G, int B) {\n        return (R + G + B) / 3;\n    }\nprivate static BufferedImage makeGray(BufferedImage testImage) {\n        int w = testImage.getWidth();\n        int h = testImage.getHeight();\n        for (int w1 = 0; w1 < w; w1++) {\n            for (int h1 = 0; h1 < h; h1++) {\n                int col = testImage.getRGB(w1, h1);\n                int R = (col & 0xff0000) / 65536;\n                int G = (col & 0xff00) / 256;\n                int B = (col & 0xff);\n                int graycol = pixels2Gray(R, G, B);\n                testImage.setRGB(w1, h1, new Color(graycol, graycol, graycol).getRGB());\n            }\n        }\n        return testImage;\n    }\n```", "```py\nconvertedImage = ImageIO.read(new File(x))\n          .makeSquare()\n          .resizeImg(resizeImgDim, resizeImgDim) // (128, 128)\n         .image2gray();\n```", "```py\n//imageUtils.java\npublic class imageUtils {\n    // image 2 vector processing\n    private static Integer pixels2gray(Integer red, Integer green, Integer blue){\n        return (red + green + blue) / 3;\n    }\n    private static List<Integer> pixels2color(Integer red, Integer green, Integer blue) {\n        return Arrays.asList(red, green, blue);\n    }\n\nprivate static <T> List<T> image2vec(BufferedImage img, Function<Triple<Integer, Integer, Integer>, T> f) {\n        int w = img.getWidth();\n        int h = img.getHeight();\n\n        ArrayList<T> result = new ArrayList<>();\n        for (int w1 = 0; w1 < w; w1++ ) {\n            for (int h1 = 0; h1 < h; h1++) {\n                int col = img.getRGB(w1, h1);\n                int red =  (col & 0xff0000) / 65536;\n                int green = (col & 0xff00) / 256;\n                int blue = (col & 0xff);\n                result.add(f.apply(new Triple<>(red, green, blue)));\n            }\n        }\n        return result;\n    }\n\n    public static List<Integer> image2gray(BufferedImage img) {\n        return image2vec(img, t -> pixels2gray(t.getFirst(), t.getSecond(), t.getThird()));\n    }\n\n    public static List<Integer> image2color(BufferedImage img) {\n        return image2vec(img, t -> pixels2color(t.getFirst(), t.getSecond(), t.getThird()))\n                .stream()\n                .flatMap(l -> l.stream())\n                .collect(Collectors.toList());\n    }\n\n    // make image square\n    public static BufferedImage makeSquare(BufferedImage img) {\n        int w = img.getWidth();\n        int h = img.getHeight();\n        int dim = Math.min(w, h);\n\n        if (w == h) {\n            return img;\n        } else if (w > h) {\n            return Scalr.crop(img, (w-h)/2, 0, dim, dim);\n        } else  {\n            return Scalr.crop(img, 0, (h-w)/2, dim, dim);\n        }\n    }\n\n    // resize pixels\npublic static BufferedImage resizeImg(BufferedImage img, int width, int height) {\n        return Scalr.resize(img, Scalr.Method.BALANCED, width, height);\n    }\n}\n```", "```py\npublic static List<List<String>> readMetadata(String csv, List<Integer> rows) throws IOException {\n        boolean defaultRows = rows.size() == 1 && rows.get(0) == -1;\n        LinkedList<Integer> rowsCopy = null;\n        if (!defaultRows) {\n            rowsCopy = new LinkedList<>(rows);\n        }\n        try(BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(csv))))) {\n            ArrayList<List<String>> arrayList = new ArrayList<>();\n            String line = bufferedReader.readLine();\n            int i = 0;\n            while (line != null) {\n                if (defaultRows || rowsCopy.getFirst() == i) {\n                    if (!defaultRows) {\n                        rowsCopy.removeFirst();\n                    }\n                    arrayList.add(Arrays.asList(line.split(\",\")));\n                }\n                line = bufferedReader.readLine();\n                i++;\n            }\n            return arrayList;\n        }\n    }\n```", "```py\npublic static Map<String, Set<Integer>> readBusinessLabels(String csv) throws IOException {\n        return readBusinessLabels(csv, DEFAULT_ROWS);\n    }\n\npublic static Map<String, Set<Integer>> readBusinessLabels(String csv, List<Integer> rows) throws IOException {\n        return readMetadata(csv, rows).stream()\n                .skip(1)\n                .map(l -> parseBusinessLabelsKv(l))\n                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));\n    }\n```", "```py\npublic static Map<Integer, String> readBusinessToImageLabels(String csv) throws IOException {\n        return readBusinessToImageLabels(csv, DEFAULT_ROWS);\n    }\n\npublic static Map<Integer, String> readBusinessToImageLabels(String csv, List<Integer> rows) throws IOException {\n        return readMetadata(csv, rows).stream()\n                .skip(1)\n                .map(l -> parseBusinessToImageLabelsKv(l))\n                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue(), useLastMerger()));\n    }\n```", "```py\npublic static Pattern patt_get_jpg_name = Pattern.compile(\"[0-9]\");\n```", "```py\npublic static List<Integer> getImgIdsFromBusinessId(Map<Integer, String> bizMap, List<String> businessIds) {\n        return bizMap.entrySet().stream().filter(x -> \n                 businessIds.contains(x.getValue())).map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n```", "```py\npublic static List<String> getImageIds(String photoDir, Map<Integer, String> businessMap, \n                                       List<String> businessIds) {\n        File d = new File(photoDir);\n        List<String> imgsPath = Arrays.stream(d.listFiles()).map(f -> \n                                f.toString()).collect(Collectors.toList());\n        boolean defaultBusinessMap = businessMap.size() == 1 && businessMap.get(-1).equals(\"-1\");\n        boolean defaultBusinessIds = businessIds.size() == 1 && businessIds.get(0).equals(\"-1\");\n        if (defaultBusinessMap || defaultBusinessIds) {\n            return imgsPath;\n        } else {\n            Map<Integer, String> imgsMap = imgsPath.stream()\n                    .map(x -> new AbstractMap.SimpleEntry<Integer, String>(extractInteger(x), x))\n                    .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));\n            List<Integer> imgsPathSub = imageFeatureExtractor.getImgIdsFromBusinessId(\n                                        businessMap, businessIds);\n            return imgsPathSub.stream().filter(x -> imgsMap.containsKey(x)).map(x -> imgsMap.get(x))\n                    .collect(Collectors.toList());\n        }\n    }\n```", "```py\npublic static Map<Integer, List<Integer>> processImages(List<String> imgs, int resizeImgDim, int nPixels) {\n        Function<String, AbstractMap.Entry<Integer, List<Integer>>> handleImg = x -> {\n            BufferedImage img = null;\n            try {\n                img = ImageIO.read(new File(x));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            img = makeSquare(img);\n            img = resizeImg(img, resizeImgDim, resizeImgDim);\n            List<Integer> value = image2gray(img);\n            if(nPixels != -1) {\n                value = value.subList(0, nPixels);\n            }\n            return new AbstractMap.SimpleEntry<Integer, List<Integer>>(extractInteger(x), value);\n        };\n\n        return imgs.stream().map(handleImg).filter(e -> !e.getValue().isEmpty())\n                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));\n    }\n```", "```py\nFeatureAndDataAligner alignedData = new FeatureAndDataAligner(dataMap, businessMap, Optional.*of*(labMap));\n```", "```py\nprivate Map<Integer, List<Integer>> dataMap;\nprivate Map<Integer, String> bizMap;\nprivate Optional<Map<String, Set<Integer>>> labMap;\nprivate List<Integer> rowindices;\n\npublic FeatureAndDataAligner(Map<Integer, List<Integer>> dataMap, Map<Integer, String> bizMap, Optional<Map<String, Set<Integer>>> labMap) {\n        this(dataMap, bizMap, labMap, dataMap.keySet().stream().collect(Collectors.toList()));\n    }\n```", "```py\npublic FeatureAndDataAligner(Map<Integer, List<Integer>> dataMap, Map<Integer, String> bizMap, Optional<Map<String, Set<Integer>>> labMap,List<Integer> rowindices) {\n        this.dataMap = dataMap;\n        this.bizMap = bizMap;\n        this.labMap = labMap;\n        this.rowindices = rowindices;\n    }\n```", "```py\npublic FeatureAndDataAligner(Map<Integer, List<Integer>> dataMap, Map<Integer, String> bizMap) {\n        this(dataMap, bizMap, Optional.empty(), dataMap.keySet().stream().collect(Collectors.toList()));\n    }\n```", "```py\npublic List<Triple<Integer, String, List<Integer>>> alignBusinessImgageIds(Map<Integer, List<Integer>> dataMap, Map<Integer, String> bizMap) {\n        return alignBusinessImgageIds(dataMap, bizMap, dataMap.keySet().stream().collect(Collectors.toList()));\n    }   \n```", "```py\npublic List<Triple<Integer, String, List<Integer>>> alignBusinessImgageIds(Map<Integer, List<Integer>> dataMap, Map<Integer, String> bizMap, List<Integer> rowindices) {\n        ArrayList<Triple<Integer, String, List<Integer>>> result = new ArrayList<>();\n        for (Integer pid : rowindices) {\n            Optional<String> imgHasBiz = Optional.ofNullable(bizMap.get(pid));\n            String bid = imgHasBiz.orElse(\"-1\");\n            if (dataMap.containsKey(pid) && imgHasBiz.isPresent()) {\n               result.add(new ImmutableTriple<>(pid, bid, dataMap.get(pid)));\n            }\n        }\n        return result;\n    }\n```", "```py\nprivate List<Quarta<Integer, String, List<Integer>, Set<Integer>>> alignLabels(Map<Integer, List<Integer>>   \n                                                                   dataMap, Map<Integer, String>             \n                                                                   bizMap,Optional<Map<String, \n Set<Integer>>> labMap,  \n                                                                   List<Integer> rowindices) {\n        ArrayList<Quarta<Integer, String, List<Integer>, Set<Integer>>> result = new ArrayList<>();\n        List<Triple<Integer, String, List<Integer>>> a1 = alignBusinessImgageIds(dataMap, \n                                                                                 bizMap, rowindices);\n        for (Triple<Integer, String, List<Integer>> p : a1) {\n            String bid = p.getMiddle();\n            Set<Integer> labs = Collections.emptySet();\n            if (labMap.isPresent() && labMap.get().containsKey(bid)) {\n                 labs = labMap.get().get(bid);\n            }\n            result.add(new Quarta<>(p.getLeft(), p.getMiddle(), p.getRight(), labs));\n        }\n        return result;\n    }\n```", "```py\npublic static class Quarta <A, B, C, D> {\n        public final A a;\n        public final B b;\n        public final C c;\n        public final D d;\n\n        public Quarta(A a, B b, C c, D d) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.d = d;\n        }\n    }\n```", "```py\n private volatile List<Quarta<Integer, String, List<Integer>, Set<Integer>>> _data = null;\n// pre-computing and saving data as a val so method does not need to re-compute each time it is called.\npublic List<Quarta<Integer, String, List<Integer>, Set<Integer>>> data() {\n        if (_data == null) {\n            synchronized (this) {\n                if (_data == null) {\n                    _data = alignLabels(dataMap, bizMap, labMap, rowindices);\n                }\n            }\n        }\n        return _data;\n    }\n```", "```py\n// getter functions\npublic List<Integer> getImgIds() {\n        return data().stream().map(e -> e.a).collect(Collectors.toList());\n    }\npublic List<String> getBusinessIds() {\n        return data().stream().map(e -> e.b).collect(Collectors.toList());\n    }\npublic List<List<Integer>> getImgVectors() {\n        return data().stream().map(e -> e.c).collect(Collectors.toList());\n    }\npublic List<Set<Integer>> getBusinessLabels() {\n        return data().stream().map(e -> e.d).collect(Collectors.toList());\n    }\npublic Map<String, Integer> getImgCntsPerBusiness() {\n        return getBusinessIds().stream().collect(Collectors.groupingBy(Function.identity())).entrySet()\n                .stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(), e.getValue().size()))\n                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()));\n    }\n```", "```py\npublic static DataSet makeDataSet(FeatureAndDataAligner alignedData, int bizClass) {\n        INDArray alignedXData = makeDataSetTE(alignedData);\n        List<Set<Integer>> labels = alignedData.getBusinessLabels();\n        float[][] matrix2 = labels.stream().map(x -> (x.contains(bizClass) ? new float[]{1, 0} \n                             : new float[]{0, 1})).toArray(float[][]::new);\n        INDArray alignedLabs = toNDArray(matrix2);\n        return new DataSet(alignedXData, alignedLabs);\n    }\n```", "```py\npublic static INDArray makeDataSetTE(FeatureAndDataAligner alignedData) {\n        List<List<Integer>> imgs = alignedData.getImgVectors();\n        double[][] matrix = new double[imgs.size()][];\n        for (int i = 0; i < matrix.length; i++) {\n            List<Integer> img = imgs.get(i);\n            matrix[i] = img.stream().mapToDouble(Integer::doubleValue).toArray();\n        }\n        return toNDArray(matrix);\n    }\n```", "```py\n// For converting floar matrix to INDArray\nprivate static INDArray toNDArray(float[][] matrix) {\n          return Nd4j.*create*(matrix);\n             }\n// For converting double matrix to INDArray\nprivate static INDArray toNDArray(double[][] matrix) {\n            return Nd4j.*create*(matrix);\n                  }\n```", "```py\nConvolutionLayer layer_0 = new ConvolutionLayer.Builder(6,6)\n            .nIn(nChannels)\n            .stride(2,2) // default stride(2,2)\n            .nOut(20) // # of feature maps\n            .dropOut(0.7) // dropout to reduce overfitting\n            .activation(Activation.*RELU*) // Activation: rectified linear units\n            .build();\n```", "```py\nSubsamplingLayer layer_1 = new SubsamplingLayer\n                .Builder(SubsamplingLayer.PoolingType.*MAX*)\n                .stride(2, 2)\n                .build();\n```", "```py\nConvolutionLayer layer_2= new ConvolutionLayer.Builder(6, 6)\n            .stride(2, 2) // nIn need not specified in later layers\n            .nOut(50)\n            .activation(Activation.*RELU*) // Activation: rectified linear units\n            .build();\n```", "```py\nSubsamplingLayer layer_3 = new SubsamplingLayer\n           .Builder(SubsamplingLayer.PoolingType.*MAX*)\n           .stride(2, 2)\n           .build();\n```", "```py\nDenseLayer layer_4 = new DenseLayer.Builder() // Fully connected layer\n               .nOut(500)\n               .dropOut(0.7) // dropout to reduce overfitting\n              .activation(Activation.*RELU*) // Activation: rectified linear units \n             .build();\n```", "```py\nOutputLayer layer_5 = new OutputLayer.Builder(LossFunctions.LossFunction.*XENT*)\n          .nOut(outputNum) // number of classes to be predicted\n          .activation(Activation.*SOFTMAX*)\n          .build();\n```", "```py\nconvolutionalFlat(numRows, numColumns, nChannels))\n```", "```py\nMultiLayerConfiguration conf = new NeuralNetConfiguration.Builder()\n           .seed(seed)a\n           .miniBatch(true) // for MultipleEpochsIterator\n           .optimizationAlgo(OptimizationAlgorithm.*STOCHASTIC_GRADIENT_DESCENT*)\n           .updater(new Adam(0.001)) // Aama for weight updater\n           .weightInit(WeightInit.*XAVIER*) //Xavier weight init\n           .list()\n                    .layer(0, layer_0)\n                    .layer(1, layer_1)\n                    .layer(2, layer_2)\n                    .layer(3, layer_3)\n                    .layer(4, layer_4)\n                   .layer(5, layer_5)\n            .setInputType(InputType.*convolutionalFlat*(numRows, numColumns, nChannels))\n            .backprop(true).pretrain(false)\n            .build();\n```", "```py\nlog.info(\"Train model....\");\nfor( int i=0; i<nepochs; i++ ){\n      model.fit(epochitTr);\n}\n```", "```py\nlog.info(\"Evaluate model....\");\nEvaluation eval = new Evaluation(outputNum)\n\nwhile (epochitTe.hasNext()) {\n       DataSet testDS = epochitTe.next(nbatch);\n       INDArray output = model.output(testDS.getFeatureMatrix());\n       eval.eval(testDS.getLabels(), output);\n}\n```", "```py\nSystem.*out*.println(eval.stats())\n>>>\n ==========================Scores========================================\n Accuracy: 0.5600\n Precision: 0.5584\n Recall: 0.5577\n F1 Score: 0.5926\n Precision, recall & F1: reported for positive class (class 1 - \"1\") only\n ========================================================================\n```", "```py\nif (!saveNN.isEmpty()) {\n      // model config\n      FileUtils.write(new File(saveNN + \".json\"), model.getLayerWiseConfigurations().toJson());\n      // model parameters\n      DataOutputStream dos = new DataOutputStream(Files.*newOutputStream*(Paths.*get*(saveNN + \".bin\")));\n      Nd4j.*write*(model.params(), dos);\n         }\n    log.info(\"****************Example finished********************\");\n}\n```", "```py\npublic void saveNN(MultiLayerNetwork model, String NNconfig, String NNparams) throws IOException {\n       // save neural network config\n       FileUtils.write(new File(NNconfig), model.getLayerWiseConfigurations().toJson());\n\n       // save neural network parms\n      DataOutputStream dos = new  DataOutputStream(Files.*newOutputStream*(Paths.*get*(NNparams)));        \n      Nd4j.*write*(model.params(), dos);\n  }\n```", "```py\npublic static MultiLayerNetwork loadNN(String NNconfig, String NNparams) throws IOException {\n        // get neural network config\n        MultiLayerConfiguration confFromJson = MultiLayerConfiguration\n                .fromJson(FileUtils.readFileToString(new File(NNconfig)));\n\n        // get neural network parameters\n        DataInputStream dis = new DataInputStream    (new FileInputStream(NNparams));\n        INDArray newParams = Nd4j.read(dis);\n\n        // creating network object\n        MultiLayerNetwork savedNetwork = new MultiLayerNetwork(confFromJson);\n        savedNetwork.init();\n        savedNetwork.setParameters(newParams);\n\n        return savedNetwork;\n    }\n```", "```py\npublic static INDArray scoreModel(MultiLayerNetwork model, INDArray ds) {\n        return model.output(ds);\n    }\n```", "```py\n/** Take model predictions from scoreModel and merge with alignedData*/\npublic static List<Pair<String, Double>> aggImgScores2Business(INDArray scores,\n                                         FeatureAndDataAligner alignedData) {\n        assert(scores.size(0) == alignedData.data().size());\n        ArrayList<Pair<String, Double>> result = new ArrayList<Pair<String, Double>>();\n\n        for (String x : alignedData.getBusinessIds().stream().distinct().collect(Collectors.toList())) {\n            //R irows = getRowIndices4Business(alignedData.getBusinessIds(), x);\n            List<String> ids = alignedData.getBusinessIds();\n            DoubleStream ret = IntStream.range(0, ids.size())\n                    .filter(i -> ids.get(i).equals(x))\n                    .mapToDouble(e -> scores.getRow(e).getColumn(1).getDouble(0,0));\n            double mean = ret.sum() / ids.size();\n            result.add(new ImmutablePair<>(x, mean));\n        }\n        return result;\n    }\n```", "```py\npublic static List<Pair<String, List<Double>>> SubmitObj(FeatureAndDataAligner alignedData,\n                                               String modelPath,\n                                               String model0,\n                                               String model1,\n                                               String model2,\n                                               String model3,\n                                               String model4,\n                                               String model5,\n                                               String model6,\n                                               String model7,\n                                               String model8) throws IOException {\n        List<String> models = Arrays.asList(model0, model1, \n                                            model2, model3, \n                                            model4, model5, \n                                            model6, model7, model8);\n        ArrayList<Map<String, Double>> big = new ArrayList<>();\n        for (String m : models) {\n            INDArray ds = makeND4jDataSets.makeDataSetTE(alignedData);\n            MultiLayerNetwork model = NetworkSaver.loadNN(modelPath + m + \".json\", \n                                                          modelPath + m + \".bin\");\n            INDArray scores = ModelEvaluation.scoreModel(model, ds);\n            List<Pair<String, Double>> bizScores = ModelEvaluation.\n                                                   aggImgScores2Business(scores, alignedData);\n            Map<String, Double> map = bizScores.stream().collect(Collectors.toMap(\n                                                                 e -> e.getKey(), e -> e.getValue()));\n            big.add(map);\n              }\n\n        // transforming the data structure above into a List for each bizID containing a Tuple (bizid, \n           List[Double]) where the Vector[Double] is the the vector of probabilities: \n        List<Pair<String, List<Double>>> result = new ArrayList<>();\n        Iterator<String> iter = alignedData.data().stream().map(e -> e.b).distinct().iterator();\n        while (iter.hasNext()) {\n            String x = iter.next();\n            result.add(new MutablePair(x, big.stream().map(x2 -> \n                                       x2.get(x)).collect(Collectors.toList())));\n        }\n        return result;\n    }\n```", "```py\npublic static void writeSubmissionFile(String outcsv, List<Pair<String, List<Double>>> phtoObj, double thresh) throws FileNotFoundException {\n        try (PrintWriter writer = new PrintWriter(outcsv)) {\n            writer.println(\"business_ids,labels\");\n            for (int i = 0; i < phtoObj.size(); i++) {\n                Pair<String, List<Double>> kv = phtoObj.get(i);\n                StringBuffer sb = new StringBuffer();\n                Iterator<Double> iter = kv.getValue().stream().filter(x -> x >= thresh).iterator();\n                for (int idx = 0; iter.hasNext(); idx++) {\n                    iter.next();\n                    if (idx > 0) {\n                        sb.append(' ');\n                    }\n                    sb.append(Integer.toString(idx));\n                }\n                String line = kv.getKey() + \",\" + sb.toString();\n                writer.println(line);\n            }\n        }\n    }\n```", "```py\npublic class YelpImageClassifier {\n    public static void main(String[] args) throws IOException {\n        Map<String, Set<Integer>> labMap = readBusinessLabels(\"Yelp/labels/train.csv\");        \n        Map<Integer, String> businessMap = readBusinessToImageLabels(\"Yelp/labels\n                                                                      /train_photo_to_biz_ids.csv\");\n        List<String> businessIds = businessMap.entrySet().stream().map(e -> \n                                                    e.getValue()).distinct().collect(Collectors.toList());\n        // 100 images\n        List<String> imgs = getImageIds(\"Yelp/images/train/\", businessMap, businessIds).subList(0, 100); \n        System.out.println(\"Image ID retreival done!\");\n\n        Map<Integer, List<Integer>> dataMap = processImages(imgs, 64);\n        System.out.println(\"Image processing done!\");\n\n        FeatureAndDataAligner alignedData = new FeatureAndDataAligner(dataMap, \n                                                                      businessMap, Optional.of(labMap));\n        //System.out.println(alignedData.data());\n        System.out.println(\"Feature extraction done!\");\n\n        // Training one model for one class at a time\n        CNNEpochs.trainModelEpochs(alignedData, 0, \"results/models/model0\"); \n        CNNEpochs.trainModelEpochs(alignedData, 1, \"results/models/model1\");\n        CNNEpochs.trainModelEpochs(alignedData, 2, \"results/models/model2\");\n        CNNEpochs.trainModelEpochs(alignedData, 3, \"results/models/model3\");\n        CNNEpochs.trainModelEpochs(alignedData, 4, \"results/models/model4\");\n        CNNEpochs.trainModelEpochs(alignedData, 5, \"results/models/model5\");\n        CNNEpochs.trainModelEpochs(alignedData, 6, \"results/models/model6\");\n        CNNEpochs.trainModelEpochs(alignedData, 7, \"results/models/model7\");\n        CNNEpochs.trainModelEpochs(alignedData, 8, \"results/models/model8\");\n\n        // processing test data for scoring\n        Map<Integer, String> businessMapTE = readBusinessToImageLabels(\"Yelp/labels\n                                                                        /test_photo_to_biz.csv\");\n        List<String> imgsTE = getImageIds(\"Yelp/images/test/\", businessMapTE,                                     \n                                  businessMapTE.values().stream()\n                                  .distinct().collect(Collectors.toList()))\n                                  .subList(0, 100);\n\n        Map<Integer, List<Integer>> dataMapTE = processImages(imgsTE, 64); // make them 64x64\n        FeatureAndDataAligner alignedDataTE = new FeatureAndDataAligner(dataMapTE, \n                                                  businessMapTE, Optional.empty());\n\n        // creating csv file to submit to kaggle (scores all models)\n        List<Pair<String, List<Double>>> Results = SubmitObj(alignedDataTE, \"results/models/\", \n                                                             \"model0\", \"model1\", \"model2\", \n                                                             \"model3\", \"model4\", \"model5\", \n                                                             \"model6\", \"model7\", \"model8\");\n        writeSubmissionFile(\"results/kaggleSubmission/kaggleSubmitFile.csv\", Results, 0.50);\n\n       // example of how to score just model\n        INDArray dsTE = makeND4jDataSets.makeDataSetTE(alignedDataTE);\n        MultiLayerNetwork model = NetworkSaver.loadNN(\"results/models/model0.json\", \n                                                      \"results/models/model0.bin\");\n        INDArray predsTE = ModelEvaluation.scoreModel(model, dsTE);\n        List<Pair<String, Double>> bizScoreAgg = ModelEvaluation\n                                                .aggImgScores2Business(predsTE, alignedDataTE);\n        System.out.println(bizScoreAgg);\n    }\n}\n```", "```py\nConvolutionLayer layer_0 = new ConvolutionLayer.Builder(6, 6)\n                .nIn(nChannels)\n                .stride(2, 2) // default stride(2,2)\n                .nOut(20) // # of feature maps\n                .dropOut(0.7) // dropout to reduce overfitting\n                .activation(Activation.RELU) // Activation: rectified linear units\n                .build();\n        SubsamplingLayer layer_1 = new SubsamplingLayer.Builder(SubsamplingLayer.PoolingType.MAX)\n                .stride(2, 2)\n                .build();\n        ConvolutionLayer layer_2 = new ConvolutionLayer.Builder(6, 6)\n                .stride(2, 2) // nIn need not specified in later layers\n                .nOut(50)\n                .activation(Activation.RELU) // Activation: rectified linear units\n                .build();\n        SubsamplingLayer layer_3 = new SubsamplingLayer.Builder(SubsamplingLayer.PoolingType.MAX)\n                .stride(2, 2)\n                .build();\n        DenseLayer layer_4 = new DenseLayer.Builder() // Fully connected layer\n                .nOut(500)\n                .dropOut(0.7) // dropout to reduce overfitting\n                .activation(Activation.RELU) // Activation: rectified linear units\n                .gradientNormalization(GradientNormalization.ClipElementWiseAbsoluteValue)\n                .gradientNormalizationThreshold(10)\n                .build();\n        OutputLayer layer_5 = new OutputLayer.Builder(LossFunctions.LossFunction.XENT)\n                .nOut(outputNum) // number of classes to be predicted\n                .gradientNormalization(GradientNormalization.ClipElementWiseAbsoluteValue)\n                .gradientNormalizationThreshold(10)\n                .activation(Activation.SOFTMAX)\n                .build();\n        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder().seed(seed).miniBatch(true)\n                .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT\n                .l2(0.001) // l2 reg on all layers\n                .updater(new AdaGrad(0.001))\n                .weightInit(WeightInit.XAVIER) // Xavier weight init\n                .list()\n                        .layer(0, layer_0)\n                        .layer(1, layer_1)\n                        .layer(2, layer_2)\n                        .layer(3, layer_3)\n                        .layer(4, layer_4)\n                         .layer(5, layer_5)\n                .setInputType(InputType.convolutionalFlat(numRows, numColumns, nChannels))\n                .backprop(true).pretrain(false) // Feedforward hence no pre-train.\n                .build();\n```", "```py\n//Print the number of parameters in the network (and for each layer)\nLayer[] layers = model.getLayers();\nint totalNumParams = 0;\nfor( int i=0; i<layers.length; i++ ){\n          int nParams = layers[i].numParams();\n          System.*out*.println(\"Number of parameters in layer \" + i + \": \" + nParams);\n          totalNumParams += nParams;\n        }\nSystem.*out*.println(\"Total number of network parameters: \" + totalNumParams);\n```", "```py\n>>>\n Number of parameters in layer 0: 740\n Number of parameters in layer 1: 0\n Number of parameters in layer 2: 36050\n Number of parameters in layer 3: 0\n Number of parameters in layer 4: 225500\n Number of parameters in layer 5: 1002\n Total number of network parameters: 263292\n```"]