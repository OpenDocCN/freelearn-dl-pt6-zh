["```py\nUserID::MovieID::Rating::Timestamp\n```", "```py\nMovieID::Title::Genres\n```", "```py\nUserID::Gender::Age::Occupation::Zip-code \n```", "```py\nSparkSession spark = new Builder()\n                  .master(\"local[*]\")\n                  .config(\"spark.sql.warehouse.dir\", \"temp/\")// change accordingly\n                  .appName(\"MovieRecommendation\")\n                  .getOrCreate();\n```", "```py\n// Read RatingsFile\nDataset<Row> df1 = spark.read()\n                .format(\"com.databricks.spark.csv\")\n                .option(\"inferSchemea\", \"true\")\n                .option(\"header\", \"true\")\n                .load(ratingsFile);\n\nDataset<Row> ratingsDF = df1.select(df1.col(\"userId\"), df1.col(\"movieId\"),\n                df1.col(\"rating\"), df1.col(\"timestamp\"));\nratingsDF.show(10);\n```", "```py\n// Read MoviesFile\nDataset<Row> df2 = spark.read()\n                .format(\"com.databricks.spark.csv\")\n                .option(\"inferSchema\", \"true\")\n                .option(\"header\", \"true\")\n                .load(movieFile);\n\nDataset<Row> moviesDF = df2.select(df2.col(\"movieId\"), df2.col(\"title\"), df2.col(\"genres\"));\nmoviesDF.show(10);\n```", "```py\nratingsDF.createOrReplaceTempView(\"ratings\");\nmoviesDF.createOrReplaceTempView(\"movies\");\n```", "```py\nlong numberOfRatings = ratingsDF.count();\nlong numberOfUsers = ratingsDF.select(ratingsDF.col(\"userId\")).distinct().count();\nlong numberOfMovies = ratingsDF.select(ratingsDF.col(\"movieId\")).distinct().count();\n\nString print = String.*format*(\"Got %d ratings from %d users on %d movies.\", numberOfRatings, numberOfUsers, numberOfMovies);\nSystem.*out*.println(print);\n```", "```py\nGot 100004 ratings from 671 users on 9066 movies.\n```", "```py\n// Get the max, min ratings along with the count of users who have rated a movie.\nDataset<Row> sqlDF = spark.sql(\n                \"SELECT movies.title, movierates.maxr, movierates.minr, movierates.cntu \"\n                        + \"FROM (SELECT \"\n                        + \"ratings.movieId, MAX(ratings.rating) AS maxr,\"\n                        + \"MIN(ratings.rating) AS minr, COUNT(distinct userId) AS cntu \"\n                        + \"FROM ratings \"\n                        + \"GROUP BY ratings.movieId) movierates \"\n                        + \"JOIN movies ON movierates.movieId=movies.movieId \"\n                        + \"ORDER BY movierates.cntu DESC\");\nsqlDF.show(10);\n```", "```py\n// Top 10 active users and how many times they rated a movie.\nDataset<Row> mostActiveUsersSchemaRDD = spark.sql(\n                \"SELECT ratings.userId, count(*) AS ct \"\n                        + \"FROM ratings \"\n                        + \"GROUP BY ratings.userId \"\n                        + \"ORDER BY ct DESC LIMIT 10\");\nmostActiveUsersSchemaRDD.show(10);\n```", "```py\n// Movies that user 668 rated higher than 4\nDataset<Row> userRating = spark.sql(\n                \"SELECT ratings.userId, ratings.movieId, ratings.rating, movies.title \"\n                        + \"FROM ratings JOIN movies \"\n                        + \"ON movies.movieId=ratings.movieId \"\n                        + \"WHERE ratings.userId=668 AND ratings.rating > 4\");\nuserRating.show(10);\n```", "```py\n//MovieLensFormaterWithMetaData.java\nprivate static String *inputfilepath**;* private static String *outputfilepath*;\n```", "```py\nString foldername = \"ml-1m\";\nString outFolder = \"outFolder\";\n```", "```py\nprivate static int *targetcolumn* = 0;\nprivate static String *deletecolumns* = \"3\";\n```", "```py\nprivate static String *separator* = \"::\";\nprivate static int *offset* = 0;\n```", "```py\nSet<Integer> deletecolumnsset = new HashSet<Integer>();\nMap<String, Integer> valueidmap = new HashMap<String, Integer>(); \n\n*targetcolumn* = 2; // movielens format\nString[] deletecolumnarr = *deletecolumns*.split(\";\"); \n\nfor(String deletecolumn : deletecolumnarr) { \n          deletecolumnsset.add(Integer.*parseInt*(deletecolumn));\n       }\n*inputfilepath* = foldername + File.*separator* + \"users.dat\"; \nReader fr = new FileReader(*inputfilepath*); \nBufferedReader br = new BufferedReader(fr); \n\nMap<Integer, String> usergenemap = new HashMap<Integer, String>();\nMap<Integer, String> useragemap = new HashMap<Integer, String>();\nMap<Integer, String> useroccupationmap = new HashMap<Integer, String>(); \n\nString line;\nwhile (br.ready()) {\n             line = br.readLine();\n             String[] arr = line.split(*separator*); \n             usergenemap.put(Integer.*parseInt*(arr[0]), arr[1]); \n             useragemap.put(Integer.*parseInt*(arr[0]), arr[2]);\n             useroccupationmap.put(Integer.*parseInt*(arr[0]), arr[3]);\n          } \nbr.close();\nfr.close();\n```", "```py\n*inputfilepath* = foldername + File.*separator* + \"movies.dat\"; \nfr = new FileReader(*inputfilepath*); \nbr = new BufferedReader(fr);\n\nMap<Integer, String> moviemap = new HashMap<Integer, String>();\n\nwhile (br.ready()) {\n              line = br.readLine(); \n              String[] arr = line.split(*separator*); \n               moviemap.put(Integer.*parseInt*(arr[0]), arr[2]); \n}\nbr.close();\nfr.close();\n```", "```py\ninputfilepath = foldername + File.separator + \"ratings.dat\";\noutputfilepath = outFolder + File.separator + \"ratings.libfm\";\nBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputfilepath)));\n\n        fr = new FileReader(inputfilepath);\n        br = new BufferedReader(fr);\n\n        while(br.ready()) {\n            line = br.readLine();\n            String[] arr = line.split(separator);\n            StringBuilder sb = new StringBuilder();\n            sb.append(arr[targetcolumn]);\n\n            int columnidx = 0;\n            int userid = Integer.parseInt(arr[0]);\n            int movieid = Integer.parseInt(arr[1]);\n\n            for(int i = 0; i < arr.length; i++) {\n                if(i != targetcolumn && !deletecolumnsset.contains(i)) {\n                    String useroritemid = Integer.toString(columnidx) + \" \" + arr[i];\n\n                    if(!valueidmap.containsKey(useroritemid)) {\n                        valueidmap.put(useroritemid, offset++);\n                    }\n\n                    sb.append(\" \");\n                    sb.append(valueidmap.get(useroritemid));\n                    sb.append(\":1\");\n\n                    columnidx++;\n                }\n```", "```py\n// Add attributes\nString gender = usergenemap.get(userid);\nString attributeid = \"The gender information \" + gender;\n\n if(!valueidmap.containsKey(attributeid)) {\n                valueidmap.put(attributeid, offset++);\n            }\n\n            sb.append(\" \");\n            sb.append(valueidmap.get(attributeid));\n            sb.append(\":1\");\n\n            String age = useragemap.get(userid);\n            attributeid = \"The age information \" + age;\n\n            if(!valueidmap.containsKey(attributeid)) {\n                valueidmap.put(attributeid, offset++);\n            }\n\n            sb.append(\" \");\n            sb.append(valueidmap.get(attributeid));\n            sb.append(\":1\");\n\n            String occupation = useroccupationmap.get(userid);\n            attributeid = \"The occupation information \" + occupation;\n\n            if(!valueidmap.containsKey(attributeid)) {\n                valueidmap.put(attributeid, offset++);\n            }\n\n            sb.append(\" \");\n            sb.append(valueidmap.get(attributeid));\n            sb.append(\":1\");\n\n            String movieclassdesc = moviemap.get(movieid);\n            String[] movieclassarr = movieclassdesc.split(\"\\\\|\");\n\n            for(String movieclass : movieclassarr) {\n                attributeid = \"The movie class information \" + movieclass;\n                if(!valueidmap.containsKey(attributeid)) {\n                    valueidmap.put(attributeid, offset++);\n                }\n\n                sb.append(\" \");\n                sb.append(valueidmap.get(attributeid));\n                sb.append(\":1\");\n}\n```", "```py\n//add metadata information, userid and movieid\nsb.append(\"#\");\nsb.append(userid);\nsb.append(\" \"+movieid);\nwriter.write(sb.toString());\nwriter.newLine();\n```", "```py\n//SplitDataWithMetaData.java\nprivate static String *ratinglibFM* = *formattedDataPath* + \"/\" + \"ratings.libfm\"; // input\nprivate static String *ratinglibFM_train* = *formattedDataPath* + \"/\" + \"ratings_train.libfm\"; // for traning\nprivate static String *ratinglibFM_test* = *formattedDataPath* + \"/\" + \"ratings_test.libfm\"; // for testing\nprivate static String *ratinglibFM_test_meta* = *formattedDataPath* +\"/\"+\"ratings_test.libfm.meta\";// metadata\nprivate static String *ratinglibFM_valid* = *formattedDataPath* + \"/\" + \"ratings_valid.libfm\"; // validation\n```", "```py\nprivate static String *formattedDataPath* = \"outFolder\";\n```", "```py\nReader fr = new FileReader(ratinglibFM);\nRandom ra = new Random();\n\nBufferedWriter trainwrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(ratinglibFM_train)));\n\nBufferedWriter testwrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(ratinglibFM_test)));\n\nBufferedWriter testmetawrite = new BufferedWriter(new OutputStreamWriter(new                       FileOutputStream(ratinglibFM_test_meta)));   \n\nBufferedWriter validwrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(ratinglibFM_valid)));\n\nBufferedReader br = new BufferedReader(fr);\nString line = null;\nint testline = 0;\n\nwhile(br.ready()) {\n       line = br.readLine();\n       String[] arr = line.split(\"#\");\n       String info = arr[0];\n\n       double dvalue = ra.nextDouble();\n       if(dvalue>0.9)\n            {\n             validwrite.write(info);\n             validwrite.newLine();\n            }\n\n       else if(dvalue <= 0.9 && dvalue>0.1) {\n                trainwrite.write(info);\n                trainwrite.newLine();\n         } else {\n                testwrite.write(info);\n                testwrite.newLine();\n           if(arr.length==2)\n                {\n                testmetawrite.write(arr[1] + \" \" + testline);\n                testmetawrite.newLine();\n                testline++;\n            }\n         }\n  }\n```", "```py\nbr.close();\nfr.close();\n\ntrainwrite.flush();\ntrainwrite.close();\n\ntestwrite.flush();\ntestwrite.close();\n\nvalidwrite.flush();\nvalidwrite.close();\n\ntestmetawrite.flush();\ntestmetawrite.close();\n```", "```py\nfinal String trainFile = *formattedDataPath*+ \"/\" + \"ratings_train.libfm\";\n```", "```py\nfinal String testFile = *formattedDataPath*+ \"/\" + \"ratings_test.libfm\";\n```", "```py\nfinal String testMetaFile = *formattedDataPath*+ \"/\" + \"ratings_test.libfm.meta\";\n```", "```py\nfinal String outputFile = *formattedDataPath*+ \"/\" + \"predict_output.txt\";\n```", "```py\nfinal String rLog = *outPut* + \"/\" + \"metrics_logs.txt\";\n```", "```py\nfinal String dimension = \"1,1,8\"; // tunable parameters\n```", "```py\nfinal String iterations = \"100\"; // tunable parameter\n```", "```py\nfinal String learnRate = \"0.01\"; // tunable and learnable parameter\n```", "```py\nfinal String regularization = \"0,0,0.1\";\n```", "```py\nfinal String stdDeviation = \"0.1\";\n```", "```py\nSystem.*out*.println(\"Loading train...t\");\nDataProvider train = new LibSVMDataProvider();\nProperties trainproperties = new Properties();\n\ntrainproperties.put(Constants.*FILENAME*, trainFile);\ntrain.load(trainproperties,false);\n\nSystem.*out*.println(\"Loading test... t\");\nDataProvider test = new LibSVMDataProvider();\nProperties testproperties = new Properties();\n\ntestproperties.put(Constants.*FILENAME*, testFile);\ntest.load(testproperties,false);\n```", "```py\nint num_all_attribute = Math.*max*(train.getFeaturenumber(), test.getFeaturenumber());\nDataMetaInfo meta = new DataMetaInfo(num_all_attribute);\nmeta.debug();\nDebug.*openConsole*();\n```", "```py\nFmModel fm = new FmModel();\n```", "```py\npublic FmModel()\n    {\n        num_factor = 0;\n        initmean = 0;\n        initstdev = 0.01;\n        reg0 = 0.0;\n        regw = 0.0;\n        regv = 0.0; \n        k0 = true;\n        k1 = true;\n    }\n```", "```py\npublic void init()\n    {\n        w0 = 0;\n        w = new double[num_attribute];\n        v = new DataPointMatrix(num_factor, num_attribute);\n        Arrays.fill(w, 0);\n        v.init(initmean, initstdev);\n        m_sum = new double[num_factor];\n        m_sum_sqr = new double[num_factor];\n    }\n```", "```py\nfm.num_attribute = num_all_attribute;\nfm.initstdev = Double.*parseDouble*(stdDeviation);\n```", "```py\nInteger[] dim = *getIntegerValues*(dimension);\nassert (dim.length == 3);\nfm.k0 = dim[0] != 0;\nfm.k1 = dim[1] != 0;\nfm.num_factor = dim[2];\n```", "```py\nstatic public Integer[] getIntegerValues(String parameter) {\n        Integer[] result = null;\n        String[] strresult = Util.tokenize(parameter, \",\");\n        if(strresult!=null && strresult.length>0) {\n            result = new Integer[strresult.length];\n            for(int i=0;i<strresult.length;i++) {\n                result[i] = Integer.parseInt(strresult[i]);\n            }\n        }\n        return result;\n    }\n```", "```py\nFmLearn fml = new FmLearnSgdElement();\n((FmLearnSgd) fml).num_iter = Integer.*parseInt*(iterations);\n\nfml.fm = fm;\nfml.max_target = train.getMaxtarget();\nfml.min_target = train.getMintarget();\nfml.meta = meta;\n```", "```py\nfml.task = TaskType.*TASK_REGRESSION*\n```", "```py\nDouble[] reg = *getDoubleValues*(regularization);\nassert ((reg.length == 3)); // should meet 3 way regularization\n\nfm.reg0 = reg[0];\nfm.regw = reg[1];\nfm.regv = reg[2];\n```", "```py\nFmLearnSgd fmlsgd = (FmLearnSgd) (fml);\n\nif (fmlsgd != null) {\n        Double[] lr = *getDoubleValues*(learnRate);\n        assert (lr.length == 1);\n        fmlsgd.learn_rate = lr[0];\n        Arrays.*fill*(fmlsgd.learn_rates, lr[0]);\n}\n```", "```py\nstatic public Double[] getDoubleValues(String parameter) {\n        Double[] result;\n        String[] strresult = Util.tokenize(parameter, \",\");\n        if(strresult!=null && strresult.length>0) {\n            result = new Double[strresult.length];\n            for(int i=0; i<strresult.length; i++) {\n                result[i] = Double.parseDouble(strresult[i]);\n            }\n        }\n        else {\n            result = new Double[0];\n        }\n        return result;\n    }\n```", "```py\nfml.learn(train, test);\n```", "```py\n//FmLearn.java\npublic abstract void learn(DataProvider train, DataProvider test) throws Exception;\n```", "```py\n//FmLearnSgdElement.java\npublic void learn(DataProvider train, DataProvider test)  throws Exception{\n        super.learn(train, test);\n        List<Double> iterationList=new ArrayList<Double>();\n        List<Double> trainList=new ArrayList<Double>();\n        List<Double> testList=new ArrayList<Double>();\n\n        // SGD\n        for(int i = 0; i < num_iter; i++) {\n            try\n            {\n                double iteration_time = Util.getusertime();\n                train.shuffle();\n                for(train.getData().begin(); !train.getData().end(); train.getData().next()) {\n                    double p = fm.predict(train.getData().getRow(), sum, sum_sqr);\n                    double mult = 0;\n\n                    if(task == TaskType.TASK_REGRESSION) {\n                        p = Math.min(max_target, p);\n                        p = Math.max(min_target, p);\n                        mult = -(train.getTarget()[train.getData().getRowIndex()]-p);\n                    } else if(task == TaskType.TASK_CLASSIFICATION) {\n                        mult = -train.getTarget()[train.getData().getRowIndex()]*\n                                (1.0-1.0/(1.0+Math.exp(-train.getTarget()[train.getData()\n                                .getRowIndex()]*p)));\n                    }                \n                    SGD(train.getData().getRow(), mult, sum);                    \n                }                \n                iteration_time = (Util.getusertime() - iteration_time);\n                double rmse_train = evaluate(train);\n                double rmse_test = evaluate(test);\n                iterationList.add((double)i);\n                testList.add(rmse_test);\n                trainList.add(rmse_train);\n\n                String print = String.format(\"#Iterations=%2d::  \n                               Train_RMSE=%-10.5f  Test_RMSE=%-10.5f\", i, rmse_train, rmse_test);\n                Debug.println(print);\n                if(log != null) {\n                    log.log(\"rmse_train\", rmse_train);\n                    log.log(\"time_learn\", iteration_time);\n                    log.newLine();\n                }\n            }\n            catch(Exception e)\n            {\n                throw new JlibfmRuntimeException(e);// Exception library for Java FM\n            }\n        }    \n        PlotUtil_Rating.plot(convertobjectArraytoDouble(iterationList.toArray()),\n                convertobjectArraytoDouble(testList.toArray()),\n                convertobjectArraytoDouble(trainList.toArray()));\n\n    }\n```", "```py\n// FmModel.java, we create a sparse matrix \npublic double predict(SparseRow x, double[] sum, double[] sum_sqr)\n    {\n        double result = 0;\n        if(k0) {    \n            result += w0;\n        }\n        if(k1) {\n            for(int i = 0; i < x.getSize(); i++) {\n                result += w[x.getData()[i].getId()] * x.getData()[i].getValue();\n            }\n        }\n        for(int f = 0; f < num_factor; f++) {\n            sum[f] = 0;\n            sum_sqr[f] = 0;\n            for(int i = 0; i < x.getSize(); i++) {\n                double d = v.get(f,x.getData()[i].getId()) * x.getData()[i].getValue();\n                sum[f] = sum[f]+d;\n                sum_sqr[f] = sum_sqr[f]+d*d;\n            }\n            result += 0.5 * (sum[f]*sum[f] - sum_sqr[f]);\n        }\n\n        return result;\n }\n```", "```py\nSystem.*out*.println(\"logging to \" + rLog);\nRLog rlog = new RLog(rLog);\nfml.log = rlog;\nfml.init();\nrlog.init();\nfm.debug();\nfml.debug();\n```", "```py\nString print = String.*format*(\"#Iterations=%s:: Train_RMSE=%-10.5f Test_RMSE=%-10.5f\", iterations, fml.evaluate(train), fml.evaluate(test));\nSystem.*out*.println(print);\n```", "```py\n>>> Loading train...\n Loading test...\n #attr=9794 #groups=1\n #attr_in_group[0]=9794\n logging to outFolder/output.txt\n num_attributes=9794\n use w0=true\n use w1=true\n dim v =8\n reg_w0=0.0\n reg_w=0.0\n reg_v=0.0\n init ~ N(0.0,0.1)\n num_iter=100\n task=TASK_REGRESSION\n min_target=1.0\n max_target=5.0\n learnrate=0.01\n learnrates=0.01,0.01,0.01\n #iterations=100\n #Iterations= 0:: Train_RMSE=0.92469 Test_RMSE=0.93231\n #Iterations= 1:: Train_RMSE=0.91460 Test_RMSE=0.92358\n #Iterations= 2:: Train_RMSE=0.91595 Test_RMSE=0.92535\n #Iterations= 3:: Train_RMSE=0.91238 Test_RMSE=0.92313\n ...\n #Iterations=98:: Train_RMSE=0.84275 Test_RMSE=0.88206\n #Iterations=99:: Train_RMSE=0.84068 Test_RMSE=0.87832\n```", "```py\n// prediction at the end\nString print = String.format(\"#Iterations=%s::  Train_RMSE=%-10.5f  Test_RMSE=%-10.5f\", iterations, fml.evaluate(train), fml.evaluate(test));\nSystem.out.println(print);\n\n// save prediction\nMap<Integer, String> ratingsMetaData = new HashMap<>();\nif(Files.exists(Paths.get(testMetaFile))) {\n            BufferedReader bufferedReader = new BufferedReader(new FileReader(testMetaFile));\n            String line;\n\n            while((line = bufferedReader.readLine()) != null) {\n                String[] splitLine = line.split(\"\\\\s+\");\n                if(splitLine.length > 0) {\n                    Integer indexKey = Integer.parseInt(splitLine[2]);\n                    String userIdmovieIdValue = splitLine[0] + \" \" +  splitLine[1];\n                    ratingsMetaData.put(indexKey, userIdmovieIdValue);\n                }\n            }\n        }\n\ndouble[] pred = new double[test.getRownumber()];\nfml.predict(test, pred);\nUtil.save(ratingsMetaData, pred, outputFile);\n\nString FILENAME = Constants.FILENAME;\n// Save the trained FM model \nfmlsgd.saveModel(FILENAME);\n```", "```py\n1 3408 4.40\n 1 2797 4.19\n 1 720 4.36\n 1 1207 4.66\n 2 1537 3.92\n 2 1792 3.39\n 2 1687 3.32\n 2 3107 3.55\n 2 3108 3.46\n 2 3255 3.65\n```", "```py\npublic static void plot(double[] iterationArray, double[] testArray, double[] trainArray) {\n    final XYSeriesCollection dataSet = new XYSeriesCollection();\n    addSeries(dataSet, iterationArray, testArray, \"Test MSE per iteration\");\n    addSeries(dataSet, iterationArray, trainArray, \"Training MSE per iteration\");\n\n    final JFreeChart chart = ChartFactory.createXYLineChart(\n            \"Training and Test error/iteration (1000 iterations)\", // chart title\n            \"Iteration\", // x axis label\n            \"MSE\", // y axis label\n            dataSet, // data\n            PlotOrientation.VERTICAL,\n            true, // include legend\n            true, // tooltips\n            false // urls\n    );\n\n    final ChartPanel panel = new ChartPanel(chart);\n    final JFrame f = new JFrame();\n    f.add(panel);\n    f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    f.pack();\n    f.setVisible(true);\n}\n```", "```py\nprivate static void addSeries (final XYSeriesCollection dataSet, double[] x, double[] y, final String label){\n    final XYSeries s = new XYSeries(label);\n    for(int j = 0; j < x.length; j++ ) s.add(x[j], y[j]);\n    dataSet.addSeries(s);\n}\n```", "```py\nfinal String folderPath = \"ml-1m\";\nfinal String indexPath = \"index\";\nfinal String userFileName = \"users.dat\";\nfinal String moviesFileName = \"movies.dat\";\nfinal String ratingsFileName = \"ratings.dat\";\nfinal String encodingUTF8 = \"UTF-8\";\n\nfinal String userDatPath = folderPath + \"/\" + userFileName;\nfinal String movieDatPath = folderPath + \"/\" + moviesFileName;\n```", "```py\nfinal String indexPath = \"index\";\nfinal String userIndexPath = indexPath + \"/\" + \"userIndex\";\nfinal String movieIndexPath = indexPath + \"/\" + \"movieIndex\";\n```", "```py\nString trainDataPath = indexPath + \"/ratings_train\";\nString testDataPath = indexPath + \"/ratings_test\";\nfinal String ratingsDatPath = folderPath + \"/\" + ratingsFileName;\n```", "```py\nFastUserIndex<Long> userIndex = SimpleFastUserIndex.*load*(UsersReader.*read*(userIndexPath, *lp*));\n```", "```py\nFastItemIndex<Long> itemIndex = SimpleFastItemIndex.*load*(ItemsReader.*read*(movieIndexPath, *lp*));\n```", "```py\nFastPreferenceData<Long, Long> trainData = SimpleFastPreferenceData.*load*(SimpleRatingPreferencesReader.*get*().read(trainDataPath, *lp*, *lp*), userIndex, itemIndex);\n\nFastPreferenceData<Long, Long> testData = SimpleFastPreferenceData.*load*(SimpleRatingPreferencesReader.*get*().read(testDataPath, *lp*, *lp*), userIndex, itemIndex);\n```", "```py\nif (!Files.*exists*(Paths.*get*(userIndexPath))) {\n     *createIndexFromFile*(userDatPath, encodingUTF8, userIndexPath);\n}\n\nif (!Files.*exists*(Paths.*get*(movieIndexPath))) {\n *createIndexFromFile*(movieDatPath, encodingUTF8, movieIndexPath);\n}\n```", "```py\nstatic void createIndexFromFile(String fileReadPath, String encodings, String fileWritePath) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\n                        fileReadPath), Charset.forName(encodings)));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(\n                        new FileOutputStream(fileWritePath)));\n\n        String line;\n        while((line = bufferedReader.readLine()) != null) {\n            StringBuilder builder = new StringBuilder();\n            String[] lineArray = line.split(\"::\");\n            builder.append(lineArray[0]);\n            writer.write(builder.toString());\n            writer.newLine();\n        }\n\n        writer.flush();\n\n        bufferedReader.close();\n        writer.close();\n    }\n```", "```py\nif ( !Files.*exists*(Paths.*get*(trainDataPath))) {\n *generateTrainAndTestDataSet*(ratingsDatPath, trainDataPath, testDataPath);\n}\n```", "```py\nstatic void generateTrainAndTestDataSet(String ratingsDatPath, String trainDataPath, String testDataPath) throws IOException {\n        BufferedWriter writerTrain = new BufferedWriter(new OutputStreamWriter(\n                        new FileOutputStream(trainDataPath)));\n\n        BufferedWriter writerTest = new BufferedWriter(new OutputStreamWriter(\n                        new FileOutputStream(testDataPath)));\n\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(ratingsDatPath));\n        List<String> dummyData = new ArrayList<>();\n        String line;\n\n        while((line = bufferedReader.readLine()) != null) {\n            String removeDots = line.replaceAll(\"::\", \"\\t\");\n            dummyData.add(removeDots);\n        }\n\n        bufferedReader.close();\n\n        Random generator = new Random();\n        int dataSize = dummyData.size();\n        int trainDataSize = (int)(dataSize * (2.0 / 3.0));\n        int i = 0;\n\n        while(i < trainDataSize){\n            int random = generator.nextInt(dummyData.size()-0) + 0;\n            line = dummyData.get(random);\n            dummyData.remove(random);\n            writerTrain.write(line);\n            writerTrain.newLine();\n            i++;\n        }\n\n        int j = 0;\n        while(j < (dataSize - trainDataSize)){\n            writerTest.write(dummyData.get(j));\n            writerTest.newLine();\n            j++;\n        }\n\n        writerTrain.flush();\n        writerTrain.close();\n\n        writerTest.flush();\n        writerTest.close();\n    }\n```", "```py\nMap<String, Supplier<Recommender<Long, Long>>> recMap = new HashMap<>();\n```", "```py\n// Use Factorisation machine that uses RMSE-like loss with balanced sampling of negative instances:\nString outFileName = \"outFolder/Ranking_RMSE.txt\";\nrecMap.put(outFileName, Unchecked.supplier(() -> {\n            double negativeProp = 2.0D;\n\n            FMData fmTrain = new OneClassPreferenceFMData(trainData, negativeProp);\n            FMData fmTest = new OneClassPreferenceFMData(testData, negativeProp);\n\n            double learnRate = 0.01D; // Learning Rate\n            int numIter = 10; // Number of Iterations\n            double sdev = 0.1D;\n            double regB = 0.01D;\n\n            double[] regW = new double[fmTrain.numFeatures()];\n            Arrays.fill(regW, 0.01D);\n            double[] regM = new double[fmTrain.numFeatures()];\n\n            Arrays.fill(regM, 0.01D);\n            int K = 100;\n\n            // returns enclosed FM\n FM fm = new FM(fmTrain.numFeatures(), K, new Random(), sdev);\n            (new PointWiseGradientDescent(learnRate, numIter, PointWiseError.rmse(), \n                                          regB, regW, regM)).learn(fm, fmTrain, fmTest);\n             // From general purpose factorization machines to preference FM for user-preference  \n            PreferenceFM<Long, Long> prefFm = new PreferenceFM<Long, Long>(userIndex, itemIndex, fm);\n\n            return new FMRecommender<Long, Long>(prefFm);\n        }));\n```", "```py\nSet<Long> targetUsers = testData.getUsersWithPreferences().collect(Collectors.*toSet*());\n//Format of the recommendation generated by the FM recommender model as <user, prediction)\nRecommendationFormat<Long, Long> format = new SimpleRecommendationFormat<>(*lp*, *lp*);\nFunction<Long, IntPredicate> filter = FastFilters.*notInTrain*(trainData);\nint maxLength = 100;\n```", "```py\n// Generate recommendations and print it based on the format.\nRecommenderRunner<Long, Long> runner = new FastFilterRecommenderRunner<>(userIndex, itemIndex, targetUsers.stream(), filter, maxLength);\n\n recMap.forEach(Unchecked.biConsumer((name, recommender) -> {\n            System.out.println(\"Ranking prediction is ongoing...\");\n            System.out.println(\"Result will be saved at \" + name);\n            try(RecommendationFormat.Writer<Long, Long> writer = format.getWriter(name)) {\n                runner.run(recommender.get(), writer);\n            }\n        }));\n```", "```py\n>>\n Ranking prediction is ongoing...\n Result will be saved at outFolder/Ranking_RMSE.txt\n INFO: iteration n = 1 t = 3.92s\n INFO: iteration n = 2 t = 3.08s\n INFO: iteration n = 3 t = 2.88s\n INFO: iteration n = 4 t = 2.84s\n INFO: iteration n = 5 t = 2.84s\n INFO: iteration n = 6 t = 2.88s\n INFO: iteration n = 7 t = 2.87s\n INFO: iteration n = 8 t = 2.86s\n INFO: iteration n = 9 t = 2.94s\n ...\n INFO: iteration n = 100 t = 2.87s\n Graph plotting...\n```", "```py\n944 2396 0.9340957389234708\n 944 593 0.9299994477666256\n 944 1617 0.9207678675263278\n 944 50 0.9062805385053954\n 944 1265 0.8740234972054955\n 944 589 0.872143533435846\n 944 480 0.8659624750023733\n 944 2028 0.8649344355656503\n 944 1580 0.8620307480644472\n 944 2336 0.8576568651679782\n 944 1196 0.8570902991702303\n```", "```py\npublic static void plot(double[] iterationArray, double[] timeArray, String chart_type, int iter) {\n        String series = null;\n        String title = null;\n        String x_axis = null;\n        String y_axis = null;\n\n        if(chart_type ==\"MSE\"){        \n            series = \"MSE per Iteration (\" + iter + \" iterations)\";\n            title = \"MSE per Iteration (\" + iter + \" iterations)\";\n            x_axis = \"Iteration\";\n            y_axis = \"MSE\";\n        }else {\n            series = \"Time per Iteration (\" + iter + \" iterations)\";\n            title = \"Time per Iteration (\" + iter + \" iterations)\";\n            x_axis = \"Iteration\";\n            y_axis = \"Time\";            \n        }\n            final XYSeriesCollection dataSet = new XYSeriesCollection();\n            addSeries(dataSet, iterationArray, timeArray, series);\n\n            final JFreeChart chart = ChartFactory.createXYLineChart(\n                    title, // chart title\n                    x_axis, // x axis label\n                    y_axis, // y axis label\n                    dataSet, // data\n                    PlotOrientation.VERTICAL,\n                    true, // include legend\n                    true, // tooltips\n                    false // urls\n                    );\n\n        final ChartPanel panel = new ChartPanel(chart);\n        final JFrame f = new JFrame();\n        f.add(panel);\n        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n    }\n```", "```py\n//PointWiseGradientDescent.java\nList<Double> timeList = new ArrayList<Double>();\nList<Double> errList = new ArrayList<Double>();\n```", "```py\niter = t;\nlong time1 = System.*nanoTime*() - time0;\niterationList.add((double)iter);\ntimeList.add((double)time1 / 1_000_000_000.0);\nerrList.add(error(fm, test));\n```", "```py\nPlotUtil_Rank.*plot*(convertobjectArraytoDouble(iterationList.toArray()),     convertobjectArraytoDouble(errList.toArray()), \"MSE\", iter); \n\nPlotUtil_Rank.*plot*(convertobjectArraytoDouble(iterationList.toArray()), convertobjectArraytoDouble(timeList.toArray()), \"TIME\", iter);\n```", "```py\npublic double [] convertobjectArraytoDouble(Object[] objectArray){\n double[] doubleArray = newdouble[objectArray.length];\n               //Double[ ]doubleArray=new Double();\n for(int i = 0; i < objectArray.length; i++){\n                   Object object = objectArray[i]; \n                   String string = object.toString(); double dub = Double.*valueOf*(string).doubleValue();\n                   doubleArray[i] = dub;\n                       }\n return doubleArray;\n     }\n```", "```py\nString FILENAME = Constants.FILENAME;\n// Save the trained FM model \nfmlsgd.saveModel(FILENAME);\n```", "```py\npublic void saveModel(String FILENAME) throws Exception\n    {\n        FILENAME = Constants.FILENAME;\n        FileOutputStream fos = null;\n        DataOutputStream dos = null;        \n        try {      \n            fos = new FileOutputStream(FILENAME);\n            dos = new DataOutputStream(fos);\n            dos.writeBoolean(fm.k0);\n            dos.writeBoolean(fm.k1);\n            dos.writeDouble(fm.w0);\n            dos.writeInt(fm.num_factor);\n            dos.writeInt(fm.num_attribute);\n            dos.writeInt(task.ordinal());\n            dos.writeDouble(max_target);\n            dos.writeDouble(min_target);\n\n            for(int i=0;i<fm.num_attribute;i++)\n            {\n                dos.writeDouble(fm.w[i]);\n            }\n\n            for(int i=0;i<fm.num_factor;i++)\n            {\n                dos.writeDouble(fm.m_sum[i]);\n            }\n\n            for(int i=0;i<fm.num_factor;i++)\n            {\n                dos.writeDouble(fm.m_sum_sqr[i]);\n            }\n\n            for(int i_1 = 0; i_1 < fm.num_factor; i_1++) {\n                for(int i_2 = 0; i_2 < fm.num_attribute; i_2++) {                    \n                    dos.writeDouble(fm.v.get(i_1,i_2));\n                }\n            }\n\n            dos.flush();\n        }\n        catch(Exception e) {\n            throw new JlibfmRuntimeException(e);\n        } finally {          \n             if(dos!=null)\n                dos.close();\n             if(fos!=null)\n                fos.close();\n        }\n    }\n```", "```py\npublic void restoreModel(String FILENAME) throws Exception\n    {\n        FILENAME = Constants.FILENAME;\n        InputStream is = null;\n        DataInputStream dis = null;        \n        try {      \n            is = new FileInputStream(FILENAME);          \n            dis = new DataInputStream(is);\n\n            fm.k0 = dis.readBoolean();\n            fm.k1 = dis.readBoolean();\n            fm.w0 = dis.readDouble();\n            fm.num_factor = dis.readInt();\n            fm.num_attribute = dis.readInt();\n\n            if(dis.readInt() == 0)\n            {\n               task = TaskType.TASK_REGRESSION;\n            }\n            else\n            {\n               task = TaskType.TASK_CLASSIFICATION;\n            }\n\n            max_target = dis.readDouble();\n            min_target = dis.readDouble();\n\n            fm.w = new double[fm.num_attribute];\n\n            for(int i=0;i<fm.num_attribute;i++)\n            {\n                fm.w[i] = dis.readDouble();\n            }\n\n            fm.m_sum = new double[fm.num_factor];\n            fm.m_sum_sqr = new double[fm.num_factor];\n\n            for(int i=0;i<fm.num_factor;i++)\n            {\n               fm.m_sum[i] = dis.readDouble();\n            }\n\n            for(int i=0;i<fm.num_factor;i++)\n            {\n                fm.m_sum_sqr[i] = dis.readDouble();\n            }\n\n            fm.v = new DataPointMatrix(fm.num_factor, fm.num_attribute);\n\n            for(int i_1 = 0; i_1 < fm.num_factor; i_1++) {\n                for(int i_2 = 0; i_2 < fm.num_attribute; i_2++) {        \n                    fm.v.set(i_1,i_2, dis.readDouble());\n                }\n            }\n\n        }\n        catch(Exception e) {\n            throw new JlibfmRuntimeException(e);\n        } finally {          \n             if(dis!=null)\n                dis.close();\n             if(is!=null)\n                is.close();\n        }\n    }\n```"]