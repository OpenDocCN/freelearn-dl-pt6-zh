["```py\noriginal_image = tf.placeholder(tf.float32, (None, 32, 32, 3))\nresized_image = tf.image.resize_images(original_imag, (227, 227))\n```", "```py\n#Refer AlexNet implementation code, returns last fully connected layer\nfc7 = AlexNet(resized, feature_extract=True)\nshape = (fc7.get_shape().as_list()[-1], 43)\nfc8_weight = tf.Variable(tf.truncated_normal(shape, stddev=1e-2))\nfc8_b = tf.Variable(tf.zeros(43))\nlogits = tf.nn.xw_plus_b(fc7, fc8_weight, fc8_b)\nprobs = tf.nn.softmax(logits)\n```", "```py\n#import VGG16 network model and other necessary libraries \n\nfrom keras.applications.vgg16 import VGG16\nfrom keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\nimport numpy as np\n\n#Instantiate VGG16 and returns a vgg16 model instance \nvgg16_model = VGG16(weights='imagenet', include_top=False) \n#include_top: whether to include the 3 fully-connected layers at the top of the network.\n#This has to be True for classification and False for feature extraction. Returns a model instance\n#weights:'imagenet' means model is pre-training on ImageNet data.\nmodel = VGG16(weights='imagenet', include_top=True)\nmodel.summary()\n\n#image file name to classify\nimage_path = 'jumping_dolphin.jpg'\n#load the input image with keras helper utilities and resize the image. \n#Default input size for this model is 224x224 pixels.\nimg = image.load_img(image_path, target_size=(224, 224))\n#convert PIL (Python Image Library??) image to numpy array\nx = image.img_to_array(img)\nprint (x.shape)\n\n#image is now represented by a NumPy array of shape (224, 224, 3),\n# but we need to expand the dimensions to be (1, 224, 224, 3) so we can\n# pass it through the network -- we'll also preprocess the image by\n# subtracting the mean RGB pixel intensity from the ImageNet dataset\n#Finally, we can load our Keras network and classify the image:\n\nx = np.expand_dims(x, axis=0)\nprint (x.shape)\n\npreprocessed_image = preprocess_input(x)\n\npreds = model.predict(preprocessed_image)\nprint('Prediction:', decode_predictions(preds, top=2)[0])\n```"]