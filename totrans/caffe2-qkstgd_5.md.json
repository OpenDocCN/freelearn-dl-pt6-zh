["```py\n$ sudo pip install onnx\n```", "```py\n$ python -c \"import onnx\"\n```", "```py\nstatic const char* Relu_ver6_doc = R\"DOC(\n    Relu takes one input data (Tensor<T>) and produces one output data\n    (Tensor<T>) where the rectified linear function, y = max(0, x), is \n    applied to the tensor elementwise.\n    )DOC\";\n\nONNX_OPERATOR_SET_SCHEMA(\n    Relu,\n    6,\n    OpSchema()\n        .SetDoc(Relu_ver6_doc)\n        .Input(0, \"X\", \"Input tensor\", \"T\")\n        .Output(0, \"Y\", \"Output tensor\", \"T\")\n        .TypeConstraint(\n            \"T\",\n            {\"tensor(float16)\", \"tensor(float)\", \"tensor(double)\"},\n            \"Constrain input and output types to float tensors.\")\n        .TypeAndShapeInferenceFunction(propagateShapeAndTypeFromFirstInput));\n```", "```py\n#define ONNX_OPERATOR_SET_SCHEMA(name, ver, impl) \\\nONNX_OPERATOR_SET_SCHEMA_EX(name, Onnx, ONNX_DOMAIN, ver, true, impl)\n```", "```py\nconst std::unordered_map<std::string, std::string>&\nOnnxExporter::get_renamed_operators() const {\n  const static std::unordered_map<std::string, std::string> kRenamedOperators{\n      {\"SpatialBN\", \"BatchNormalization\"},\n      {\"Conv1D\", \"Conv\"},\n      {\"Conv2D\", \"Conv\"},\n      {\"Conv3D\", \"Conv\"},\n      {\"ConvTranspose1D\", \"ConvTranspose\"},\n      {\"ConvTranspose2D\", \"ConvTranspose\"},\n      {\"ConvTranspose3D\", \"ConvTranspose\"},\n      {\"MaxPool1D\", \"MaxPool\"},\n      {\"MaxPool2D\", \"MaxPool\"},\n      {\"MaxPool3D\", \"MaxPool\"},\n      {\"AveragePool1D\", \"AveragePool\"},\n      {\"AveragePool2D\", \"AveragePool\"},\n      {\"AveragePool3D\", \"AveragePool\"}};\n  return kRenamedOperators;\n}\n```", "```py\n./export_to_onnx.py predict_net.pb init_net.pb alexnet.onnx\n```", "```py\nimport onnx import caffe2.python.onnx.frontend from caffe2.proto import caffe2_pb2\n```", "```py\nINPUT_NAME = \"data\"\nINPUT_SHAPE = (1, 3, 227, 227)\n```", "```py\n# Read Caffe2 predict and init model files to protobuf\n\npredict_net = caffe2_pb2.NetDef()\nwith open(predict_net_fpath, \"rb\") as f:\n    predict_net.ParseFromString(f.read())\n\ninit_net = caffe2_pb2.NetDef()\nwith open(init_net_fpath, \"rb\") as f:\n    init_net.ParseFromString(f.read())\n```", "```py\n# Network input type, shape and name\n\ndata_type = onnx.TensorProto.FLOAT\nvalue_info = {INPUT_NAME: (data_type, INPUT_SHAPE)}\n```", "```py\n# Convert Caffe2 model protobufs to ONNX\n\nonnx_model = caffe2.python.onnx.frontend.caffe2_net_to_onnx_model(\n    predict_net,\n    init_net,\n    value_info,\n)\n```", "```py\n# Write ONNX protobuf to file\n\nprint(\"Writing ONNX model to: \" + onnx_model_fpath)\nwith open(onnx_model_fpath, \"wb\") as f:\n    f.write(onnx_model.SerializeToString())\n```", "```py\n#!/usr/bin/env python2\n\n\"\"\"Script to convert Caffe2 model files to ONNX format.\n\nInput is assumed to be named \"data\" and of dims (1, 3, 227, 227)\n\"\"\"\n\n# Std\nimport sys\n\n# Ext\nimport onnx\nimport caffe2.python.onnx.frontend\nfrom caffe2.proto import caffe2_pb2\n\nINPUT_NAME = \"data\"\nINPUT_SHAPE = (1, 3, 227, 227)\n\ndef main():\n\n    # Check if user provided all required inputs\n    if len(sys.argv) != 4:\n        print(__doc__)\n        print(\"Usage: \" + sys.argv[0] + \" <path/to/caffe2/predict_net.pb> <path/to/caffe2/init_net.pb> <path/to/onnx_output.pb>\")\n        return\n\n    predict_net_fpath = sys.argv[1]\n    init_net_fpath = sys.argv[2]\n    onnx_model_fpath = sys.argv[3]\n\n    # Read Caffe2 model files to protobuf\n\n    predict_net = caffe2_pb2.NetDef()\n    with open(predict_net_fpath, \"rb\") as f:\n        predict_net.ParseFromString(f.read())\n\n    init_net = caffe2_pb2.NetDef()\n    with open(init_net_fpath, \"rb\") as f:\n        init_net.ParseFromString(f.read())\n\n    print(\"Input Caffe2 model name: \" + predict_net.name)\n\n    # Network input type, shape and name\n\n    data_type = onnx.TensorProto.FLOAT\n    value_info = {INPUT_NAME: (data_type, INPUT_SHAPE)}\n\n    # Convert Caffe2 model protobufs to ONNX\n\n    onnx_model = caffe2.python.onnx.frontend.caffe2_net_to_onnx_model(\n        predict_net,\n        init_net,\n        value_info,\n    )\n\n    # Write ONNX protobuf to file\n\n    print(\"Writing ONNX model to: \" + onnx_model_fpath)\n    with open(onnx_model_fpath, \"wb\") as f:\n        f.write(onnx_model.SerializeToString())\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n# Std\nimport PIL.Image\nimport json\nimport sys\n\n# Ext\nimport numpy as np\nfrom caffe2.python import workspace\nimport onnx\nimport caffe2.python.onnx.backend\n```", "```py\ndef prepare_input_image(img_fpath):\n    \"\"\"Read and prepare input image as AlexNet input.\"\"\"\n\n    # Read input image as 3-channel 8-bit values\n    pil_img = PIL.Image.open(sys.argv[1])\n\n    # Resize to AlexNet input size\n    res_img = pil_img.resize((IMG_SIZE, IMG_SIZE), PIL.Image.LANCZOS)\n\n    # Convert to NumPy array and float values\n    img = np.array(res_img, dtype=np.float32)\n\n    # Change HWC to CHW\n    img = img.swapaxes(1, 2).swapaxes(0, 1)\n\n    # Change RGB to BGR\n    img = img[(2, 1, 0), :, :]\n\n    # Mean subtraction\n    img = img - MEAN\n\n    # Change CHW to NCHW by adding batch dimension at front\n    img = img[np.newaxis, :, :, :]\n\n    return img\n```", "```py\nmodel = onnx.load(\"alexnet.onnx\")\n```", "```py\ndef predict_img_class(onnx_model, img):\n    \"\"\"Get image class determined by network.\"\"\"\n\n    results = caffe2.python.onnx.backend.run_model(onnx_model, [img])\n    class_index = np.argmax(results[0])\n    class_prob = results[0][0, class_index]\n\n    imgnet_classes = json.load(open(\"imagenet1000.json\"))\n    class_name = imgnet_classes[class_index]\n\n    return class_index, class_name, class_prob\n```", "```py\n$ python /usr/local/lib/python2.7/dist-packages/onnx/tools/net_drawer.py --input alexnet.onnx --output alexnet.dot\n```", "```py\n$ dot alexnet.dot -Tpng -o alexnet.png\n```"]