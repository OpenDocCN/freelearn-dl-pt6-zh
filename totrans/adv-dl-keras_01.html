<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introducing Advanced Deep Learning with Keras"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introducing Advanced Deep Learning with Keras</h1></div></div></div><p>In this first chapter, we will introduce the three deep learning artificial neural networks that we will be using throughout the book. These deep learning models are MLPs, CNNs, and RNNs, which are the building blocks to the advanced deep learning topics covered in this book, such as Autoencoders and GANs.</p><p>Together, we'll implement these deep learning models using the Keras library in this chapter. We'll start by looking at why Keras is an excellent choice as a tool for us. Next, we'll dig into the installation and implementation details within the three deep learning models.</p><p>This chapter will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Establish why the Keras library is a great choice to use for advanced deep learning</li><li class="listitem" style="list-style-type: disc">Introduce MLPs, CNNs, and RNNs – the core building blocks of most advanced deep learning models, which we'll be using throughout this book</li><li class="listitem" style="list-style-type: disc">Provide examples of how to implement MLPs, CNNs, and RNNs using Keras and TensorFlow</li><li class="listitem" style="list-style-type: disc">Along the way, start to introduce important deep learning concepts, including optimization, regularization, and loss function</li></ul></div><p>By the end of this chapter, we'll have the fundamental deep learning models implemented using Keras. In the next chapter, we'll get into the advanced deep learning topics that build on these foundations, such as Deep Networks, Autoencoders, and GANs.</p><div class="section" title="Why is Keras the perfect deep learning library?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Why is Keras the perfect deep learning library?</h1></div></div></div><p>Keras [<span class="emphasis"><em>Chollet, François. "Keras (2015)." (2017)</em></span>] is a<a id="id0" class="indexterm"/> popular deep learning library with over 250,000 developers at the time of writing, a number that is more than doubling every year. Over 600 contributors actively maintain it. Some of the examples we'll use in this book have been contributed to the official Keras GitHub repository. Google's <span class="strong"><strong>TensorFlow</strong></span>, a popular open source deep learning library, uses Keras as a high-level API to its library. In the industry, Keras is used by major technology companies like <a id="id1" class="indexterm"/>Google, Netflix, Uber, and NVIDIA. In this chapter, we introduce how to use <span class="strong"><strong>Keras Sequential API</strong></span>.</p><p>We have chosen Keras as our tool of choice to work within this book because Keras is a library dedicated to accelerating the implementation of deep learning models. This makes Keras ideal for when we want to be practical and hands-on, such as when we're exploring the advanced deep learning concepts in this book. Because Keras is intertwined with deep learning, it is essential to learn the key concepts of deep learning before someone can maximize the use of Keras libraries.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note01"/>Note</h3><p>All examples in this book can be found on GitHub at the following link: <a class="ulink" href="https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras">https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras</a>.</p></div></div><p>Keras is a deep learning library that enables us to build and train models efficiently. In the library, layers are connected to <a id="id2" class="indexterm"/>one another like pieces of Lego, resulting in a model that is clean and easy to understand. Model training is straightforward requiring only data, a number of epochs of training, and metrics to monitor. The end result is that most deep learning models can be implemented with a significantly smaller number of lines of code. By using Keras, we'll gain productivity by saving time in code implementation which can instead be spent on more critical tasks such as formulating better deep learning algorithms. We're combining Keras with deep learning, as it offers increased efficiency when introduced with the three deep learning networks that we will introduce in the following sections of this chapter.</p><p>Likewise, Keras is ideal for the rapid implementation of deep learning models, like the ones that we will be using in this book. Typical models can be built in few lines of code using the <span class="strong"><strong>Sequential Model API</strong></span>. However, do not be misled by<a id="id3" class="indexterm"/> its simplicity. Keras can also build more advanced and complex models using its API and <code class="literal">Model</code> and <code class="literal">Layer</code> classes which can be customized to satisfy unique requirements. Functional API supports building graph-like models, layers reuse, and models that are behaving like Python functions. Meanwhile, <code class="literal">Model</code> and <code class="literal">Layer</code> classes provide a framework for implementing uncommon or experimental deep learning models and layers.</p><div class="section" title="Installing Keras and TensorFlow"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec05"/>Installing Keras and TensorFlow</h2></div></div></div><p>Keras is not<a id="id4" class="indexterm"/> an independent deep learning library. As shown in <span class="emphasis"><em>Figure 1.1.1</em></span>, it is built on<a id="id5" class="indexterm"/> top of another deep learning library or backend. This could be Google's <span class="strong"><strong>TensorFlow</strong></span>, MILA's <span class="strong"><strong>Theano</strong></span> or Microsoft's <span class="strong"><strong>CNTK</strong></span>. Support for Apache's <span class="strong"><strong>MXNet</strong></span> is nearly completed. We'll be testing examples in this book on a <span class="strong"><strong>TensorFlow backend using Python 3</strong></span>. This due to the popularity of TensorFlow, which makes it a common backend.</p><p>We can easily switch<a id="id6" class="indexterm"/> from one back-end to another by editing the Keras<a id="id7" class="indexterm"/> configuration file <code class="literal">.keras/keras.json</code> in Linux or macOS. Due to the differences in the way low-level algorithms are implemented, networks can often have different speeds on different backends.</p><p>On hardware, Keras runs on a CPU, GPU, and Google's TPU. In this book, we'll be testing on a CPU and NVIDIA GPUs (Specifically, the GTX 1060 and GTX 1080Ti models).</p><div class="mediaobject"><img src="graphics/B08956_01_01.jpg" alt="Installing Keras and TensorFlow"/><div class="caption"><p>Figure 1.1.1: Keras is a high-level library that sits on top of other deep learning models. Keras is supported on CPU, GPU, and TPU.</p></div></div><p>Before proceeding with the rest of the book, we need to ensure that Keras and TensorFlow are correctly installed. There are multiple ways to perform the installation; one example is installing using <code class="literal">pip3</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pip3 install tensorflow</strong></span>
</pre></div><p>If we have a supported NVIDIA GPU, with properly installed drivers, and both NVIDIA's <span class="strong"><strong>CUDA</strong></span> Toolkit and <span class="strong"><strong>cuDNN Deep Neural Network library</strong></span>, it is recommended that we install the GPU-enabled version since it can accelerate both training and prediction:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pip3 install tensorflow-gpu</strong></span>
</pre></div><p>The next step for us is to then install Keras:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pip3 install keras</strong></span>
</pre></div><p>The examples presented in this<a id="id8" class="indexterm"/> book will require additional packages, such as <code class="literal">pydot</code>, <code class="literal">pydot_ng</code>, <code class="literal">vizgraph</code>, <code class="literal">python3-tk</code> and <code class="literal">matplotlib</code>. We'll need<a id="id9" class="indexterm"/> to install these packages before proceeding beyond this chapter.</p><p>The following should not generate any error if both TensorFlow and Keras are installed along with their dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import tensorflow as tf</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; message = tf.constant('Hello world!')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session = tf.Session()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session.run(message)</strong></span>
<span class="strong"><strong>b'Hello world!'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import keras.backend as K</strong></span>
<span class="strong"><strong>Using TensorFlow backend.</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(K.epsilon())</strong></span>
<span class="strong"><strong>1e-07</strong></span>
</pre></div><p>The warning message about <code class="literal">SSE4.2 AVX AVX2 FMA</code>, which is similar to the one below can be safely ignored. To remove the warning message, you'll need to recompile <a id="id10" class="indexterm"/>and install the TensorFlow source code from <a class="ulink" href="https://github.com/tensorflow/tensorflow">https://github.com/tensorflow/tensorflow</a>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.2 AVX AVX2 FMA</strong></span>
</pre></div><p>This book does not cover the complete<a id="id11" class="indexterm"/> Keras API. We'll only be covering the materials needed to explain the advanced deep learning topics in this book. For further information, we can consult the official Keras documentation, which can be found at <a class="ulink" href="https://keras.io">https://keras.io</a>.</p></div></div></div>
<div class="section" title="Implementing the core deep learning models - MLPs, CNNs, and RNNs"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Implementing the core deep learning models - MLPs, CNNs, and RNNs</h1></div></div></div><p>We've already<a id="id12" class="indexterm"/> mentioned that we'll be using three advanced deep learning models, they are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MLPs</strong></span>: Multilayer perceptrons</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>RNNs</strong></span>: Recurrent neural networks</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CNNs</strong></span>: Convolutional neural networks</li></ul></div><p>These are the<a id="id13" class="indexterm"/> three networks that we will be using throughout this book. Despite the three networks being separate, you'll find that they are often combined together in order to take advantage of the strength of each model.</p><p>In the following sections of this chapter, we'll discuss these building blocks one by one in more detail. In the following sections, MLPs are covered together with other important topics such as loss function, optimizer, and regularizer. Following on afterward, we'll cover both CNNs and RNNs.</p><div class="section" title="The difference between MLPs, CNNs, and RNNs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>The difference between MLPs, CNNs, and RNNs</h2></div></div></div><p>Multilayer perceptrons or MLPs are a fully-connected network. You'll often find them referred to as<a id="id14" class="indexterm"/> either deep feedforward networks or feedforward neural networks in some literature. Understanding these networks in terms of known target applications will help us get insights about the underlying reasons for the design of the advanced deep learning models. MLPs are common in simple logistic and linear regression problems. However, MLPs are not optimal for processing sequential and multi-dimensional data patterns. By design, MLPs struggle to remember patterns in sequential data and requires a substantial number of parameters to process multi-dimensional data.</p><p>For sequential data input, RNNs are popular because the internal design allows the network to discover dependency in the history of data that is useful for prediction. For multi-dimensional data like images and videos, a CNN excels in extracting feature maps for classification, segmentation, generation, and other purposes. In some cases, a CNN in the form of a 1D convolution is also used for networks with sequential input data. However, in most deep learning models, MLPs, RNNs, and CNNs are combined to make the most out of each network.</p><p>MLPs, RNNs, and CNNs do not complete the whole picture of deep networks. There is a need to identify an <span class="emphasis"><em>objective</em></span> or <span class="emphasis"><em>loss function</em></span>, <span class="emphasis"><em>an optimizer</em></span>, and a <span class="emphasis"><em>regularizer</em></span>. The goal is to reduce the loss function value during training since it is a good guide that a model is learning. To minimize this value, the model employs an optimizer. This is an algorithm that determines how weights and biases should be adjusted at each training step. A trained model must work not only on the training data but also on a test or even on unforeseen input data. The role of the regularizer is to ensure that the trained model generalizes to new data.</p></div></div>
<div class="section" title="Multilayer perceptrons (MLPs)"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Multilayer perceptrons (MLPs)</h1></div></div></div><p>The first of the three networks we will be looking at is known as a <span class="strong"><strong>multilayer perceptrons or (MLPs)</strong></span>. Let's suppose that the objective is to<a id="id15" class="indexterm"/> create a neural network for identifying numbers based on handwritten digits. For example, when the input to the network is an image of a handwritten number 8, the corresponding prediction must also be the digit 8. This is a classic job of classifier networks that can be trained using logistic regression. To both train and validate a classifier network, there must be a sufficiently large dataset of handwritten digits. The Modified National Institute of Standards and Technology dataset or MNIST for short, is often considered as the <span class="emphasis"><em>Hello World!</em></span> of deep learning and is a suitable dataset for handwritten digit classification.</p><p>Before we discuss the multilayer perceptron model, it's essential that we understand the MNIST dataset. A large number of the examples in this book use the MNIST dataset. MNIST is used to explain and validate deep learning theories because the 70,000 samples it contains are small, yet sufficiently rich in information:</p><div class="mediaobject"><img src="graphics/B08956_01_02.jpg" alt="Multilayer perceptrons (MLPs)"/><div class="caption"><p>Figure 1.3.1: Example images from the MNIST dataset. Each image is 28 × 28-pixel grayscale.</p></div></div><div class="section" title="MNIST dataset"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>MNIST dataset</h2></div></div></div><p>MNIST is a collection<a id="id16" class="indexterm"/> of handwritten digits ranging from the number 0 to 9. It has a training set of 60,000 images, and 10,000 test images that are classified into corresponding categories or labels. In some literature, the term <span class="strong"><strong>target</strong></span> or <span class="strong"><strong>ground truth</strong></span> is also <a id="id17" class="indexterm"/>used to refer to the <span class="strong"><strong>label</strong></span>.</p><p>In the preceding figure sample images of the MNIST digits, each being sized at 28 X 28-pixel grayscale, can be seen. To use the MNIST dataset in Keras, an API is provided to download and extract images and labels automatically. <span class="emphasis"><em>Listing 1.3.1</em></span> demonstrates how to load the MNIST dataset in just one line, allowing us to both count the train and test labels and then plot random digit images.</p><p>Listing 1.3.1, <code class="literal">mnist-sampler-1.3.1.py</code>. Keras code showing how to access MNIST dataset, plot 25 random samples, and count the number of labels for train and test datasets:</p><div class="informalexample"><pre class="programlisting">import numpy as np
from keras.datasets import mnist
import matplotlib.pyplot as plt

# load dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# count the number of unique train labels
unique, counts = np.unique(y_train, return_counts=True)
print("Train labels: ", dict(zip(unique, counts)))

# count the number of unique test labels
unique, counts = np.unique(y_test, return_counts=True)
print("Test labels: ", dict(zip(unique, counts)))

# sample 25 mnist digits from train dataset
indexes = np.random.randint(0, x_train.shape[0], size=25)
images = x_train[indexes]
labels = y_train[indexes]

# plot the 25 mnist digits
plt.figure(figsize=(5,5))
for i in range(len(indexes)):
    plt.subplot(5, 5, i + 1)
    image = images[i]
    plt.imshow(image, cmap='gray')
    plt.axis('off')

plt.show()
plt.savefig("mnist-samples.png")
plt.close('all')</pre></div><p>The <code class="literal">mnist.load_data()</code> method is convenient since there is no need to load all 70,000 images and labels individually and store them in arrays. Executing <code class="literal">python3 mnist-sampler-1.3.1.py</code> on command line prints the distribution of labels in the train and test datasets:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Train labels:  {0: 5923, 1: 6742, 2: 5958, 3: 6131, 4: 5842, 5: 5421, 6: 5918, 7: 6265, 8: 5851, 9: 5949}</strong></span>
<span class="strong"><strong>Test labels:  {0: 980, 1: 1135, 2: 1032, 3: 1010, 4: 982, 5: 892, 6: 958, 7: 1028, 8: 974, 9: 1009}</strong></span>
</pre></div><p>Afterward, the code will plot 25 random digits as shown in the preceding figure, <span class="emphasis"><em>Figure 1.3.1</em></span>.</p><p>Before discussing the multilayer perceptron <a id="id18" class="indexterm"/>classifier model, it is essential to keep in mind that while MNIST data are 2D tensors, they should be reshaped accordingly depending on the type of input layer. The following figure shows how a 3 × 3 grayscale image is reshaped for MLPs, CNNs, and RNNs input layers:</p><div class="mediaobject"><img src="graphics/B08956_01_03.jpg" alt="MNIST dataset"/><div class="caption"><p>Figure 1.3.2: An input image similar to the MNIST data is reshaped depending on the type of input layer. For simplicity, reshaping of a 3 × 3 grayscale image is shown.</p></div></div></div><div class="section" title="MNIST digits classifier model"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>MNIST digits classifier model</h2></div></div></div><p>The proposed MLP model shown in <span class="emphasis"><em>Figure 1.3.3</em></span> can be used for MNIST digit classification. When the <a id="id19" class="indexterm"/>units or perceptrons are exposed, the MLP model is a fully connected network as shown in <span class="emphasis"><em>Figure 1.3.4</em></span>. It will also be shown how the output of the perceptron is computed from inputs as a function of weights, <span class="emphasis"><em>w</em></span><sub>i</sub> and bias, <span class="emphasis"><em>b</em></span>
<sub>n</sub> for the n<sup>th</sup> unit. The corresponding Keras implementation is illustrated in <span class="emphasis"><em>Listing 1.3.2</em></span>.</p><div class="mediaobject"><img src="graphics/B08956_01_04.jpg" alt="MNIST digits classifier model"/><div class="caption"><p>Figure 1.3.3: MLP MNIST digit classifier model</p></div></div><div class="mediaobject"><img src="graphics/B08956_01_05.jpg" alt="MNIST digits classifier model"/><div class="caption"><p>Figure 1.3.4: The MLP MNIST digit classifier in Figure 1.3.3 is made up of fully connected layers. For simplicity, the activation and dropout are not shown. One unit or perceptron is also shown.</p></div></div><p>Listing 1.3.2, <code class="literal">mlp-mnist-1.3.2.py</code> shows the Keras<a id="id20" class="indexterm"/> implementation of the MNIST digit classifier model using MLP:</p><div class="informalexample"><pre class="programlisting">import numpy as np
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout
from keras.utils import to_categorical, plot_model
from keras.datasets import mnist

# load mnist dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# compute the number of labels
num_labels = len(np.unique(y_train))

# convert to one-hot vector
y_train = to_categorical(y_train)
y_test = to_categorical(y_test)

# image dimensions (assumed square)
image_size = x_train.shape[1]
input_size = image_size * image_size

# resize and normalize
x_train = np.reshape(x_train, [-1, input_size])
x_train = x_train.astype('float32') / 255
x_test = np.reshape(x_test, [-1, input_size])
x_test = x_test.astype('float32') / 255

# network parameters
batch_size = 128
hidden_units = 256
dropout = 0.45

# model is a 3-layer MLP with ReLU and dropout after each layer
model = Sequential()
model.add(Dense(hidden_units, input_dim=input_size))
model.add(Activation('relu'))
model.add(Dropout(dropout))
model.add(Dense(hidden_units))
model.add(Activation('relu'))
model.add(Dropout(dropout))
model.add(Dense(num_labels))
# this is the output for one-hot vector
model.add(Activation('softmax'))
model.summary()
plot_model(model, to_file='mlp-mnist.png', show_shapes=True)

# loss function for one-hot vector
# use of adam optimizer
# accuracy is a good metric for classification tasks
model.compile(loss='categorical_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])
# train the network
model.fit(x_train, y_train, epochs=20, batch_size=batch_size)

# validate the model on test dataset to determine generalization
loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size)
print("\nTest accuracy: %.1f%%" % (100.0 * acc))</pre></div><p>Before discussing the model implementation, the data must be in the correct shape and format. After loading the MNIST dataset, the number of labels is computed as:</p><div class="informalexample"><pre class="programlisting"># compute the number of labels
num_labels = len(np.unique(y_train))</pre></div><p>Hard coding <code class="literal">num_labels = 10</code> is also an option. But, it's always a good practice to let the computer do its job. The code assumes that <code class="literal">y_train</code> has labels 0 to 9.</p><p>At this point, the labels are in<a id="id21" class="indexterm"/> digits format, 0 to 9. This sparse scalar representation of labels is not suitable for the neural network prediction layer that outputs probabilities per class. A more suitable format<a id="id22" class="indexterm"/> is called a <span class="strong"><strong>one-hot vector</strong></span>, a 10-dim<a id="id23" class="indexterm"/> vector with all elements 0, except for the index of the digit class. For example, if the label is 2, the equivalent one-hot vector is <code class="literal">[0,0,1,0,0,0,0,0,0,0]</code>. The first label has index <code class="literal">0</code>.</p><p>The following lines convert each label into a one-hot vector:</p><div class="informalexample"><pre class="programlisting"># convert to one-hot vector
y_train = to_categorical(y_train)
y_test = to_categorical(y_test)</pre></div><p>In deep learning, data is<a id="id24" class="indexterm"/> stored in <span class="strong"><strong>tensors</strong></span>. The term tensor applies to a scalar (0D tensor), vector (1D tensor), matrix (2D tensor), and a <a id="id25" class="indexterm"/>multi-dimensional tensor. From this point, the term tensor is used unless scalar, vector, or matrix makes the explanation clearer.</p><p>The rest computes the image dimensions, <code class="literal">input_size</code> of the first <code class="literal">Dense</code> layer and scales each pixel value from 0 to 255 to range from 0.0 to 1.0. Although raw pixel values can be used directly, it is better to normalize the input data as to avoid large gradient values that could make<a id="id26" class="indexterm"/> training difficult. The output of the network is also normalized. After training, there is an option to put everything back to the integer pixel values by multiplying the output tensor by 255.</p><p>The proposed model is based on MLP layers. Therefore, the input is expected to be a 1D tensor. As such, <code class="literal">x_train</code> and <code class="literal">x_test</code> are reshaped to [60000, 28 * 28] and [10000, 28 * 28], respectively.</p><div class="informalexample"><pre class="programlisting"># image dimensions (assumed square)
image_size = x_train.shape[1]
input_size = image_size * image_size

# resize and normalize
x_train = np.reshape(x_train, [-1, input_size])
x_train = x_train.astype('float32') / 255
x_test = np.reshape(x_test, [-1, input_size])
x_test = x_test.astype('float32') / 255</pre></div><div class="section" title="Building a model using MLPs and Keras"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Building a model using MLPs and Keras</h3></div></div></div><p>After data preparation, building the model is next. The proposed model is made of three MLP layers. In Keras, an MLP layer is referred to as <span class="strong"><strong>Dense</strong></span>, which stands for the densely connected layer. Both the first and second MLP layers are identical in nature with 256 units each, followed<a id="id27" class="indexterm"/> by <code class="literal">relu</code> activation<a id="id28" class="indexterm"/> and <code class="literal">dropout</code>. 256 units are chosen since 128, 512 and 1,024 units have lower performance metrics. At 128 units, the network converges quickly, but has a lower test accuracy. The added number units for 512 or 1,024 does not increase the test accuracy significantly.</p><p>The number of units is a <span class="strong"><strong>hyperparameter</strong></span>. It controls the <span class="emphasis"><em>capacity</em></span> of the network. The capacity is a measure <a id="id29" class="indexterm"/>of the complexity of the function that the network can approximate. For example, for polynomials, the degree is the hyperparameter. As the degree increases, the capacity of the function also increases.</p><p>As shown in the following model, the classifier model is implemented using a sequential model API of Keras. This is sufficient if the model requires one input and one output processed by a sequence of layers. For simplicity, we'll use this in the meantime, however, in <a class="link" href="ch02.html" title="Chapter 2. Deep Neural Networks">Chapter 2</a>, <span class="emphasis"><em>Deep Neural Networks</em></span>, the Functional API of Keras will be introduced to implement advanced deep learning models.</p><div class="informalexample"><pre class="programlisting"># model is a 3-layer MLP with ReLU and dropout after each layer
model = Sequential()
model.add(Dense(hidden_units, input_dim=input_size))
model.add(Activation('relu'))
model.add(Dropout(dropout))
model.add(Dense(hidden_units))
model.add(Activation('relu'))
model.add(Dropout(dropout))
model.add(Dense(num_labels))
# this is the output for one-hot vector
model.add(Activation('softmax'))</pre></div><p>Since a <code class="literal">Dense</code> layer<a id="id30" class="indexterm"/> is a linear operation, a sequence of <code class="literal">Dense</code> layers can<a id="id31" class="indexterm"/> only approximate a linear function. The problem is that the MNIST digit<a id="id32" class="indexterm"/> classification is inherently a non-linear process. Inserting a <code class="literal">relu</code> activation between <code class="literal">Dense</code> layers will enable MLPs to model non-linear mappings. <code class="literal">relu</code> or <span class="strong"><strong>Rectified Linear Unit</strong></span> (<span class="strong"><strong>ReLU</strong></span>) is a simple non-linear function. It's very much like a filter that allows positive inputs to pass through unchanged while clamping everything else to zero. Mathematically, <code class="literal">relu</code> is expressed in the following equation and plotted in <span class="emphasis"><em>Figure 1.3.5</em></span>:</p><p>
<span class="emphasis"><em>relu</em></span>(x) = <span class="emphasis"><em>max</em></span>(0,<span class="emphasis"><em>x</em></span>)</p><div class="mediaobject"><img src="graphics/B08956_01_06.jpg" alt="Building a model using MLPs and Keras"/><div class="caption"><p>Figure 1.3.5: Plot of ReLU function. The ReLU function introduces non-linearity in neural networks.</p></div></div><p>There are<a id="id33" class="indexterm"/> other non-linear functions that can be used<a id="id34" class="indexterm"/> such as <code class="literal">elu</code>, <code class="literal">selu</code>, <code class="literal">softplus</code>, <code class="literal">sigmoid</code>, and <code class="literal">tanh</code>. However, <code class="literal">relu</code> is the most commonly used in the industry and is computationally efficient due to its simplicity. The <code class="literal">sigmoid</code> and <code class="literal">tanh</code> are used as activation functions in the output layer and described later. <span class="emphasis"><em>Table 1.3.1</em></span> shows the equation for each of these activation functions:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">relu</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>relu</em></span>(x) = <span class="emphasis"><em>max</em></span>(0,<span class="emphasis"><em>x</em></span>)</p>
</td><td style="text-align: left" valign="top">
<p>1.3.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">softplus</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>softplus</em></span>(<span class="emphasis"><em>x</em></span>) = log(1 + <span class="emphasis"><em>e</em></span>
<span class="emphasis"><em>x</em></span>)</p>
</td><td style="text-align: left" valign="top">
<p>1.3.2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">elu</code>
</p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B08956_01_001.jpg" alt="Building a model using MLPs and Keras"/></div>
<p>where </p><div class="mediaobject"><img src="graphics/B08956_01_002.jpg" alt="Building a model using MLPs and Keras"/></div><p> and is a tunable hyperparameter</p>
</td><td style="text-align: left" valign="top">
<p>1.3.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">selu</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>selu</em></span>(<span class="emphasis"><em>x</em></span>) = <span class="emphasis"><em>k</em></span> × <span class="emphasis"><em>elu</em></span>(<span class="emphasis"><em>x,a</em></span>)</p>
<p>where <span class="emphasis"><em>k</em></span> = 1.0507009873554804934193349852946 and <span class="emphasis"><em>a</em></span> = 1.6732632423543772848170429916717</p>
</td><td style="text-align: left" valign="top">
<p>1.3.4</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p>Table 1.3.1: Definition of common non-linear activation functions</p></blockquote></div></div></div><div class="section" title="Regularization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Regularization</h2></div></div></div><p>A neural network has the<a id="id35" class="indexterm"/> tendency to memorize its training data especially if it contains more than enough capacity. In such a case, the network fails catastrophically when subjected to the test data. This is the classic case of the network failing to generalize. To avoid this<a id="id36" class="indexterm"/> tendency, the model uses<a id="id37" class="indexterm"/> a regularizing layer or function. A common regularizing layer is referred to as a <span class="strong"><strong>dropout</strong></span>.</p><p>The idea of dropout is simple. Given a dropout rate (here, it is set to <code class="literal">dropout=0.45</code>), the <code class="literal">Dropout</code> layer randomly removes that fraction of units from participating in the next layer. For example, if the first layer has 256 units, after <code class="literal">dropout=0.45 </code>is applied, only <span class="emphasis"><em>(1 - 0.45) * 256 units = 140</em></span> units from layer 1 participate in layer 2. The <code class="literal">Dropout</code> layer makes neural networks robust to unforeseen input data because the network is trained to predict correctly, even if some units are missing. It's worth noting that dropout is not used in the output layer and it is only active during training. Moreover, dropout is not present during prediction.</p><p>There are regularizers that can be used other than dropouts like <code class="literal">l1</code> or <code class="literal">l2</code>. In Keras, the bias, weight and activation <a id="id38" class="indexterm"/>output can be regularized per layer. <code class="literal">l1</code> and <code class="literal">l2</code> favor smaller parameter values by adding a penalty function. Both <code class="literal">l1</code> and <code class="literal">l2</code> enforce the penalty using a fraction of the sum of absolute (<code class="literal">l1</code>) or square (<code class="literal">l2</code>) of parameter values. In other words, the penalty function forces the optimizer to find parameter values that are small. Neural networks with small parameter values are more insensitive to the presence of noise from within the input data.</p><p>As an example, <code class="literal">l2</code> weight regularizer with <code class="literal">fraction=0.001</code> can be implemented as:</p><div class="informalexample"><pre class="programlisting">from keras.regularizers import l2
model.add(Dense(hidden_units,
          kernel_regularizer=l2(0.001),
          input_dim=input_size))</pre></div><p>No additional layer is added if <code class="literal">l1</code> or <code class="literal">l2</code> regularization is used. The regularization is imposed in the <code class="literal">Dense</code> layer internally. For the proposed model, dropout still has a better performance than <code class="literal">l2</code>.</p></div><div class="section" title="Output activation and loss function"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Output activation and loss function</h2></div></div></div><p>The output layer has 10<a id="id39" class="indexterm"/> units followed by <code class="literal">softmax</code> activation. The 10<a id="id40" class="indexterm"/> units correspond to the 10 possible labels, classes or categories. The <code class="literal">softmax</code> activation can be expressed mathematically as shown in the following equation:</p><div class="mediaobject"><img src="graphics/B08956_01_003.jpg" alt="Output activation and loss function"/></div><p>          (Equation 1.3.5)</p><p>The equation is applied to all <span class="emphasis"><em>N</em></span> = 10 outputs, <span class="emphasis"><em>x</em></span>
<span class="emphasis"><em>i</em></span>
<span class="emphasis"><em> for i</em></span> = 0, 1 … 9 for the final prediction. The idea of <code class="literal">softmax</code> is surprisingly simple. It squashes the outputs into probabilities by normalizing the prediction. Here, each predicted output is a probability that the index is the correct label of the given input image. The sum of all the probabilities for all outputs is 1.0. For example, when the <code class="literal">softmax</code> layer generates a prediction, it will be a 10-dim 1D tensor that may look like the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[  3.57351579e-11   7.08998016e-08   2.30154569e-07   6.35787558e-07</strong></span>
<span class="strong"><strong>   5.57471187e-11   4.15353840e-09   3.55973775e-16   9.99995947e-01</strong></span>
<span class="strong"><strong>   1.29531730e-09   3.06023480e-06]</strong></span>
</pre></div><p>The prediction output tensor suggests that the input image is going to be 7 given that its index has the highest probability. The <code class="literal">numpy.argmax()</code> method can be used to determine the index of the element with the highest value.</p><p>There are other choices of output activation layer, like <code class="literal">linear</code>, <code class="literal">sigmoid</code>, and <code class="literal">tanh</code>. The <code class="literal">linear</code> activation is an<a id="id41" class="indexterm"/> identity function. It copies its input to its output. The <code class="literal">sigmoid</code> function is more specifically known as a <span class="strong"><strong>logistic sigmoid</strong></span>. This will be used if the<a id="id42" class="indexterm"/> elements of the prediction tensor should be mapped between 0.0 and 1.0 independently. The summation of all elements of the <a id="id43" class="indexterm"/>predicted tensor is not constrained to 1.0 unlike in <code class="literal">softmax</code>. For example, <code class="literal">sigmoid</code> is used as the last layer in sentiment prediction (0.0 is bad to 1.0, which is good) or in image generation (0.0 is 0 to 1.0 is 255-pixel values).</p><p>The <code class="literal">tanh</code> function maps its input in the range -1.0 to 1.0. This is important if the output can swing in both positive and negative values. The <code class="literal">tanh</code> function is more popularly used in the internal layer of recurrent neural networks but has also been used as output layer activation. If <code class="literal">tanh</code> is used to replace <code class="literal">sigmoid</code> in the output activation, the data used must be scaled appropriately. For example, instead of scaling each grayscale pixel in the range [0.0  1.0] using </p><div class="mediaobject"><img src="graphics/B08956_01_004.jpg" alt="Output activation and loss function"/></div><p>, it is assigned in the range [-1.0  1.0] by </p><div class="mediaobject"><img src="graphics/B08956_01_005.jpg" alt="Output activation and loss function"/></div><p>.</p><p>The following graph shows the <code class="literal">sigmoid</code> and <code class="literal">tanh</code> functions. Mathematically, <code class="literal">sigmoid</code> can be expressed in equation as follows:</p><div class="mediaobject"><img src="graphics/B08956_01_006.jpg" alt="Output activation and loss function"/></div><p>          (Equation 1.3.6)</p><div class="mediaobject"><img src="graphics/B08956_01_07.jpg" alt="Output activation and loss function"/><div class="caption"><p>Figure 1.3.6: Plots of sigmoid and tanh</p></div></div><p>How far<a id="id44" class="indexterm"/> the predicted tensor is from the one-hot<a id="id45" class="indexterm"/> ground truth vector is called loss. One type<a id="id46" class="indexterm"/> of loss function is <code class="literal">mean_squared_error</code> (<span class="strong"><strong>mse</strong></span>), or the<a id="id47" class="indexterm"/> average of the squares of the differences between target and prediction. In the current example, we are using <code class="literal">categorical_crossentropy</code>. It's the negative of the sum of the product of the target and the logarithm of the prediction. There are other loss functions that are available in Keras, such as <code class="literal">mean_absolute_error</code>, and <code class="literal">binary_crossentropy</code>. The choice of the loss function is not arbitrary but should be a criterion that the model is learning. For classification by category, <code class="literal">categorical_crossentropy</code> or <code class="literal">mean_squared_error</code> is a good choice after the <code class="literal">softmax</code> activation layer. The <code class="literal">binary_crossentropy</code> loss function is normally used after the <code class="literal">sigmoid</code> activation layer while <code class="literal">mean_squared_error</code> is an option for <code class="literal">tanh</code> output.</p></div><div class="section" title="Optimization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Optimization</h2></div></div></div><p>With optimization, the objective is to minimize the loss function. The idea is that if the loss is reduced<a id="id48" class="indexterm"/> to an acceptable level, the model has indirectly learned the function mapping input to output. Performance metrics are used to determine if a model has learned the underlying data distribution. The default metric in Keras is <span class="strong"><strong>loss</strong></span>. During training, validation, and testing, other metrics such as <span class="strong"><strong>accuracy</strong></span> can also be included. Accuracy<a id="id49" class="indexterm"/> is the percent, or fraction, of correct predictions based on ground truth. In deep learning, there are many other performance metrics. However, it depends on the target application of the model. In literature, performance metrics of the trained model on the test dataset is reported for comparison to other deep learning models.</p><p>In Keras, there are several choices for<a id="id50" class="indexterm"/> optimizers. The most commonly used optimizers are; <span class="strong"><strong>Stochastic Gradient Descent</strong></span> (<span class="strong"><strong>SGD</strong></span>), <span class="strong"><strong>Adaptive Moments</strong></span> (<span class="strong"><strong>Adam</strong></span>), and <span class="strong"><strong>Root Mean Squared Propagation</strong></span> (<span class="strong"><strong>RMSprop</strong></span>). Each <a id="id51" class="indexterm"/>optimizer features <a id="id52" class="indexterm"/>tunable parameters like learning rate, momentum, and decay. Adam and RMSprop are variations of SGD with adaptive learning rates. In the proposed classifier network, Adam is used since it has the highest test accuracy.</p><p>SGD is considered the most fundamental optimizer. It's a simpler version of the gradient descent in calculus. In <span class="strong"><strong>gradient descent</strong></span> (<span class="strong"><strong>GD</strong></span>), tracing the curve of a<a id="id53" class="indexterm"/> function downhill finds the minimum value, much like walking downhill in a valley or opposite the gradient until the bottom is reached.</p><p>The GD algorithm is illustrated in <span class="emphasis"><em>Figure 1.3.7</em></span>. Let's suppose <span class="emphasis"><em>x</em></span> is the parameter (for example, weight) being tuned to find the minimum value of <span class="emphasis"><em>y</em></span> (for example, loss function). Starting at an arbitrary point of <span class="emphasis"><em>x</em></span> = -0.5 with the gradient being </p><div class="mediaobject"><img src="graphics/B08956_01_007.jpg" alt="Optimization"/></div><p>. The GD algorithm imposes that <span class="emphasis"><em>x</em></span> is then updated to </p><div class="mediaobject"><img src="graphics/B08956_01_008.jpg" alt="Optimization"/></div><p>. The new value of <span class="emphasis"><em>x</em></span> is equal to<a id="id54" class="indexterm"/> the old value, plus the opposite of the gradient scaled by </p><div class="mediaobject"><img src="graphics/B08956_01_009.jpg" alt="Optimization"/></div><p>. The small<a id="id55" class="indexterm"/> number </p><div class="mediaobject"><img src="graphics/B08956_01_010.jpg" alt="Optimization"/></div><p> refers to the learning rate. If </p><div class="mediaobject"><img src="graphics/B08956_01_011.jpg" alt="Optimization"/></div><p>, then the new value of <span class="emphasis"><em>x</em></span> = -0.48.</p><p>GD is performed iteratively. At each step, <span class="emphasis"><em>y</em></span> will get closer to its minimum value. At <span class="emphasis"><em>x</em></span> = 0.5 </p><div class="mediaobject"><img src="graphics/B08956_01_012.jpg" alt="Optimization"/></div><p>, the GD has found the absolute minimum value of <span class="emphasis"><em>y</em></span> = -1.25. The gradient recommends no further change in <span class="emphasis"><em>x</em></span>.</p><p>The choice of learning rate is crucial. A large value of </p><div class="mediaobject"><img src="graphics/B08956_01_013.jpg" alt="Optimization"/></div><p> may not find the minimum value since the search will just swing back and forth around the minimum value. On the other hand, too small value of </p><div class="mediaobject"><img src="graphics/B08956_01_014.jpg" alt="Optimization"/></div><p> may take a significant number of iterations before the minimum is found. In the case of multiple minima, the search might get stuck in a local minimum.</p><div class="mediaobject"><img src="graphics/B08956_01_08.jpg" alt="Optimization"/><div class="caption"><p>Figure 1.3.7: Gradient descent is similar to walking downhill on the function curve until the lowest point is reached. In this plot, the global minimum is at x = 0.5.</p></div></div><p>An example of multiple minima can be seen in <span class="emphasis"><em>Figure 1.3.8</em></span>. If for some reason the search started at the left<a id="id56" class="indexterm"/> side of the plot and the learning rate is very small, there is a high probability that GD will find <span class="emphasis"><em>x</em></span> = -1.51 as the minimum value of <span class="emphasis"><em>y</em></span>. GD will not find the global minimum at <span class="emphasis"><em>x</em></span> = 1.66. A sufficiently valued learning rate will enable the gradient descent to overcome the hill at <span class="emphasis"><em>x</em></span> = 0.0. In deep learning practice, it is normally recommended to start at a bigger learning rate (for example. 0.1 to 0.001) and gradually decrease as the loss gets closer to the minimum.</p><div class="mediaobject"><img src="graphics/B08956_01_09.jpg" alt="Optimization"/><div class="caption"><p>Figure 1.3.8: Plot of a function with 2 minima, x = -1.51 and x = 1.66. Also shown is the derivative of the function.</p></div></div><p>Gradient descent is not typically used in deep neural networks since you'll often come upon millions of<a id="id57" class="indexterm"/> parameters that need to be trained. It is computationally inefficient to perform a full gradient descent. Instead, SGD is used. In SGD, a mini batch of samples is chosen to compute an approximate value of the descent. The parameters (for example, weights and biases) are adjusted by the following equation:</p><div class="mediaobject"><img src="graphics/B08956_01_015.jpg" alt="Optimization"/></div><p>          (Equation 1.3.7)</p><p>In this equation, </p><div class="mediaobject"><img src="graphics/B08956_01_016.jpg" alt="Optimization"/></div><p> and </p><div class="mediaobject"><img src="graphics/B08956_01_017.jpg" alt="Optimization"/></div><p> are the parameters and gradients tensor of the loss function respectively. The <span class="strong"><strong>g</strong></span> is computed from partial derivatives of the loss function. The mini-batch size is recommended to be a power of 2 for GPU <a id="id58" class="indexterm"/>optimization purposes. In the proposed network, <code class="literal">batch_size=128</code>.</p><p>
<span class="emphasis"><em>Equation 1.3.7</em></span> computes the last layer parameter updates. So, how do we adjust the parameters of the preceding layers? For this case, the chain rule of differentiation is applied to propagate the derivatives to the lower layers and compute the gradients accordingly. This algorithm is known as <span class="strong"><strong>backpropagation</strong></span> in deep learning. The details of backpropagation are beyond the scope of this book. However, a good online reference can be found at <a class="ulink" href="http://neuralnetworksanddeeplearning.com">http://neuralnetworksanddeeplearning.com</a>.</p><p>Since optimization is based <a id="id59" class="indexterm"/>on differentiation, it follows that an important criterion of the loss function is that it must be smooth or differentiable. This is an important constraint to keep in mind when introducing a new loss function.</p><p>Given the training dataset, the choice of the loss function, the optimizer, and the regularizer, the model can now be trained by calling the <code class="literal">fit()</code> function:</p><div class="informalexample"><pre class="programlisting"># loss function for one-hot vector
# use of adam optimizer
# accuracy is a good metric for classification tasks
model.compile(loss='categorical_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])
# train the network
model.fit(x_train, y_train, epochs=20, batch_size=batch_size)</pre></div><p>This is another helpful feature of Keras. By just supplying both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> data, the number of epochs to train, and the batch size, <code class="literal">fit()</code> does the rest. In other deep learning frameworks, this translates to multiple tasks such as preparing the input and output data in the proper format, loading, monitoring, and so on. While all of these must be done inside a <code class="literal">for</code> loop! In Keras, everything is done in just one line.</p><p>In the <code class="literal">fit()</code> function, an epoch is the complete sampling of the entire training data. The <code class="literal">batch_size</code> parameter is the sample size of the number of inputs to process at each training step. To complete one epoch, <code class="literal">fit()</code> requires the size of train dataset divided by batch size, plus 1 to compensate for any fractional part.</p></div><div class="section" title="Performance evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Performance evaluation</h2></div></div></div><p>At this point, the model for the <span class="strong"><strong>MNIST</strong></span> digit classifier is now complete. Performance evaluation will be the next crucial step to <a id="id60" class="indexterm"/>determine if the proposed model has come up with a satisfactory solution. Training the model for 20 epochs will be sufficient to obtain comparable performance metrics.</p><p>The following table, <span class="emphasis"><em>Table 1.3.2</em></span>, shows the different network configurations and corresponding performance measures. Under <span class="emphasis"><em>Layers</em></span>, the number of units is shown for layers 1 to 3. For each optimizer, the default parameters in Keras are used. The effects of varying the regularizer, optimizer and number of units per layer can be observed. Another important observation in <span class="emphasis"><em>Table 1.3.2</em></span> is that bigger networks do not necessarily translate to better performance.</p><p>Increasing the depth of this network shows no added benefits in terms of accuracy for both training and testing datasets. On the other hand, a smaller number of units, like 128, could also lower both the test and train accuracy. The best train accuracy at 99.93% is obtained when the regularizer is removed, and 256 units per layer are used. The test accuracy, however, is much lower at 98.0%, as a result of the network overfitting.</p><p>The highest test accuracy is with the Adam optimizer and <code class="literal">Dropout(0.45)</code> at 98.5%. Technically, there is still some degree of overfitting given that its training accuracy is 99.39%. Both the train and test accuracy are the same at 98.2% for 256-512-256, <code class="literal">Dropout(0.45)</code> and SGD. Removing both the <span class="emphasis"><em>Regularizer</em></span> and <span class="emphasis"><em>ReLU</em></span> layers results in it having the worst performance. Generally, we'll find that the <code class="literal">Dropout</code> layer has better performance than <code class="literal">l2</code>.</p><p>Following table demonstrates a typical deep neural network performance during tuning. The example indicates that there is a need to improve the network architecture. In the following section, another model using CNNs shows a significant improvement in test accuracy:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Layers</p>
</th><th style="text-align: left" valign="bottom">
<p>Regularizer</p>
</th><th style="text-align: left" valign="bottom">
<p>Optimizer</p>
</th><th style="text-align: left" valign="bottom">
<p>ReLU</p>
</th><th style="text-align: left" valign="bottom">
<p>Train Accuracy, %</p>
</th><th style="text-align: left" valign="bottom">
<p>Test Accuracy, %</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>93.65</p>
</td><td style="text-align: left" valign="top">
<p>92.5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>L2(0.001)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.35</p>
</td><td style="text-align: left" valign="top">
<p>98.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>L2(0.01)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>96.90</p>
</td><td style="text-align: left" valign="top">
<p>96.7</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.93</p>
</td><td style="text-align: left" valign="top">
<p>98.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.4)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.23</p>
</td><td style="text-align: left" valign="top">
<p>98.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.07</p>
</td><td style="text-align: left" valign="top">
<p>98.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.5)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>97.68</p>
</td><td style="text-align: left" valign="top">
<p>98.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.6)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>97.11</p>
</td><td style="text-align: left" valign="top">
<p>97.9</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-512-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.21</p>
</td><td style="text-align: left" valign="top">
<p>98.2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>512-512-512</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.45</p>
</td><td style="text-align: left" valign="top">
<p>98.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>512-512-512</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.4)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.95</p>
</td><td style="text-align: left" valign="top">
<p>98.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>512-1024-512</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.90</p>
</td><td style="text-align: left" valign="top">
<p>98.2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1024-1024-1024</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.4)</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.37</p>
</td><td style="text-align: left" valign="top">
<p>98.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.6)</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.64</p>
</td><td style="text-align: left" valign="top">
<p>98.2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.55)</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.02</p>
</td><td style="text-align: left" valign="top">
<p>98.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>99.39</p>
</td><td style="text-align: left" valign="top">
<p>98.5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256-256-256</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>RMSprop</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.75</p>
</td><td style="text-align: left" valign="top">
<p>98.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>128-128-128</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.45)</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>98.70</p>
</td><td style="text-align: left" valign="top">
<p>97.7</p>
</td></tr></tbody></table></div></div><div class="section" title="Model summary"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Model summary</h2></div></div></div><p>Using the Keras library provides us with a quick mechanism to double check the model description by calling:</p><div class="informalexample"><pre class="programlisting">model.summary()</pre></div><p>
<span class="emphasis"><em>Listing</em></span> <span class="emphasis"><em>1.3.2</em></span> shows the model<a id="id61" class="indexterm"/> summary of the proposed network. It requires a total of 269,322 parameters. This is substantial considering that we have a simple task of classifying MNIST digits. MLPs are not parameter efficient. The number of parameters can be computed from <span class="emphasis"><em>Figure 1.3.4</em></span> by focusing on how the output of the perceptron is computed. From input to Dense layer: 784 × 256 + 256 = 200,960. From first Dense to second Dense: 256 × 256 + 256 = 65,792. From second Dense to the output layer: 10 × 256 + 10 = 2,570. The total is 269,322.</p><p>Listing 1.3.2 shows a summary of an MLP MNIST digit classifier model:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>Layer (type)                 Output Shape              Param #   </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>dense_1 (Dense)              (None, 256)               200960    </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>activation_1 (Activation)    (None, 256)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dropout_1 (Dropout)          (None, 256)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dense_2 (Dense)              (None, 256)               65792     </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>activation_2 (Activation)    (None, 256)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dropout_2 (Dropout)          (None, 256)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dense_3 (Dense)              (None, 10)                2570      </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>activation_3 (Activation)    (None, 10)                0         </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>Total params: 269,322</strong></span>
<span class="strong"><strong>Trainable params: 269,322</strong></span>
<span class="strong"><strong>Non-trainable params: 0</strong></span>
</pre></div><p>Another way of verifying the network is by calling:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot_model(model, to_file='mlp-mnist.png', show_shapes=True)</strong></span>
</pre></div><p>
<span class="emphasis"><em>Figure 1.3.9</em></span> shows the plot. You'll find that this is<a id="id62" class="indexterm"/> similar to the results of <code class="literal">summary()</code> but graphically shows the interconnection and I/O of each layer.</p><div class="mediaobject"><img src="graphics/B08956_01_10.jpg" alt="Model summary"/><div class="caption"><p>Figure 1.3.9: The graphical description of the MLP MNIST digit classifier</p></div></div></div></div>
<div class="section" title="Convolutional neural networks (CNNs)"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Convolutional neural networks (CNNs)</h1></div></div></div><p>We're now going to move onto the second artificial neural network, <span class="strong"><strong>Convolutional Neural Networks</strong></span> (<span class="strong"><strong>CNNs</strong></span>). In this section, we're going solve the same MNIST <a id="id63" class="indexterm"/>digit classification problem, instead this time using CNNs.</p><p>
<span class="emphasis"><em>Figure 1.4.1</em></span> shows the CNN model that we'll use for the MNIST digit classification, while its implementation is illustrated in <span class="emphasis"><em>Listing</em></span> <span class="emphasis"><em>1.4.1</em></span>. Some changes in the previous model will be needed to implement the CNN model. Instead of having input vector, the input tensor now has new dimensions (height, width, channels) or (image_size, image_size, 1) = (28, 28, 1) for the grayscale MNIST images. Resizing the train and test images will be needed to conform to this input shape requirement.</p><div class="mediaobject"><img src="graphics/B08956_01_11.jpg" alt="Convolutional neural networks (CNNs)"/><div class="caption"><p>Figure 1.4.1: CNN model for MNIST digit classification</p></div></div><p>Listing 1.4.1, <code class="literal">cnn-mnist-1.4.1.py</code> shows the Keras code for the MNIST digit classification using CNN:</p><div class="informalexample"><pre class="programlisting">import numpy as np
from keras.models import Sequential
from keras.layers import Activation, Dense, Dropout
from keras.layers import Conv2D, MaxPooling2D, Flatten
from keras.utils import to_categorical, plot_model
from keras.datasets import mnist

# load mnist dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# compute the number of labels
num_labels = len(np.unique(y_train))

# convert to one-hot vector
y_train = to_categorical(y_train)
y_test = to_categorical(y_test)

# input image dimensions
image_size = x_train.shape[1]
# resize and normalize
x_train = np.reshape(x_train,[-1, image_size, image_size, 1])
x_test = np.reshape(x_test,[-1, image_size, image_size, 1])
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

# network parameters
# image is processed as is (square grayscale)
input_shape = (image_size, image_size, 1)
batch_size = 128
kernel_size = 3
pool_size = 2
filters = 64
dropout = 0.2

# model is a stack of CNN-ReLU-MaxPooling
model = Sequential()
model.add(Conv2D(filters=filters,
                 kernel_size=kernel_size,
                 activation='relu',
                 input_shape=input_shape))
model.add(MaxPooling2D(pool_size))
model.add(Conv2D(filters=filters,
                 kernel_size=kernel_size,
                 activation='relu'))
model.add(MaxPooling2D(pool_size))
model.add(Conv2D(filters=filters,
                 kernel_size=kernel_size,
                 activation='relu'))
model.add(Flatten())
# dropout added as regularizer
model.add(Dropout(dropout))
# output layer is 10-dim one-hot vector
model.add(Dense(num_labels))
model.add(Activation('softmax'))
model.summary()
plot_model(model, to_file='cnn-mnist.png', show_shapes=True)

# loss function for one-hot vector
# use of adam optimizer
# accuracy is good metric for classification tasks
model.compile(loss='categorical_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])
# train the network
model.fit(x_train, y_train, epochs=10, batch_size=batch_size)

loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size)
print("\nTest accuracy: %.1f%%" % (100.0 * acc))</pre></div><p>The major change here is the use of <code class="literal">Conv2D</code> layers. The <code class="literal">relu</code> activation function is already an argument of <code class="literal">Conv2D</code>. The <code class="literal">relu</code> function <a id="id64" class="indexterm"/>can be brought out as an <code class="literal">Activation</code> layer when the <span class="strong"><strong>batch normalization</strong></span> layer is included in the model. Batch normalization is used in<a id="id65" class="indexterm"/> deep CNNs so that large learning rates can be used without causing instability during training.</p><div class="section" title="Convolution"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Convolution</h2></div></div></div><p>If in the MLP model the number of <a id="id66" class="indexterm"/>units characterizes the <code class="literal">Dense</code> layers, the kernel characterizes the CNN operations. As shown in <span class="emphasis"><em>Figure 1.4.2</em></span>, the kernel can be visualized as a rectangular patch or window that slides through the whole image from left to right, and top to bottom. This operation is called <span class="strong"><strong>convolution</strong></span>. It transforms the input image into a <span class="strong"><strong>feature maps</strong></span>, which is a<a id="id67" class="indexterm"/> representation of what the kernel has <span class="emphasis"><em>learned</em></span> from the input image. The feature<a id="id68" class="indexterm"/> maps are then transformed into another feature maps in the succeeding layer and so on. The number of feature maps generated per <code class="literal">Conv2D</code> is controlled by the <code class="literal">filters</code> argument.</p><div class="mediaobject"><img src="graphics/B08956_01_12.jpg" alt="Convolution"/><div class="caption"><p>Figure 1.4.2: A 3 × 3 kernel is convolved with an MNIST digit image. The convolution is shown in steps t<sub>n</sub> and t<sub>n+1</sub> where the kernel moved by a stride of 1 pixel to the right.</p></div></div><p>The computation involved in the convolution is shown in <span class="emphasis"><em>Figure 1.4.3</em></span>. For simplicity, a 5 × 5 input image (or input feature map) where a 3 × 3 kernel is applied is illustrated. The resulting feature map is shown after the convolution. The value of one element of the feature map is shaded. You'll notice that the resulting feature map is smaller than the original input image, this is because the convolution is only performed on valid elements. The kernel cannot go beyond the<a id="id69" class="indexterm"/> borders of the image. If the dimensions of the input should be the same as the output feature maps, <code class="literal">Conv2D</code> will accept the option <code class="literal">padding='same'</code>. The input is padded with zeroes around its borders to keep the dimensions unchanged after the convolution:</p><div class="mediaobject"><img src="graphics/B08956_01_13.jpg" alt="Convolution"/><div class="caption"><p>Figure 1.4.3: The convolution operation shows how one element of the feature map is computed</p></div></div></div><div class="section" title="Pooling operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Pooling operations</h2></div></div></div><p>The last change is the addition of a <code class="literal">MaxPooling2D</code> layer with the argument <code class="literal">pool_size=2</code>. <code class="literal">MaxPooling2D </code>compresses each feature map. Every patch of size <code class="literal">pool_size</code> × <code class="literal">pool_size</code> is reduced to one pixel. The value is equal to the maximum pixel value within the patch. <code class="literal">MaxPooling2D </code>is shown in the following figure for two patches:</p><div class="mediaobject"><img src="graphics/B08956_01_14.jpg" alt="Pooling operations"/><div class="caption"><p>Figure 1.4.4: MaxPooling2D operation. For simplicity, the input feature map is 4 × 4 resulting in a 2 × 2 feature map.</p></div></div><p>The significance of <code class="literal">MaxPooling2D</code> is the<a id="id70" class="indexterm"/> reduction in feature maps size which translates to increased kernel coverage. For example, after <code class="literal">MaxPooling2D(2)</code>, the 2 × 2 kernel is now approximately convolving with a 4 × 4 patch. The CNN has learned a new set of feature maps for a different coverage.</p><p>There are other means of pooling and compression. For example, to achieve a 50% size reduction as <code class="literal">MaxPooling2D(2)</code>, <code class="literal">AveragePooling2D(2)</code> takes the average of a patch instead of finding the maximum. Strided convolution, <code class="literal">Conv2D(strides=2,…)</code> will skip every two pixels during convolution and will still have the same 50% size reduction effect. There are subtle differences in the effectiveness of each reduction technique.</p><p>In <code class="literal">Conv2D</code> and <code class="literal">MaxPooling2D</code>, both <code class="literal">pool_size</code> and <code class="literal">kernel</code> can be non-square. In these cases, both the row and column sizes must be indicated. For example, <code class="literal">pool_size=(1, 2)</code> and <code class="literal">kernel=(3, 5)</code>.</p><p>The output of the last <code class="literal">MaxPooling2D</code> is a stack of feature maps. The role of <code class="literal">Flatten</code> is to convert the stack of feature maps into a vector format that is suitable for either <code class="literal">Dropout</code> or <code class="literal">Dense</code> layers, similar to the MLP model output layer.</p></div><div class="section" title="Performance evaluation and model summary"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Performance evaluation and model summary</h2></div></div></div><p>As shown in <span class="emphasis"><em>Listing</em></span> <span class="emphasis"><em>1.4.2</em></span>, the <a id="id71" class="indexterm"/>CNN model in <span class="emphasis"><em>Listing</em></span> <span class="emphasis"><em>1.4.1</em></span> requires a smaller number of parameters at 80,226 compared to 269,322 when MLP layers are used. The <code class="literal">conv2d_1</code> layer has 640 parameters because each kernel has 3 × 3 = 9 parameters, and each of the 64 feature maps has one kernel and one bias parameter. The <a id="id72" class="indexterm"/>number of parameters for other convolution layers can be computed in a similar way. <span class="emphasis"><em>Figure 1.4.5</em></span> shows the graphical representation of the CNN MNIST digit classifier.</p><p>
<span class="emphasis"><em>Table 1.4.1</em></span> shows that the maximum test accuracy of 99.4% which can be achieved for a 3–layer network with 64 feature maps per layer using the Adam optimizer with <code class="literal">dropout=0.2</code>. CNNs are more parameter efficient and have a higher accuracy than MLPs. Likewise, CNNs are also suitable for learning representations<a id="id73" class="indexterm"/> from sequential data, images, and videos.</p><p>Listing 1.4.2 shows a summary of a CNN MNIST digit classifier<a id="id74" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>Layer (type)                 Output Shape              Param #   </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>conv2d_1 (Conv2D)            (None, 26, 26, 64)        640       </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>max_pooling2d_1 (MaxPooling2 (None, 13, 13, 64)        0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>conv2d_2 (Conv2D)            (None, 11, 11, 64)        36928     </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>max_pooling2d_2 (MaxPooling2 (None, 5, 5, 64)          0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>conv2d_3 (Conv2D)            (None, 3, 3, 64)          36928     </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>flatten_1 (Flatten)          (None, 576)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dropout_1 (Dropout)          (None, 576)               0         </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dense_1 (Dense)              (None, 10)                5770      </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>activation_1 (Activation)    (None, 10)                0         </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>Total params: 80,266</strong></span>
<span class="strong"><strong>Trainable params: 80,266</strong></span>
<span class="strong"><strong>Non-trainable params: 0</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/B08956_01_15.jpg" alt="Performance evaluation and model summary"/><div class="caption"><p>Figure 1.4.5: Graphical description of the CNN MNIST digit classifier</p></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Layers</p>
</th><th style="text-align: left" valign="bottom">
<p>Optimizer</p>
</th><th style="text-align: left" valign="bottom">
<p>Regularizer</p>
</th><th style="text-align: left" valign="bottom">
<p>Train Accuracy, %</p>
</th><th style="text-align: left" valign="bottom">
<p>Test Accuracy, %</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>64-64-64</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>97.76</p>
</td><td style="text-align: left" valign="top">
<p>98.50</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>64-64-64</p>
</td><td style="text-align: left" valign="top">
<p>RMSprop</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>99.11</p>
</td><td style="text-align: left" valign="top">
<p>99.00</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>64-64-64</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>99.75</p>
</td><td style="text-align: left" valign="top">
<p>99.40</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>64-64-64</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.4)</p>
</td><td style="text-align: left" valign="top">
<p>99.64</p>
</td><td style="text-align: left" valign="top">
<p>99.30</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Recurrent neural networks (RNNs)"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Recurrent neural networks (RNNs)</h1></div></div></div><p>We're now going to look at the last of our three artificial neural networks, Recurrent neural networks, or RNNs.</p><p>RNNs are a family of networks that are suitable for learning representations of sequential data like text in <span class="strong"><strong>Natural Language Processing</strong></span> (<span class="strong"><strong>NLP</strong></span>) or stream of sensor data in instrumentation. While each <a id="id75" class="indexterm"/>MNIST data sample is not<a id="id76" class="indexterm"/> sequential in nature, it is not hard to imagine that every image can be interpreted as a sequence of rows or columns of pixels. Thus, a model based on RNNs can process each MNIST image as a sequence of 28-element input vectors with <span class="strong"><strong>timesteps</strong></span> equal to 28. The following listing shows the code for the RNN model in <span class="emphasis"><em>Figure 1.5.1</em></span>:</p><div class="mediaobject"><img src="graphics/B08956_01_16.jpg" alt="Recurrent neural networks (RNNs)"/><div class="caption"><p>Figure 1.5.1: RNN model for MNIST digit classification</p></div></div><p>In the following listing, <span class="emphasis"><em>Listing 1.5.1</em></span>, the <code class="literal">rnn-mnist-1.5.1.py</code> shows the Keras code for MNIST digit classification using RNNs:</p><div class="informalexample"><pre class="programlisting">import numpy as np
from keras.models import Sequential
from keras.layers import Dense, Activation, SimpleRNN
from keras.utils import to_categorical, plot_model
from keras.datasets import mnist
                 
# load mnist dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()
                 
# compute the number of labels
num_labels = len(np.unique(y_train))

# convert to one-hot vector
y_train = to_categorical(y_train)
y_test = to_categorical(y_test)

# resize and normalize
image_size = x_train.shape[1]
x_train = np.reshape(x_train,[-1, image_size, image_size])
x_test = np.reshape(x_test,[-1, image_size, image_size])
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

# network parameters
input_shape = (image_size, image_size)
batch_size = 128
units = 256
dropout = 0.2 
             
# model is RNN with 256 units, input is 28-dim vector 28 timesteps
model = Sequential()
model.add(SimpleRNN(units=units,
                    dropout=dropout,
                    input_shape=input_shape))
model.add(Dense(num_labels))
model.add(Activation('softmax'))
model.summary()
plot_model(model, to_file='rnn-mnist.png', show_shapes=True)

# loss function for one-hot vector
# use of sgd optimizer
# accuracy is good metric for classification tasks
model.compile(loss='categorical_crossentropy',
              optimizer='sgd',
              metrics=['accuracy'])
# train the network
model.fit(x_train, y_train, epochs=20, batch_size=batch_size)

loss, acc = model.evaluate(x_test, y_test, batch_size=batch_size)
print("\nTest accuracy: %.1f%%" % (100.0 * acc))</pre></div><p>There are the two main differences between RNNs and the two previous models. First is the <code class="literal">input_shape = (image_size, image_size)</code> which is actually <code class="literal">input_shape = (timesteps, input_dim)</code> or a sequence of <code class="literal">input_dim</code>—dimension vectors of <code class="literal">timesteps</code> length. Second is the use of a <code class="literal">SimpleRNN</code> layer to represent an RNN cell with <code class="literal">units=256</code>. The <code class="literal">units</code> variable<a id="id77" class="indexterm"/> represents the number of output units. If the CNN is characterized by the convolution of kernel across the input feature map, the RNN output is a function not only of the present input but also of the previous output or hidden state. Since the previous output is also a function of the previous input, the current output is also a function of the previous output and input and so on. The <code class="literal">SimpleRNN</code> layer in Keras is a simplified version of the true RNN. The following, equation describes the output of SimpleRNN:</p><p>
<span class="strong"><strong>h</strong></span>t = tanh(<span class="strong"><strong>b</strong></span> + W<span class="strong"><strong>h</strong></span>t-1 + U<span class="strong"><strong>x</strong></span>t)          (1.5.1)</p><p>In this equation, <span class="strong"><strong>b</strong></span> is the bias, while <span class="strong"><strong>W</strong></span> and <span class="strong"><strong>U</strong></span> are called recurrent kernel (weights for previous output) and kernel (weights for the current input) respectively. Subscript <span class="emphasis"><em>t</em></span> is used to indicate the position in the sequence. For <code class="literal">SimpleRNN</code> layer with <code class="literal">units=256</code>, the total number of parameters is 256 + 256 × 256 + 256 × 28 = 72,960 corresponding to <span class="strong"><strong>b</strong></span>, <span class="strong"><strong>W,</strong></span> and <span class="strong"><strong>U</strong></span> contributions.</p><p>Following figure shows the diagrams of both SimpleRNN and RNN that were used in the MNIST digit classification. What makes <code class="literal">SimpleRNN</code> simpler than RNN is the absence of the output values <span class="strong"><strong>O</strong></span>t = V<span class="strong"><strong>h</strong></span>t + <span class="strong"><strong>c</strong></span> before the softmax is computed:</p><div class="mediaobject"><img src="graphics/B08956_01_17.jpg" alt="Recurrent neural networks (RNNs)"/><div class="caption"><p>Figure 1.5.2: Diagram of SimpleRNN and RNN</p></div></div><p>RNNs might be initially harder to understand when<a id="id78" class="indexterm"/> compared to MLPs or CNNs. In MLPs, the perceptron is the fundamental unit. Once the concept of the perceptron is understood, MLPs are just a network of perceptrons. In CNNs, the kernel is a patch or window that slides through the feature map to generate another feature map. In RNNs, the most important is the concept of self-loop. There is in fact just one cell.</p><p>The illusion of multiple cells appears because a cell exists per timestep but in fact, it is just the same cell reused repeatedly unless the network is unrolled. The underlying neural networks of RNNs are shared across cells.</p><p>The summary in <span class="emphasis"><em>Listing</em></span> <span class="emphasis"><em>1.5.2</em></span> indicates that using a <code class="literal">SimpleRNN</code> requires a fewer number of parameters. <span class="emphasis"><em>Figure 1.5.3</em></span> shows the graphical description of the RNN MNIST digit classifier. The model is very concise. <span class="emphasis"><em>Table 1.5.1</em></span> shows that the <code class="literal">SimpleRNN</code> has the lowest accuracy among the networks presented.</p><p>Listing 1.5.2, RNN MNIST digit classifier summary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>Layer (type)                 Output Shape              Param #   </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>simple_rnn_1 (SimpleRNN)     (None, 256)               72960     </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>dense_1 (Dense)              (None, 10)                2570      </strong></span>
<span class="strong"><strong>_________________________________________________________________</strong></span>
<span class="strong"><strong>activation_1 (Activation)    (None, 10)                0         </strong></span>
<span class="strong"><strong>=================================================================</strong></span>
<span class="strong"><strong>Total params: 75,530</strong></span>
<span class="strong"><strong>Trainable params: 75,530</strong></span>
<span class="strong"><strong>Non-trainable params: 0</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/B08956_01_18.jpg" alt="Recurrent neural networks (RNNs)"/><div class="caption"><p>Figure 1.5.3: The RNN MNIST digit classifier graphical description</p></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Layers</p>
</th><th style="text-align: left" valign="bottom">
<p>Optimizer</p>
</th><th style="text-align: left" valign="bottom">
<p>Regularizer</p>
</th><th style="text-align: left" valign="bottom">
<p>Train Accuracy, %</p>
</th><th style="text-align: left" valign="bottom">
<p>Test Accuracy, %</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>256</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>97.26</p>
</td><td style="text-align: left" valign="top">
<p>98.00</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256</p>
</td><td style="text-align: left" valign="top">
<p>RMSprop</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>96.72</p>
</td><td style="text-align: left" valign="top">
<p>97.60</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>256</p>
</td><td style="text-align: left" valign="top">
<p>Adam</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>96.79</p>
</td><td style="text-align: left" valign="top">
<p>97.40</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>512</p>
</td><td style="text-align: left" valign="top">
<p>SGD</p>
</td><td style="text-align: left" valign="top">
<p>Dropout(0.2)</p>
</td><td style="text-align: left" valign="top">
<p>97.88</p>
</td><td style="text-align: left" valign="top">
<p>98.30</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p>Table 1.5.1: The different SimpleRNN network configurations and performance measures</p></blockquote></div><p>In many deep neural networks, other members of the RNN family are more commonly used. For example, <span class="strong"><strong>Long Short-Term Memory</strong></span> (<span class="strong"><strong>LSTM</strong></span>) networks have been used in both machine<a id="id79" class="indexterm"/> translation and question answering problems. LSTM networks address the<a id="id80" class="indexterm"/> problem of long-term dependency or remembering relevant past information to the present output.</p><p>Unlike RNNs or SimpleRNN, the internal structure of the LSTM cell is more complex. <span class="emphasis"><em>Figure 1.5.4</em></span> shows a diagram of LSTM in the context of MNIST digit classification. LSTM uses not only the present input and past outputs or hidden states; it introduces a cell state, <span class="strong"><strong>s</strong></span>t, that carries information from one cell to the other. Information flow between cell states is controlled by three gates, <span class="strong"><strong>f</strong></span>t, <span class="strong"><strong>i</strong></span>t and <span class="strong"><strong>q</strong></span>t. The three gates have the effect of determining which information should be retained or replaced and the amount of information in the past and current input that should contribute to the current cell state or output. We will not discuss the details of the internal structure of the LSTM cell in this book. However, an intuitive guide to LSTM can be found at: <a class="ulink" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">http://colah.github.io/posts/2015-08-Understanding-LSTMs</a>.</p><p>The <code class="literal">LSTM()</code> layer can be used as a drop-in replacement to <code class="literal">SimpleRNN()</code>. If LSTM is overkill for the task at hand, a simpler version<a id="id81" class="indexterm"/> called <span class="strong"><strong>Gated Recurrent Unit</strong></span> (<span class="strong"><strong>GRU</strong></span>) can be used. GRU simplifies LSTM by combining the cell state and hidden state together. GRU also reduces the number of gates by one. The <code class="literal">GRU()</code> function can also be used as a drop-in replacement for <code class="literal">SimpleRNN()</code>.</p><div class="mediaobject"><img src="graphics/B08956_01_19.jpg" alt="Recurrent neural networks (RNNs)"/><div class="caption"><p>Figure 1.5.4: Diagram of LSTM. The parameters are not shown for clarity</p></div></div><p>There are many other ways to configure RNNs. One way is making an RNN model that is bidirectional. By default, RNNs are unidirectional in the sense that the current output is only influenced by the past states and the current input. In bidirectional RNNs, future states can also influence the present state and the past states by allowing information to flow backward. Past outputs are updated as needed depending on the new information received. RNNs can be made bidirectional by calling a wrapper function. For example, the implementation of bidirectional LSTM is <code class="literal">Bidirectional(LSTM())</code>.</p><p>For all types of RNNs, increasing the units will<a id="id82" class="indexterm"/> also increase the capacity. However, another way of increasing the capacity is by stacking the RNN layers. You should note though that as a general rule of thumb, the capacity of the model should only be increased if needed. Excess capacity may contribute to overfitting, and as a result, both longer training time and slower performance during prediction.</p></div>
<div class="section" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Conclusion</h1></div></div></div><p>This chapter provided an overview of the three deep learning models – MLPs, RNNs, CNNs – and also introduced Keras, a library for the rapid development, training and testing those deep learning models. The sequential API of Keras was also discussed. In the next chapter, the Functional API will be presented, which will enable us to build more complex models specifically for advanced deep neural networks.</p><p>This chapter also reviewed the important concepts of deep learning such as optimization, regularization, and loss function. For ease of understanding, these concepts were presented in the context of the MNIST digit classification. Different solutions to the MNIST digit classification using artificial neural networks, specifically MLPs, CNNs, and RNNs, which are important building blocks of deep neural networks, were also discussed together with their performance measures.</p><p>With the understanding of deep learning concepts, and how Keras can be used as a tool with them, we are now equipped to analyze advanced deep learning models. After discussing Functional API in the next chapter, we'll move onto the implementation of popular deep learning models. Subsequent chapters will discuss advanced topics such as autoencoders, GANs, VAEs, and reinforcement learning. The accompanying Keras code implementations will play an important role in understanding these topics.</p></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10_a"/>References</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">LeCun, Yann, Corinna Cortes, and C. J. Burges. MNIST handwritten digit database. AT&amp;T Labs [Online]. Available: <a class="ulink" href="http://yann.%20lecun.%20com/exdb/mnist%202%20(2010)">http://yann. lecun. com/exdb/mnist
2 (2010)</a>.</li></ol></div></div></body></html>