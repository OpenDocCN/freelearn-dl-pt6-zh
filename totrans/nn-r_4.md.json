["```py\n######################################################################\n###Chapter 4 - Introduction to Neural Networks - using R    ##########\n###Simple Perceptron implementation function in R - iris dataset  ####\n######################################################################\n\ndata(iris)\nhead(iris, n=20)\n\niris_sub=iris[1:100, c(1, 3, 5)] \nnames(iris_sub)=c(\"sepal\", \"petal\", \"species\") \nhead(iris_sub) \n\nlibrary(ggplot2) \n\nggplot(iris_sub, aes(x = sepal, y = petal)) + \n geom_point(aes(colour=species, shape=species), size = 3) +\n xlab(\"Sepal length\") +\n ylab(\"Petal length\") +\n ggtitle(\"Species vs Sepal and Petal lengths\")\n\neuclidean.norm = function(x) {sqrt(sum(x * x))}\n\ndistance.from.plane = function(z,w,b) {\n sum(z*w) + b\n}\n\nclassify.linear = function(x,w,b) {\n distances = apply(x, 1, distance.from.plane, w, b)\n return(ifelse(distances < 0, -1, +1))\n}\n\nperceptron = function(x, y, learning.rate=1) {\n w = vector(length = ncol(x)) # initialize weights\n b = 0 # Initialize bias\n k = 0 # count updates\n R = max(apply(x, 1, euclidean.norm))\n mark.complete = TRUE \n\n while (mark.complete) {\n mark.complete=FALSE \n yc = classify.linear(x,w,b)\n for (i in 1:nrow(x)) {\n if (y[i] != yc[i]) {\n w = w + learning.rate * y[i]*x[i,]\n b = b + learning.rate * y[i]*R^2\n k = k+1\n mark.complete=TRUE\n }\n }\n }\n s = euclidean.norm(w)\n return(list(w=w/s,b=b/s,updates=k))\n}\n\nx = cbind(iris_sub$sepal, iris_sub$petal)\n\ny = ifelse(iris_sub$species == \"setosa\", +1, -1)\n\np = perceptron(x,y)\n\nplot(x,cex=0.2)\n\npoints(subset(x,Y==1),col=\"black\",pch=\"+\",cex=2)\npoints(subset(x,Y==-1),col=\"red\",pch=\"-\",cex=2)\n\nintercept = - p$b / p$w[[2]]\nslope = - p$w[[1]] /p$ w[[2]]\n\nabline(intercept,slope,col=\"green\")\n```", "```py\ndata(iris)\nhead(iris, n=20)\n```", "```py\n> head(iris, n=20)\n Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n11          5.4         3.7          1.5         0.2  setosa\n12          4.8         3.4          1.6         0.2  setosa\n13          4.8         3.0          1.4         0.1  setosa\n14          4.3         3.0          1.1         0.1  setosa\n15          5.8         4.0          1.2         0.2  setosa\n16          5.7         4.4          1.5         0.4  setosa\n17          5.4         3.9          1.3         0.4  setosa\n18          5.1         3.5          1.4         0.3  setosa\n19          5.7         3.8          1.7         0.3  setosa\n20          5.1         3.8          1.5         0.3  setosa\n```", "```py\niris_sub=iris[1:100, c(1, 3, 5)] \nnames(iris_sub)=c(\"sepal\", \"petal\", \"species\") \nhead(iris_sub) \n```", "```py\nlibrary(ggplot2) \n\nggplot(iris_sub, aes(x = sepal, y = petal)) + \n geom_point(aes(colour=species, shape=species), size = 3) +\n xlab(\"Sepal length\") +\n ylab(\"Petal length\") +\n ggtitle(\"Species vs Sepal and Petal lengths\")\n```", "```py\neuclidean.norm = function(x) {sqrt(sum(x * x))}\n\ndistance.from.plane = function(z,w,b) {\n sum(z*w) + b\n}\n\nclassify.linear = function(x,w,b) {\n distances = apply(x, 1, distance.from.plane, w, b)\n return(ifelse(distances < 0, -1, +1))\n}\n\nperceptron = function(x, y, learning.rate=1) {\n w = vector(length = ncol(x)) # initialize weights\n b = 0 # Initialize bias\n k = 0 # count updates\n R = max(apply(x, 1, euclidean.norm))\n mark.complete = TRUE \n\n while (mark.complete) {\n mark.complete=FALSE \n yc = classify.linear(x,w,b)\n for (i in 1:nrow(x)) {\n if (y[i] != yc[i]) {\n w = w + learning.rate * y[i]*x[i,]\n b = b + learning.rate * y[i]*R^2\n k = k+1\n mark.complete=TRUE\n }\n }\n }\n s = euclidean.norm(w)\n return(list(w=w/s,b=b/s,updates=k))\n}\n```", "```py\nx = cbind(iris_sub$sepal, iris_sub$petal)\n\ny = ifelse(iris_sub$species == \"setosa\", +1, -1)\n\np = perceptron(x,y)\n```", "```py\nplot(x,cex=0.2)\n\npoints(subset(x,Y==1),col=\"black\",pch=\"+\",cex=2)\npoints(subset(x,Y==-1),col=\"red\",pch=\"*\",cex=2)\n\nintercept = - p$b / p$w[[2]]\nslope = - p$w[[1]] /p$ w[[2]]\n\nabline(intercept,slope,col=\"green\")\n```", "```py\n###################################################################\n###Chapter 4 - Introduction to Neural Networks - using R ##########\n###Simple RSNNS implementation function in R - iris dataset #######\n###################################################################\n\ndata(iris)\n\nlibrary(\"RSNNS\")\n\niris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)]\n\nirisValues = iris[,1:4]\nirisTargets = decodeClassLabels(iris[,5])\n\niris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15)\niris = normTrainingAndTestSet(iris)\n\nmodel = mlp(iris$inputsTrain, \n iris$targetsTrain, \n size=5, \n learnFuncParams=c(0.1),\n maxit=50, \n inputsTest=iris$inputsTest, \n targetsTest=iris$targetsTest)\n\nsummary(model)\nweightMatrix(model)\n\npar(mfrow=c(2,2))\nplotIterativeError(model)\n\npredictions = predict(model,iris$inputsTest)\n\nplotRegressionError(predictions[,2], iris$targetsTest[,2])\n\nconfusionMatrix(iris$targetsTrain,fitted.values(model))\nconfusionMatrix(iris$targetsTest,predictions)\n\npar(mfrow=c(1,2))\nplotROC(fitted.values(model)[,2], iris$targetsTrain[,2])\nplotROC(predictions[,2], iris$targetsTest[,2])\n\nconfusionMatrix(iris$targetsTrain, \n encodeClassLabels(fitted.values(model),\n method=\"402040\", \n l=0.4, \n h=0.6)) ###################################################################\n```", "```py\n\n install.packages(\"RSNNS\") \n library(\"RSNNS\")\n```", "```py\niris = iris[sample(1:nrow(iris),length(1:nrow(iris))),1:ncol(iris)]\n```", "```py\n> head(iris, n=20)\n Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n75           6.4         2.9          4.3         1.3 versicolor\n112          6.4         2.7          5.3         1.9  virginica\n54           5.5         2.3          4.0         1.3 versicolor\n36           5.0         3.2          1.2         0.2     setosa\n14           4.3         3.0          1.1         0.1     setosa\n115          5.8         2.8          5.1         2.4  virginica\n125          6.7         3.3          5.7         2.1  virginica\n27           5.0         3.4          1.6         0.4     setosa\n8            5.0         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n85           5.4         3.0          4.5         1.5 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n108          7.3         2.9          6.3         1.8  virginica\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n39           4.4         3.0          1.3         0.2     setosa\n84           6.0         2.7          5.1         1.6 versicolor\n2            4.9         3.0          1.4         0.2     setosa\n142          6.9         3.1          5.1         2.3  virginica\n```", "```py\nirisValues = iris[,1:4]\nirisTargets = decodeClassLabels(iris[,5])\n```", "```py\niris = splitForTrainingAndTest(irisValues, irisTargets, ratio=0.15)\niris = normTrainingAndTestSet(iris)\n```", "```py\nmodel = mlp(iris$inputsTrain, \n iris$targetsTrain, \n size=5, \n learnFuncParams=c(0.1),\n maxit=50, \n inputsTest=iris$inputsTest, \n targetsTest=iris$targetsTest)\n```", "```py\nsummary(model)\nweightMatrix(model)\n```", "```py\nplotIterativeError(model)\n```", "```py\npredictions = predict(model,iris$inputsTest)\n```", "```py\nplotRegressionError(predictions[,2], iris$targetsTest[,2])\n```", "```py\nconfusionMatrix(iris$targetsTrain,fitted.values(model))\nconfusionMatrix(iris$targetsTest,predictions)\n```", "```py\n> confusionMatrix(iris$targetsTrain,fitted.values(model))\n predictions\ntargets  1  2  3\n 1 45  0  0\n 2  0 34  3\n 3  0  1 44\n> confusionMatrix(iris$targetsTest,predictions)\n predictions\ntargets  1  2  3\n 1  5  0  0\n 2  0 13  0\n 3  0  0  5\n```", "```py\npar(mfrow=c(1,2))\nplotROC(fitted.values(model)[,2], iris$targetsTrain[,2])\nplotROC(predictions[,2], iris$targetsTest[,2])\n```"]