["```py\nimport tensorflow as tf \nfrom tensorflow.examples.tutorials.mnist import input_data \n#Reading data \nmnist = input_data.read_data_sets(\"./data/\", one_hot-True) \n```", "```py\n> python mnist.py \nSuccessfully downloaded train-images-idx3-ubyte.gz 9912422 bytes. \nExtracting MNIST_data/train-images-idx3-ubyte.gz Successfully downloaded train-labels-idxl-ubyte.gz 28881 bytes. \nExtracting MNIST_data/train -labels -idxl -ubyte.gz \nSuccessfully downloaded tlOk -images -idx3 -ubyte.gz 1648877 bytes. Extracting MNIST_data/t1Ok -images -idx3 -ubyte.gz \nSuccessfully downloaded tlOk -labels -idxl -ubyte.gz 4542 bytes. Extracting MNIST_data/t1Ok -labels -idxl -ubyte.gz \n```", "```py\nimage_size = 28 \nlabels_size = 10 \nlearning_rate = 0.05 \nsteps_number = 1000 \nbatch size = 100 \n```", "```py\n #Define placeholders \n training_data = tf.placeholder(tf.float32, [None, image_size*image_size]) \n labels = tf.placeholder(tf.float32, [None, labels_size]) \n```", "```py\n#Variables to be tuned \nW = tf.Variable(tf.truncated_normal([image_size*image_size, labels_size], stddev=0.1)) \nb = tf.Variable(tf.constant(0.1, shape-[labels_size]))\n```", "```py\n#Build the network \noutput = tf.matmul(training_data, W) + b\n```", "```py\ntf.nn.softmax_cross_entropy_with_logits\n```", "```py\n#Defining the loss \nloss =  tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels-labels, logits-output)) \n# Training step with gradient descent \ntrain_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss) \n```", "```py\n# Accuracy calculation \ncorrect_prediction = tf.equal(tf.argmax(output, 1), tf.argmax(labels, 1)) \naccuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n```", "```py\n# Run the training \nsess = tf.InteractiveSession() sess.run(tf.global_variables_initializer())\n```", "```py\nfor i in range(steps_number): \n    # Get the next batch input_batch, \n    labels_batch = mnist.train.next_batch(batch_size) \n    feed_dict = {training_data: input_batch, labels: labels_batch}\n    # Run the training step \n    train_step.run(feed_dict=feed_dict) \n```", "```py\n# Print the accuracy progress on the batch every 100 steps \nif i%100 == 0: \n    train_accuracy = accuracy.eval(feed_dict=feed_dict) \n    print(\"Step %d, batch accuracy %g %%\"%(i, train_accuracy*100))\n```", "```py\n# Evaluate on the test set \ntest_accuracy = accuracy.eval(feed_dict=ftraining_data: mnist.test.images, labels: mnist.test.labels}) \nprint(\"Test accuracy: %g %%\"%(test_accuracy*100))\n```", "```py\nStep 0, training batch accuracy 13 % \nStep 100, training batch accuracy 80 % \nStep 200, training batch accuracy 87 % \nStep 300, training batch accuracy 81 % \nStep 400, training batch accuracy 86 % \nStep 500, training batch accuracy 85 % \nStep 600, training batch accuracy 89 % \nStep 700, training batch accuracy 90 % \nStep 800, training batch accuracy 94 % \nStep 900, training batch accuracy: 89.49 % \nTest accuracy 91 %\n```", "```py\n$:python mnist.py \n```", "```py\npython mnist.py --export_dir /./mnist_model \n```", "```py\ntoco \\ \n--input_format=TENSORFLOW_GRAPHDEF \n--output_format=TFLITE \\ \n--output_file=./mnist.tflite \\\n--inference_type=FLOAT \\ \n--input_type=FLOAT \n--input_arrays=x \\ \n--output_arrays=output \n--input_shapes=1,28,28,1 \\ \n--graph_def_file=./mnist.pb \n```", "```py\npublic FreeHandView(Context context, AttributeSet attrs) { \n super(context, attrs); \n mPaint = new Paint(); \n mPaint.setAntiAlias(true); \n mPaint.setDither(true); \n mPaint.setColor(DEFAULT_COLOR); \n mPaint.setStyle(Paint.Style.STROKE); \n mPaint.setStrokeJoin(Paint.Join.ROUND); \n mPaint.setStrokeCap(Paint.Cap.ROUND); \n mPaint.setXfermode(null); mPaint.setAlpha(Oxff); \n mEmboss = new EmbossMaskFilter(new float[] I1, 1, 1}, 0.4f, 6, 3.5f); \n mBlur = new BlurMaskFilter(5, BlurMaskFilter.Blur.NORMAL); \n}\n```", "```py\npublic void init(DisplayMetrics metrics, ImageClassifier classifier, BarChart barChart) { \n int height = 1000; \n int width = 1000; \n mBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); \n mCanvas = new Canvas(mBitmap); \n currentColor = DEFAULT_COLOR; strokeWidth = BRUSH_SIZE;\n mClassifier = classifier; \n this.predictionBar = predictionBar; \n this.barChart = barChart; addValuesToBarEntryLabels(); \n}\n```", "```py\nBarChart barChart = (BarChart) findViewByld(R.id.barChart); \n barChart.animateY(3000); \n barChart.getXAxis().setEnabled(true); \n barChart.getAxisRight().setEnabled(false); \n barChart.getAxisLeft().setAxisMinimum(0.0f); // start at zero \n barChart.getAxisLeft().setAxisMaximum(1.0f); // the axis maximum is 100 \n barChart.getDescription().setEnabled(false); \n barChart.getLegend().setEnabled(false);\n// the labels that should be drawn on the X-Axis final String[] barLabels = new String[]{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", n7,1, 118n, n9,1}; \n\n//To format the value as integers\nIAxisValueFormatter formatter = new IAxisValueFormatter() {\n@Override public String getFormattedValue(float value, AxisBase axis) { \n return barLabels[(int) value); }\n};\n barChart.getXAxis().setGranularity(0f); // minimum axis-step (interval) is 1 \n barChart.getXAxis().setValueFormatter(formatter); \n barChart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM); \n barChart.getXAxis().setTextSize(5f);\n```", "```py\n@Override protected void onDraw(Canvas canvas) {\n canvas.save(); \n mCanvas.drawColor(backgroundColor); \n for (FingerPath fp : paths) { \n mPaint.setColor(fp.color); \n mPaint.setStrokeWidth(fp.strokeWidth); \n mPaint.setMaskFilter(null);\n    if (fp.emboss) \n     mPaint.setMaskFilter(mEmboss); \n    else if (fp.blur) \n     mPaint.setMaskFilter(mBlur);\n    mCanvas.drawPath(fp.path, mPaint); \n }\n canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint); canvas. restore(); \n}\n```", "```py\n@Override public boolean onTouchEvent(MotionEvent event) { \n float x = event.getX(); \n float y = event.getY(); \n BarData exampleData; \n switch(event.getAction()) { \n     case MotionEvent.ACTION_DOWN : \n     touchStart(x, y); \n     invalidate(); \n     break; \n     case MotionEvent.ACTION_MOVE : \n     touchMove(x, y); \n     invalidate(); \n     break; \n     case MotionEvent.ACTION_UP : \n     touchUp();\n    Bitmap scaledBitmap = Bitmap.createScaledBitmap(mBitmap,         mClassifier.getImageSizeX(), mClassifier.getImageSizeY(), true); \n     Random rng = new Random(); \n     try { \n     File mFile; \n     mFile = this.getContext().getExternalFilesDir(String.valueOf (rng.nextLong() + \".png\")); \n     FileOutputStream pngFile = new FileOutputStream(mFile); \n     } \n    catch (Exception e){ } \n     //scaledBitmap.compress(Bitmap.CompressFormat.PNG, 90, pngFile); \n     Float prediction = mClassifier.classifyFrame(scaledBitmap); \n     exampleData = updateBarEntry(); \n     barChart.animateY(1000, Easing.EasingOption.EaseOutQuad); \n     XAxis xAxis = barChart.getXAxis(); \n     xAxis.setValueFormatter(new IAxisValueFormatter() {\n     @Override public String getFormattedValue(float value, AxisBase axis) {\n         return xAxisLabel.get((int) value); \n     });\n    barChart.setData(exampleData); \n     exampleData.notifyDataChanged(); // let the data know a // dataset changed \n     barChart.notifyDataSetChanged(); // let the chart know it's // data changed \n     break; \n     } \n return true; \n}\n```", "```py\n public BarData updateBarEntry() { \n     ArrayList<BarEntry> mBarEntry = new ArrayList<>(); \n     for (int j = 0; j < 10; ++j) { \n         mBarEntry.add(new BarEntry(j, mClassifier.getProbability(j))); \n     } \n     BarDataSet mBarDataSet = new BarDataSet(mBarEntry, \"Projects\"); \n     mBarDataSet.setColors(ColorTemplate.COLORFUL_COLORS); \n     BarData mBardData = new BarData(mBarDataSet); \n     return mBardData; \n }\n```", "```py\n/** Memory-map the model file in Assets. */ \nprivate MappedByteBuffer loadModelFile(Activity activity) throws \nI0Exception \n{ \n    AssetFileDescriptor fileDescriptor = activity.getAssets().openFd(getModelPath()); \n    FilelnputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor()); \n    FileChannel fileChannel = inputStream.getChannel(); \n    long startOffset = fileDescriptor.getStartOffset(); \n    long declaredLength = fileDescriptor.getDeclaredLength();         return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength); \n}\n```", "```py\n/** Classifies a frame from the preview stream. */ \npublic float classifyFrame(Bitmap bitmap) \n{ \n    if (tflite == null){ \n    Log.e(TAG, \"classifier has not been initialized; Skipped.\");     return 0.5f; \n    } \nconvertBitmapToByteBuffer(bitmap); // Here's where the classification happens!!! \nlong startTime = SystemClock.uptimeMillis(); \nrunlnference(); \nlong endTime = SystemClock.uptimeMillis(); \nLog.d(TAG, \"Timecost to run model inference: \" + Long.toString(endTime - startTime)); \nreturn getProbability(0); \n}\n```", "```py\n@Override \nprotected void runlnference() \n{ \n    tflite.run(imgData, labelProbArray); \n}\n```", "```py\nBARENTRY = new ArrayList<>(); initializeBARENTRY();\nBardataset = new BarDataSet(BARENTRY, \"project\"); \nBARDATA = new BarData(Bardataset); \nbarChart.setData(BARDATA); \n```", "```py\npaintView.init(metrics, classifier, barChart);\n```", "```py\nresetButton.setOnClickListener(new View.OnClickListener() {\n public void onClick(View v) { \n paintView.clear(); \n }\n}) ;\n```"]