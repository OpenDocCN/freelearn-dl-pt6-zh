["```py\n\nimport tensorflow as tf\n# the code is in tensorflow\nimport numpy as np\n\ndef glimpseSensor(image, fixationLocation):\n    '''\n    Glimpse Sensor for Recurrent Attention Model (RAM)\n    :param image: the image xt\n    :type image: numpy vector\n    :param fixationLocation: cordinates l for fixation center\n    :type fixationLocation: tuple\n    :return: Multi Resolution Representations from Glimpse Sensor\n    :rtype:\n    '''\n\n    img_size=np.asarray(image).shape[:2]\n    # this can be set as default from the size of images in our dataset, leaving the third 'channel' dimension if any\n\n    channels=1\n    # settings channels as 1 by default\n    if (np.asarray(img_size).shape[0]==3):\n        channels=np.asarray(image).shape[-1]\n    # re-setting the channel size if channels are present\n\n    batch_size=32\n    # setting batch size\n\n    loc = tf.round(((fixationLocation + 1) / 2.0) * img_size)\n    # fixationLocation coordinates are normalized between -1 and 1 wrt image center as 0,0\n\n    loc = tf.cast(loc, tf.int32)\n    # converting number format compatible with tf\n\n    image = tf.reshape(image, (batch_size, img_size[0], img_size[1], channels))\n    # changing img vector shape to fit tf\n\n    representaions = []\n    # representations of image\n    glimpse_images = []\n    # to show in window\n\n    minRadius=img_size[0]/10\n    # setting the side size of the smallest resolution image\n    max_radius=minRadius*2\n    offset = 2 * max_radius\n    # setting the max side and offset for drawing representations\n    depth = 3\n    # number of representations per fixation\n    sensorBandwidth = 8\n    # sensor bandwidth for glimpse sensor\n\n    # process each image individually\n    for k in range(batch_size):\n        imageRepresentations = []\n        one_img = image[k,:,:,:]\n        # selecting the required images to form a batch\n\n        one_img = tf.image.pad_to_bounding_box(one_img, offset, offset, max_radius * 4 + img_size, max_radius * 4 + img_size)\n        # pad image with zeros for use in tf as we require consistent size\n\n        for i in range(depth):\n            r = int(minRadius * (2 ** (i)))\n            # radius of draw\n            d_raw = 2 * r\n            # diameter\n\n            d = tf.constant(d_raw, shape=[1])\n            # tf constant for dia\n\n            d = tf.tile(d, [2])\n            loc_k = loc[k,:]\n            adjusted_loc = offset + loc_k - r\n            # location wrt image adjusted wrt image transformation and pad\n\n            one_img2 = tf.reshape(one_img, (one_img.get_shape()[0].value, one_img.get_shape()[1].value))\n            # reshaping image for tf\n\n            representations = tf.slice(one_img2, adjusted_loc, d)\n            # crop image to (d x d) for representation\n\n            representations = tf.image.resize_bilinear(tf.reshape(representations, (1, d_raw, d_raw, 1)), (sensorBandwidth, sensorBandwidth))\n            # resize cropped image to (sensorBandwidth x sensorBandwidth)\n\n            representations = tf.reshape(representations, (sensorBandwidth, sensorBandwidth))\n            # reshape for tf\n\n            imageRepresentations.append(representations)\n            # appending the current representation to the set of representations for image\n\n        representaions.append(tf.stack(imageRepresentations))\n\n    representations = tf.stack(representations)\n\n    glimpse_images.append(representations)\n    # return glimpse sensor output\n    return representations\n```"]