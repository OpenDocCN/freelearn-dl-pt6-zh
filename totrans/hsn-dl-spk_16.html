<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Appendix A: Functional Programming in Scala</h1>
                </header>
            
            <article>
                
<p class="mce-root">Scala combines functional programming and object-oriented programming in a single high-level language. This appendix contains a reference to the principles of functional programming in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional programming (FP)</h1>
                </header>
            
            <article>
                
<p>In FP, functions are first-class citizens—this means that they are treated like any other values and can be passed as arguments to other functions or be returned as a result of a function. In FP, it is also possible to work with functions in the so-called literal form, with no need to name them. Let's look at the following Scala example:</p>
<pre>val integerSeq = Seq(7, 8, 9, 10)<br/>integerSeq.filter(i =&gt; i % 2 == 0)</pre>
<p><kbd>i =&gt; i % 2 == 0</kbd> is a function literal without a name. It checks whether a number is even. It can be passed as another function argument or it can be used as a return value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Purity</h1>
                </header>
            
            <article>
                
<p>One of the pillars of functional programming is pure functions. A pure programming function is a function that is analogous of a mathematical function. It depends only on its input parameters and its internal algorithm and always returns an expected result for a given input, since it doesn't rely on anything from outside. (This is a big difference compared to the OOP methods.) You can easily understand that this makes a function easier to test and maintain. The fact that a pure function doesn't rely on anything else from the outside means that it doesn't have side effects. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Purely functional programs work on immutable data. Rather than altering existing values, altered copies are created while the originals are preserved. This means that they can be shared between the old and new copies because the unchanged parts of the structure cannot be modified. An outcome of this behavior is a significant saving in terms of memory.</p>
<p class="mce-root"/>
<p>Examples of pure functions in Scala (and Java) include the <kbd>size</kbd> method of <kbd>List</kbd> (<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">https://docs.oracle.com/javase/8/docs/api/java/util/List.html</a>) or the <kbd>lowercase</kbd> method of <kbd>String</kbd> (<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html</a>). <kbd>String</kbd> and <kbd>List</kbd> are both immutable, and, as a consequence, all of their methods act like pure functions.</p>
<p>But not all abstractions can be directly implemented with pure functions (some such as reading and writing from a database or object storage or logging). FP provides two approaches that allow developers to deal with impure abstractions in a pure way, therefore making the final code much cleaner and maintainable. The first approach, which is used in some other FP languages but not in Scala, is to extend the language's purely functional core with side effects. Then, the responsibility to avoid using impure functions in situations where only pure functions are expected is up to the developers. The second approach, which happens in Scala, is by introducing side effects to the pure language simulating them with <em>monads</em> (<a href="https://www.haskell.org/tutorial/monads.html">https://www.haskell.org/tutorial/monads.html</a>). This way, while the programming language remains pure and referentially transparent, the monads can provide implicit state by threading it inside them. The compiler doesn't have to know about the imperative features because the language itself stays pure, while, usually, the implementations know about them due to efficiency reasons.</p>
<p>Since pure computations are referentially transparent, they can be performed at any time while still yielding the same result, making it possible to defer the computation of values until they are really needed (lazy computation). This lazy evaluation avoids unnecessary computations and allows infinite data structures to be defined and used.</p>
<p>Allowing side effects only through monads as in Scala and keeping the language pure makes it possible to have a lazy evaluation that doesn't conflict with the effects of impure code. While lazy expressions can be evaluated in any order, the monad structure forces these effects to be executed in the correct order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<p>Recursion is heavily used in FP, as it is the canonical, and often the only, way to iterate. Functional language implementations will often include optimizations based on the so-called <strong>tail recursion</strong> (<a href="https://alvinalexander.com/scala/fp-book/tail-recursive-algorithms">https://alvinalexander.com/scala/fp-book/tail-recursive-algorithms</a>) to ensure that heavy recursion doesn't have a significant or excessive impact on memory consumption. Tail recursion is a particular instance of recursion where the return value of a function is calculated only as a call to itself<em>.</em> Here is a Scala example of calculating a Fibonacci sequence recursively. This first piece of code represents an implementation of the recursive function:<em><br/></em></p>
<pre>def fib(prevPrev: Int, prev: Int) {<br/>    val next = prevPrev + prev<br/>    println(next)<br/>    if (next &gt; 1000000) System.exit(0)<br/>    fib(prev, next)<br/>}</pre>
<p>This other piece of code represents an implementation of the same function in a tail-recursive way:</p>
<pre>def fib(x: Int): BigInt = {<br/>    @tailrec def fibHelper(x: Int, prev: BigInt = 0, next: BigInt = 1): BigInt = x match {<br/>        case 0 =&gt; prev<br/>        case 1 =&gt; next<br/>        case _ =&gt; fibHelper(x - 1, next, (next + prev))<br/>    }<br/>    fibHelper(x)<br/>}</pre>
<p>While the return line of the first function contains a call to itself, it also does something to its output, so the return value isn't really the recursive call's return value. The second implementation is a regular recursive (and in particular tail-recursive) function.</p>


            </article>

            
        </section>
    </body></html>