- en: Creating a Real-Estate Price Prediction Mobile App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the theoretical fundamentals; this chapter,
    on the other hand, will cover the setup of all the tools and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to set up our environment to build a Keras model to predict
    house prices with real estate data. Then we are going to serve this model using
    a RESTful API built using Flask. Next, we will set up our environment for Android
    and create an app that will consume this RESTful API to predict the house price
    based on features of real estate. Finally, we will repeat the same exercise for
    iOS.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is on the setup, tools, libraries, and exercising
    the concepts learned in [Chapter 1](1bfa8853-a79e-4b4a-aa9f-254392b158bb.xhtml), *Artificial
    Intelligence Concepts and Fundamentals*. The use case is designed to be simple,
    yet adaptable enough to accommodate similar use-cases. By the end of the chapter,
    you will be comfortable creating a mobile app for prediction or classification
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the artificial intelligence environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an ANN model for prediction using Keras and Tenserflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving the model as an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android app to predict house prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an iOS app to predict house prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the artificial intelligence environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do is install Python. We are going to use Python throughout
    this book for all our **artificial intelligence** (**AI**) tasks. There are two
    ways to install Python, either through the downloadable executable file provided
    from [https://www.python.org/downloads/](https://www.python.org/downloads/) or
    via Anaconda. Our approach will be the latter, that is, using Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Anaconda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s go to the official Anaconda installation page ([https://conda.io/docs/user-guide/install/index.html#regular-installation](https://conda.io/docs/user-guide/install/index.html#regular-installation))
    and choose the appropriate option based on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ad40de0-48bf-4274-a70a-48405c216193.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Follow the instructions as per the documentation. The installation takes some
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed, let''s test the installation. Open the command prompt
    and type the `conda list` command. You should see a list of libraries and packages
    that have been installed as part of the Anaconda installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf4227c-4431-4666-9847-a5810508a2dc.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do not get this output, please follow the official documentation page
    we saw and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Anaconda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss a few positives of using a package-management tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Anaconda lets us create environments to install libraries and packages. This
    environment is completely independent of the operating system or admin libraries.
    This means we can create user-level environments with custom versions of libraries
    for specific projects, which helps us port the project across operating systems
    with minimal effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda can have multiple environments with different versions of Python and
    supporting libraries. This way, any version mismatch can be avoided and is not
    affected by existing packages and libraries of the operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda comes preloaded with most of necessary packages and libraries for data-science-related tasks,
    including a highly popular and interactive Python editor called Jupyter Notebook.
    Throughout this book, we will be using Jupyter Notebook a lot, mostly when we
    need to interactively code our tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Anaconda environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an environment named `ai-projects` that uses Python version
    3.6\. All our dependencies are going to be installed in this environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, proceed and accept the prompts that you are presented with, you should
    get an output that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2e117d-df7b-4639-a8b6-c7e28ff6b533.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we start installing the dependencies, we need to activate the environment
    we just created using the `activate ai-projects` command, or `source activate
    ai-projects` if you are using bash shell. The prompt will change to indicate that
    the environment has been activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ea56944-b878-4bff-996f-a04e75176c77.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s install TensorFlow. It is an open source framework for building
    **Artificial Neural Network** (**ANN**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output, which indicates a successful installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31ba28b-8559-4a06-872c-9d6f6b0a3c23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also manually check the installation. Type `python` to open the Python
    prompt on the command line. Once inside the Python prompt, type `import tensorflow`
    and hit *Enter*. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c27ee804-673f-4076-aaf8-9cdbe2fa926c.png)'
  prefs: []
  type: TYPE_IMG
- en: Type `exit()` to return to the default command line, keep in mind that we are
    still inside the `ai-projects` conda environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to install Keras, a wrapper over TensorFlow that makes designing
    deep neural networks much more intuitive. We continue to use the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On successful installation, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0c4df7c-c974-497b-8602-3630003cd1b9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To manually check the installation, type `python` to open the Python prompt
    on the command line. Once inside the Python prompt, type `import keras` and hit
    *Enter*. You should see the following output, with no errors. Observe that the
    output mentions that Keras is using TensorFlow as its backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaa69964-684b-40a2-86f6-8612d33bd511.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great! We have now installed the main dependencies required to create our very
    own neural networks. Let's go ahead and build an ANN to predict real estate prices.
  prefs: []
  type: TYPE_NORMAL
- en: Building an ANN model for prediction using Keras and TensorFlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our libraries installed, let''s create a folder called `aibook`
    and within that create another folder called `chapter2`. Move all the code for
    this chapter into the `chapter2` folder. Make sure that the conda environment
    is still active (the prompt will start with the environment name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f8d52ea-805c-46a4-8937-ef6c14f333d2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once within the `chapter2` folder, type `jupyter notebook`. This will open an
    interactive Python editor on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the New dropdown in the top-right corner to create a new Python 3 notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e30c7760-1f13-4aa1-ab80-9b62b18f8643.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready to build our first ANN using Keras and TensorFlow, to predict
    real estate prices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the libraries that we need for this exercise. Use the first cell
    to import all the libraries and run it. Here are the four main libraries we will
    use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pandas`: We use this to read the data and store it in a dataframe'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sklearn`: We use this to standardize data and for k-fold cross-validation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keras`: We use this to build our sequential neural network'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numpy`: We use `numpy` for all math and array operations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s import these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the real estate housing data using `pandas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the feature variables, the target variables, and a few rows of the
    data, enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This output will be a few rows of `dataframe`, which is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/251b1699-eadc-4873-a7ae-87182e276c88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The dataset has eight columns, details of each column are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: BIZPROP: Proportion of non-retail business acres per town
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROOMS: Average number of rooms per dwelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AGE: Proportion of owner-occupied units built before 1940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HIGHWAYS: Index of accessibility to radial highways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TAX: Full-value property tax rate per $10,000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PTRATIO: Pupil-to-teacher ratio by town'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LSTAT: Percentage of lower status of the population
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VALUE: Median value of owner-occupied homes in thousand dollars (target variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our use case, we need to predict the VALUE column, so we need to split the
    dataframe into features and target values. We will use a 70/30 split, that is,
    70% of data for training and 30% data for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to make sure we can reproduce the results, let''s set a seed for random
    generation. This random function is used during cross-validation to randomly sample
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to build our ANN:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a sequential neural network that has a simple and shallow architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make a function called `simple_shallow_seq_net()` that will define the architecture
    of the neural network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A sequential model is instantiated – a sequential model is an ANN model built
    using a linear stack of layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding a dense layer or fully-connected layer with seven neurons
    that are added to this sequential network. This layer accepts an input with `7`
    features (since there are seven input or features for predicting house price),
    which is indicated by the `input_dim` parameter. The weights of all the neurons
    in this layer are initialized using a random normal distribution, as indicated
    by the `kernel_initializer` parameter. Similarly, all the neurons of this layer
    use the sigmoid activation function, as indicated by the `activation` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another layer with a single neuron initialized using a random normal distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the network to use **Scalar Gradient Descent** (**SGD**) to learn, usually
    specified as `optimizers`. We also indicate that the network will use a learning
    rate (`lr`) of `0.01` at every step of learning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Indicate that the network needs to use the **mean squared error** (**MSE**)
    cost function to measure the magnitude of the error rate of the model, and use
    the SGD optimizer to learn from the wrongness measured or loss of the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the function returns a model with the defined specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set a random seed for reproducibility; this random function
    is used to split the data into training and validation. The method used is k-fold
    validation, where the data is randomly divided into 10 subsets for training and
    validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to fit this model to predict a numerical value (house price, in
    this case), therefore we use `KerasRegressor`. `KerasRegressor` is a Keras wrapper
    used to access the regression estimators for the model from `sklearn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass `simple_shallow_seq_net`as a parameter to indicate the function that
    returns the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `epochs` parameter indicates that every sample needs to go through the network
    at least `100` times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `batch_size` parameter indicates that during every learning cycle of the
    network there are `50` training samples used at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to train and cross-validate across the subsets of the data
    and print the MSE, which is the measure of how well the model performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the MSE – as you can see, it is pretty high and we need to
    make this value as low as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this model for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we have built and saved our first neural net to predict real estate
    price. Our next efforts are to improve the neural net. The first thing to try
    before fiddling with the network parameters is to improve its performance (lower
    the MSE) when we standardize the data and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a pipeline to standardize the data and then
    use it during every learning cycle of the network. In the following code block,
    we train and cross-evaluate the neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a much better MSE than before, hence standardizing and using
    the data makes a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving this model is slightly different than before as we have used  `pipeline`
    to fit the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now fiddle with our network to see whether we can get better results.
    We can start by creating a deeper network. We will increase the number of hidden
    or fully-connected layers and use both the `sigmoid` and `tanh` activation functions
    in alternate layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code is used to standardize the variables in the training
    data and then fit the shallow neural net model to the training data. Create the
    pipeline and fit the model using standardized data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to cross-validate the fit model across the subsets of the data
    and print the MSE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output an MSE that is better than the previous shallow networks that
    we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the model for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we get better results when we increase the depth (layers) of the network.
    Now, let''s see what happens when we widen the network, that is, increase the
    number of neurons (nodes) in each layer. Let''s define a deep and wide network
    to tackle the problem, we increase the neurons in each layer to `21`. Also, this
    time around, we will use the `relu` and `sigmoid` activation functions for the
    hidden layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code is used to standardize the variables in the training
    data and then fit the deep and wide neural net model to the training data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to cross-validate the fit model across the subsets of the data
    and print the MSE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the MSE is again better than the previous networks we created. This
    is a good example of how a deeper network with more neurons abstracts the problem
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, save the network for later use. The saved network model will be used
    in the next section and served within a REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been able to build a sequential neural network for prediction
    using various network architectures. As an exercise, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with the shape of the network; play around with the depth and width
    of the network to see how it impacts the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try out the various activation functions ([https://keras.io/activations/](https://keras.io/activations/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try out the various initializers, here we have only used the random normal initializer
    ([https://keras.io/initializers/](https://keras.io/initializers/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data we used here is for demonstrating the technique, so try out different
    use cases for prediction using the preceding technique on other datasets ([https://data.world/datasets/prediction](https://data.world/datasets/prediction))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about optimizers and regularizers, which are other parameters
    you can use to tune the network, in [Chapter 4](ed2667d7-0173-498a-ae53-1010580cf1de.xhtml), *Building
    a Machine Vision Mobile App to Classify Flower Species*. The complete code for
    our ANN model creation is available as a Python notebook named `sequence_networks_for_prediction.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the model as an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a model for prediction, the next thing is to serve
    this model via a RESTful API. To achieve this, we will use lightweight Python
    framework called Flask: [http://flask.pocoo.org/](http://flask.pocoo.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing the `Flask` library in our conda environment if
    it does not already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Building a simple API to add two numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will build a very simple API to get a grip on the `Flask` library and
    framework. This API will accept a JSON object with two numbers and return the
    sum of the numbers as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new notebook from your Jupyter home page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the libraries we need and create an app instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the index page for the RESTful API using the `route()` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `POST` API to add two numbers using the `route()` decorator. This
    API accepts a JSON object with the numbers to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Save the Python notebook and use the File menu to download the notebook as a
    Python file. Place the Python file in the same directory as the model file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new command terminal and traverse to the folder with this Python file
    and the model. Make sure to activate the conda environment and run the following
    to start a server running the simple API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Windows, enter the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you aren''t using Windows, enter this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output when the server starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77ddebb5-0ed8-49cd-8ae8-66da25492323.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the browser and paste this address in the URL bar to go to the index page: `http://127.0.0.1:5000/`.
    Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43df027c-5e68-4e2e-aa8e-5c3233c7e2be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will use `curl` to access the `POST` API that adds two numbers. Open
    a new terminal and enter the following curl command to test the `/add` API. The
    numbers to add in this example are `1` and `2`, and this is passed as a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get a response with the sum of the numbers if there are no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cec53b9e-bbf0-43d0-b2ad-18bfda3a0dab.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete code for the simple API is available as a Python notebook named
    `simple_api.ipynb` and as a Python file named `simple_api.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Building an API to predict the real estate price using the saved model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen how  `Flask` works, we need to implement an API to serve
    the model we built previously. Start a new Jupyter Notebook and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required Python modules and create a Flask app instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Index page` for the RESTful API using the `route()` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `POST` API to predict house price using the `route()` decorator. This
    accepts a JSON object with all the features required to predict the house or real
    estate price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Save the Python notebook and use the File menu to download the notebook as a
    Python file. Place the Python file in the same directory as the model file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new command terminal and traverse to the folder with this Python file
    and the model. Make sure to activate the conda environment and run the following
    to start a server that runs the simple API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Windows, enter the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you aren''t using Windows, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use `curl` to access the `POST` API that predicts house prices.
    Open a new terminal and enter the following `curl` command to test the `/predict` API.
    We can pass the features to be used as input for the model as a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the house price for the features provided using our prediction
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19cdc927-bbf0-4479-b019-3ee9ddec2f73.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! We just built an API to serve our prediction model and tested it
    using `curl`. The complete code for the prediction API is available as a Python
    notebook named `predict_api.ipynb` and as a Python file named `simple_api.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to see how to make a mobile app that will use the API that
    hosts our model. We will start by creating an Android app that uses the prediction
    API and then repeat the same task on an iOS app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android app to predict house prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to consume the model through the RESTful API
    via an Android app. The purpose of this section is to demonstrate how a model
    can be consumed and used by an Android app. Here, we have assumed that you are
    familiar with the basics of Java programming. The same approach can be used for
    any similar use case, even on web apps. The following steps are covered in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Android project with a single screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the layout of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a functionality to accept input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a functionality to consume the RESTful API that serves the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and installing Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio is the development environment and sandbox for Android app development.
    All our Android projects will be made using Android Studio. We can use Android
    Studio to create, design, and test our apps before publishing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the official Android Studio download page, [https://developer.android.com/studio/](https://developer.android.com/studio/),
    and choose the version that matches your OS. In this case, we are using a Windows
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d203e0-62e1-4319-87dd-91084a31fc4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the executable once it is downloaded to start the installation process.
    You will be presented with progressive installation menu choices. Choose Next
    and progress through the installation process. Most of the options are chosen
    as default during the installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Android project with a single screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have installed Android Studio, we will create a simple app to estimate
    the price of real estate based on certain input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we start Android Studio, it gives us a menu to start creating projects.
    Click on the Start a new Android Studio project option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4131112d-51a2-4203-a771-42bd378e4f3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next dialog is to select the Application name and Project location. Choose
    whatever you want and click Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9aae155-2d19-4601-878a-fd8008993202.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, choose the target versions for the application to run on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ba1f6d5-aa22-4139-b019-a890b09584de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then choose a screen for the app; in this case, select an Empty Activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88b0a687-fec0-4f7f-af95-54a2a79ccb4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose the screen or Activity Name and the corresponding name for the layout
    or design of the activity screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80508382-73a6-420d-b677-60fe007b8dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The project should load in a few seconds after the build is complete. In the
    project structure, there are three main folders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'manifests: This folder contains the manifest file used for permissions and
    application versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'java: This folder has all the Java code files (java|app|chapter2|realestateprediction|MainActivity.java).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'res: This folder has all the layout files and media files used in the application
    (res|layout|activity_main.xml):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5821d790-164b-41e5-81d8-0e771d0a4d36.png)'
  prefs: []
  type: TYPE_IMG
- en: Designing the layout of the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s design the screen that will accept the factors of the model we created
    as input. The screen will have seven input boxes to accept the factors, one button,
    and an output textbox to display the predicted result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b6aa2a2-7cdf-432b-b49c-5a1a058e6afd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Traverse to thelayout folder in res and select the activity_layout.xml file
    to open in the editing panel. Choose the Text option at the bottom to view the
    existing XML for the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/073f2eb7-11ec-4426-899a-2693b6247880.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, replace the existing XML code with the new design template for the app.
    Please refer to the activity_layout.xml code file in the Android folder for the
    full design template. The following is only a skeletal reference of the XML code
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have designed a layout to accept the seven factors as input, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'BIZPROP: Proportion of non-retail business acres per town'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ROOMS: Average number of rooms per dwelling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A****GE**: Proportion of owner-occupied units built prior to 1940'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HIGHWAYS**: Index of accessibility to radial highways'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TAX**: Full-value property-tax rate per $10,000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PTRATIO**: Pupil-to-teacher ratio by town'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LSTAT**: Percentage of lower status of the population'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a button and a textbox to display the output. The predicted value
    is displayed when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the design of the activity, run the Run app option in the **run** menu
    from the top menu bar. The first time you run it, the environment will ask you
    to create a virtual device to test your app. You can either create an **Android
    Virtual Device** (**AVD**) or use the traditional method, that is, use an USB
    cable to connect your Android phone to the PC so that you can run the output directly
    on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e518d696-637a-457a-be1a-121b5203a0f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see the design of the scrollable layout once the app starts on the
    device or AVD emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8e556b-4586-4f6b-9e1e-cea5afd364c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a functionality to accept input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to accept the input and create a map to hold the values. We will
    then convert the map into a JSON object so that it can be passed as the data in
    the `POST` API request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traverse to the `MainActivity.java` file and open it in the edit panel of Android
    Studio. Declare the following class variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find a function called `onCreate()` that is already created. Add the
    following code into the `onCreate()` function to initialize the elements of the
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add another function called `makeJSON()` to the Java class. This function
    accepts the values from the edit boxes and returns the JSON object we need to
    pass as data in our API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Adding a functionality to consume the RESTful API that serves the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to hit the API with the data on a click of the button. To achieve
    this, we need the flowing helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByPostMethod`: Accepts the URL as a `String` and returns the response as an
    `InputStream`.  This function takes the server URL string that we created using
    the Flask framework and returns the response from the server as an input stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`ConvertStreamToString`: This function accepts `InputStream` and returns a
    `String` of the response. The input stream returned from the previous function
    is processed as a string object by the following function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`DisplayMessage`: This functions updates the textbox with the response, which
    is the predicted value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A point to note is that whenever network calls are made on Android, it is a
    best practice to do it on a separate thread so it does not block the main **user
    interface** (**UI**) thread. So, we will write an inner class called `MakeNetworkCall`
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we used `http://10.0.2.2:5000/predict` instead of `http://127.0.0.1:5000/predict`.
    This is done because in Android, when we use the emulator, it accesses the local
    host via `10.0.2.2` instead of `127.0.0.1`. As the example is run on an emulator,
    we used `10.0.2.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add the functionality to call the API on click of the button.
    So, within the `oncreate()` method, insert the following code after the button
    has been initialized. This will initiate a background thread to access the API
    on a click of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add permissions to use internet within the `AndroidManifest.xml`
    file. Place the following code inside the `<manifest>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to run your Flask app. If you haven''t already, make sure to
    run it within the conda environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all the code required to run and test the app on Android. Now run the
    app in the emulator, enter the details on the screen, hit the ESTIMATE VALUE button,
    and you''ll get immediate results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe3b6dbc-7420-4f10-9f37-995f866d0c02.png)'
  prefs: []
  type: TYPE_IMG
- en: Additional notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was a demonstration of how we can use the AI models built on an Android
    device. Having said that, there are a lot of additional tasks that can be added
    to the existing app:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the UI design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add input checks to validate the data entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host the Flask app (Heroku, AWS, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tasks are independent of our core AI theme, so can be addressed as
    an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an iOS app to predict house prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to consume the model through the RESTful API
    via an iOS app. The purpose of this section is to demonstrate how a model can
    be consumed and used by an iOS app. Here, we have assumed that you are familiar
    with Swift programming. The same approach can be used for any similar use case.
    These are the following steps covered in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new iOS project with a single screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the layout of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a functionality to accept input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a functionality to consume the RESTful API that serves the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and installing Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need a Mac (macOS 10.11.5 or later) to develop the iOS apps that are implemented
    in this book. Also, the latest version of Xcode is required to run those codes
    since it contains all the features that are necessary to design, develop, and
    debug any app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the latest version of Xcode, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the App Store on your Mac (it's in the Dock by default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Xcode` in the search field, which is at the top-right corner. Then press
    the return key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first search result that turns up is the Xcode app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Get and then click on Install App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your Apple ID and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xcode will be downloaded in your `/Applications` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new iOS project with a single screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xcode includes several built-in app templates. We will start with a basic template:
    Single View Application. Open Xcode from the `/Applications` directory to create
    a new project.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are launching Xcode for the first time, it may ask you to agree to all
    the user agreements. Proceed by clicking on these prompts until Xcode is set up
    and ready to launch on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we launch Xcode, the following window appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a6aa306-1b07-4f5a-a055-31e05a850377.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create a new Xcode project. A new window will open that displays a
    dialog box that allows us to select the required template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbdc672b-af4c-4db8-b9b2-fba77d240fea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we select a template, a dialog box appears. Here, you need to name your
    app for which you can use the following values. You can also choose some additional
    options for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product Name**: Xcode will use the product name that you entered to name
    both the project and the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team**: If there''s no value filled in, set the team to None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization Name**: This is an optional field. You can either enter your
    organization''s name or your name. You may also choose to leave this option blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization Identifier**: If you have an organization identifier, use that
    value. If you don''t, use `com.example`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle Identifier**: This value is automatically generated based on your
    product name and organization identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Swift.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: Universal. An app that runs on both iPhones and iPads is considered
    a universal app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Core Data**: We don''t need any core date. Hence, it remains unselected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include Unit Tests**: We need to include unit tests. So this option will
    be selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include UI Tests**: We don''t need to include any  UI tests. Hence, this
    option stays unselected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, click on Next. A dialog box will appear, where you need to select a location
    to save your project. After saving the project, click on Create. You new project
    will be opened by Xcode in the workspace window.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the layout of the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s design the screen that will accept the factors of the model we created
    as input. The screen will have seven input boxes to accept the factors, one button,
    and an output textbox to display the predicted result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/589a76d7-b37b-4dc7-9362-302898467a83.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's work on the storyboard that is required for the app. What is a storyboard? A
    storyboard displays the screen of content and the transitions between that content.
    It gives us a visual representation of the application's UI. We get a **WYSIWYG** (short
    for **what you see is what you get**) editor where we can see the changes in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the storyboard, select the Main.storyboard option in the project navigator. This
    will open a canvas where we can design the screen. We can now add elements and
    design the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/675b1bb5-e59c-4d18-a961-81fc301bccbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same can also be coded instead of using the drag-and-drop approach. To
    do so, start by defining the text fields that are used as input in the `ViewController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Then, within the `CreateView` method, we implement the design of each text field.
    The following is the sample for the first couple of text fields; the same approach
    can be used for the rest of the text fields. The completed project code is available
    in the `chapter2_ios_prediction` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a header text field, `Estimate the value of real estate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create another text field, `Enter real estate details`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a field to enter the input for a proportion of non-retail business
    in acres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a field to enter the input for the average number of rooms per dwelling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a button to hit the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Adding a functionality to accept input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, all the input from the text fields are packaged in an `NSString` object,
    which is used in the `POST` body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Adding a functionality to consume the RESTful API that serves the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to use the `NSURLSession` object to hit the RESTful API with the
    input from the activity screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, display the output from the response received from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The app can now run and is ready to be tested on the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Additional notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was a demonstration of how we can use AI models on an iOS device. Having
    said that, there are a lot of tasks that can be added to the existing app:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the UI design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add input checks to validate the data entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host the Flask app (Heroku, AWS, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tasks are independent of our core AI theme, so they can be addressed
    as an exercise for the reader. The complete code and project files for both the
    Android and iOS apps are available as `chapter2_android_prediction` and `chapter2_ios_prediction`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic sequential network and consumed it on
    mobile devices. In the next chapter, we will take a look at a special kind of
    network called **Convolutional Neural Networks** (**CNN**). CNNs are the most
    common networks used with Machine Vision. Our goal in the next chapter is to get
    comfortable with machine vision and to build our own custom-purpose CNNs.
  prefs: []
  type: TYPE_NORMAL
