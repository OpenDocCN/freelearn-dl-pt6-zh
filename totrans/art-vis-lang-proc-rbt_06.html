<html><head></head><body>
		<div id="_idContainer172" class="Content">
			<h1 id="_idParaDest-106"><em class="italics"><a id="_idTextAnchor142"/>Chapter 6</em></h1>
		</div>
		<div id="_idContainer173" class="Content">
			<h1 id="_idParaDest-107"><a id="_idTextAnchor143"/>Robot Operating System (ROS)</h1>
		</div>
		<div id="_idContainer174" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain Robot Operating System (ROS) essentials and basic concepts</li>
				<li class="bullets">Create Robot Operating System packages and work with them</li>
				<li class="bullets">Operate a virtual robot with information obtained from sensors</li>
				<li class="bullets">Develop and implement working programs for robots</li>
			</ul>
			<p>This chapter focuses on ROS and the different ways to work with its packages. You'll also learn how to operate a virtual robot based on the information received from its sensors using ROS.</p>
		</div>
		<div id="_idContainer184" class="Content">
			<h2 id="_idParaDest-108"><a id="_idTextAnchor144"/><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/><a id="_idTextAnchor147"/><a id="_idTextAnchor148"/>Introduction</h2>
			<p>Developing software for robots is not as easy as developing any other type of software. To build robots, you need methods and functions that enable you to access sensor information, control robot parts, and connect with the robot. These methods and functions are present in ROS, making it easier to build a virtual robot.</p>
			<p><strong class="keyword">ROS</strong> is a framework that is compatible with Ubuntu (Linux) for writing robot software. It is a set of libraries and tools through which it is possible to build and create various robotic behaviors. One of the most interesting features about this framework is that the developed code can be adapted for any other robot. ROS also gives you a chance to work on several machines simultaneously; for instance, if you want to use a robot to collect apples, you can use a computer to obtain the camera information of the apple and process it, another machine to launch the movement that commands the robot, and finally the robot will pick up the apple. By following this workflow, computers won't perform too many computational tasks, and the execution turns out to be more fluid.</p>
			<p>ROS is the most widely used tool for robotics, both for researchers and companies. It is becoming a standard for robotics tasks. Furthermore, ROS is constantly evolving to solve new problems and is adapting to different technologies. All these facts make it a good topic for studying and practicing.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor149"/>ROS Concepts</h2>
			<p>As mentioned earlier, working with ROS is not easy the first time round. But just like any other software, you need to know how ROS works and how to perform certain tasks using it. In order to do that and before installing or working with the framework, it is important to understand its basic concepts. The key ideas behind ROS' functions that will help you understand its internal processes are mentioned here:</p>
			<ul>
				<li><strong class="keyword">Node</strong>: An ROS node is a process in charge of performing tasks and calculations. They can be combined with each other using topics or other more complex tools.</li>
				<li><strong class="keyword">Topic</strong>: Topics can be defined as information channels between nodes that work in a unidirectional way. This is considered a unidirectional workflow because nodes can subscribe to topics, but a topic would not know which nodes are subscribed to it.</li>
				<li><strong class="keyword">Master</strong>: The ROS master is a service that provides a name and registration to the remaining nodes. Its main function is to enable individual nodes so that they can locate each other and establish peer-to-peer communication.</li>
				<li><strong class="keyword">Package</strong>: Packages are the core of ROS organization. Within these packages, you can find nodes, libraries, datasets, or useful components to build a robotics application.</li>
				<li><strong class="keyword">Stack</strong>: An ROS stack is a set of nodes that, all together, provide some functionality. It can be useful for dividing tasks between nodes when the functionality to develop is too complex.</li>
			</ul>
			<p>Apart from the aforementioned concepts, there are many other concepts that can be useful when using ROS, but understanding these basic ones will let you implement powerful programs for robots. Let's look at a simple example in order to learn how they would be used in a real situation:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/C13550_06_01.jpg" alt="Figure 6.1: A schema of a real example system using ROS"/>
				</div>
			</div>
			<h6>Figure 6.1: A schema of a real example system using ROS</h6>
			<p>The situation here consists of a robot changing its direction when detecting a close obstacle. This is how it works step by step:</p>
			<ol>
				<li>The ROS master is enabled. This means the ROS system has been started and can have any node run.</li>
				<li>The proximity node starts and extracts information from the laser sensor. It advertises the master to publish this obtained information. If there's no problem and the information has the expected type, the master will allow the node to publish through a topic.</li>
				<li>Once the master allows the node to publish, the information is passed to a topic and published. In this case, the proximity node publishes the information in the laser topic.</li>
				<li>The movement node asks the master to subscribe to a laser topic. When subscribed, it will obtain the published information and work with it to decide the next action for the robot to perform.</li>
			</ol>
			<p>To sum up, both nodes can share information using the master service, which notifies both nodes about each other's existence.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor150"/>ROS Commands</h2>
			<p>ROS doesn't have a graphical user interface to work with it; every action must be performed on the command line as it is compatible with Ubuntu. However, before getting your hands on the ROS, you need to learn about its most common commands. Here's a short list of them and their functionality:</p>
			<ul>
				<li><strong class="keyword">roscore</strong>: This is the first command to be run when working with ROS. It enables the framework and provides support to any ROS program or operation. It should be launched in order to allow node communication.</li>
				<li><strong class="keyword">roscd</strong>: This command switches to a stack or package directory without entering a physical path.</li>
				<li><strong class="keyword">rosnode</strong>: These commands manage nodes and obtain information about them. Here, you can see the most used rosnode commands:</li>
				<li><strong class="keyword">rosnode list</strong>: This command prints the information of active nodes.</li>
				<li><strong class="keyword">rosnode info &lt;node_name&gt;</strong>: This informs the user about the entered node.</li>
				<li><strong class="keyword">rosnode kill &lt;node_name&gt;</strong>: The function of this command is to stop a node process.</li>
				<li><strong class="keyword">rosrun</strong>: Using this command, you can run any application on your system without switching to its directory.</li>
				<li><strong class="keyword">rostopic</strong>: This command allows you to manage and check topic information. There are several other types for this command:</li>
				<li><strong class="keyword">rostopic list</strong>: This type prints the information of active topics.</li>
				<li><strong class="keyword">rostopic info &lt;topic_name&gt;</strong>: This shows information about a concrete topic.</li>
				<li><strong class="keyword">rostopic pub &lt;topic_name&gt; [data...]</strong>: The function of this command is to publish the given data to the entered topic.</li>
				<li><strong class="keyword">rqt_graph</strong>: This is a very useful command that can be used to graphically observe active nodes and topics that are being published or subscribed to.</li>
			</ul>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor151"/>Installation and Configuration</h2>
			<p>The first thing to consider before installing ROS is the installed Ubuntu version. There are several ROS versions that you will have to choose from depending on your operating system version. In this case, we are explaining the installation of ROS Kinetic Kame, which is compatible with Ubuntu 16.04 LTS (Xenial Xerus).</p>
			<h4>Note</h4>
			<p class="callout">If this is not your Ubuntu version, you can head to the ROS website, <a href="http://www.ros.org/">http://www.ros.org/</a>, and look for the corresponding distribution.</p>
			<p>As happens with almost every other tool, it is recommended to always install the latest version, because it may have solved errors or new functionalities; but, as mentioned before, don't worry if you're working with an older version.</p>
			<h4>Note</h4>
			<p class="callout">To get detailed steps on how to install ROS, refer to the preface on page vi.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor152"/>Catkin Workspaces and Packages</h2>
			<p>This is the last step before coding your first application and program for robots. You have to set up your working environment. To do this, you are going to learn what catkin workspaces and packages are and how to work with them.</p>
			<p>A catkin workspace is a ROS directory where catkin packages can be created, compiled, and run. A catkin package is a container for creating ROS nodes and applications. Each of these packages work as a single project that can contain multiple nodes. It is important to know that the ROS code inside catkin packages can only be Python or C++.</p>
			<p>Now, let's see how to create the catkin workspace:</p>
			<h4>Note</h4>
			<p class="callout">Execute these commands in the same terminal window.</p>
			<ol>
				<li value="1">Create a standard folder containing a subfolder named "<strong class="inline">src</strong>." You can choose any location on your system:<p class="snippet">mkdir -p ~/catkin_ws/src</p><p class="snippet">cd ~/catkin_ws</p></li>
				<li>Switch to the new <strong class="inline">catkin_ws</strong> directory and run the <strong class="inline">catkin</strong> compilation command to initialize the new workspace:<p class="snippet">catkin_make</p><p>This command must be executed every time you want to compile your workspace when making changes in any package.</p></li>
			</ol>
			<p>By following these simple steps, you will have your catkin workspace ready to work with. But, when working on it, you should always remember to enter this command first:</p>
			<p class="snippet">source devel/setup.bash</p>
			<p>This lets ROS know that there can be ROS executables in the created catkin workspace.</p>
			<p>If you have successfully completed the preceding process, you can now create your catkin packages and work on them. Create a package with the steps mentioned here:</p>
			<ol>
				<li value="1">Go into the "<strong class="inline">src</strong>" folder of your catkin workspace:<p class="snippet">cd ~/catkin_ws/src</p></li>
				<li>Use this command to create a package:<p class="snippet">catkin_create_pkg &lt;package_name&gt; [dependencies]</p></li>
			</ol>
			<p>The dependencies are a set of libraries or tools that the package needs to function correctly. For example, in a simple package where you only use Python code, the command will be as follows:</p>
			<p class="snippet">catkin_create_pkg my_python_pkg rospy</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor153"/>Publishers and Subscribers</h2>
			<p>When explaining basic ROS concepts, we discussed a few nodes used for publishing data and some others used for subscribing to that data. Knowing this, it is not hard to imagine that nodes can be classified into two groups, depending on the kind of action they perform. They can be <strong class="bold">publishers</strong> or <strong class="bold">subscribers</strong>. Why do you think it is important to distinguish between these two types of nodes?</p>
			<p>As mentioned earlier, publishers are nodes that provide information to other nodes. They usually work with sensors to check the environment status and convert it into valuable outputs for subscribers that can receive this information.</p>
			<p>On the other hand, subscribers usually get an understandable input and process it. They then decide which action will be launched depending on the obtained result.</p>
			<p>As this is a rarely used type of programming, it will be interesting to follow some examples of how these nodes really work, before starting to use them with robots and simulators. So, let's go through some exercises that will help you understand nodes.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor154"/>Exercise 20: Publishing and Subscribing</h3>
			<p>In this example, we will write a simple publisher and subscriber in Python using the following steps:</p>
			<ol>
				<li value="1">Open a new terminal and enter the <strong class="inline">roscore</strong> command to start the ROS service:<p class="snippet">roscore</p></li>
				<li>Create a new package in your catkin workspace that contains the solution to this exercise. This package will depend on <strong class="inline">rospy</strong> and <strong class="inline">std_msgs</strong>, so you must create it as follows:<p class="snippet">catkin_create_pkg exercise20 rospy std_msgs</p><h4>Note</h4><p class="callout"><strong class="inline">std_msgs</strong> is a package that provides support to ROS primitive data types. You can find more information about it, including the concrete types of managed data, here: <a href="http://wiki.ros.org/std_msgs">http://wiki.ros.org/std_msgs</a>.</p></li>
				<li>Switch to the package directory and create a new folder, which will contain publisher and subscriber files, for example:<p class="snippet">cd ~/catkin_ws/src/exercise20</p><p class="snippet">mkdir –p scripts</p></li>
				<li>Go into the new folder and create a corresponding Python file for each node:<p class="snippet">cd scripts</p><p class="snippet">touch publisher.py</p><p class="snippet">touch subscriber.py</p></li>
				<li>Provide the executable permission to both files:<p class="snippet">chmod +x publisher.py</p><p class="snippet">chmod +x subscriber.py</p></li>
				<li>Begin with the publisher implementation:<p>Initialize the Python environment and import the necessary libraries.</p><h4>Note</h4><p class="callout">This code needs to be added in a <strong class="inline">publisher.py</strong> file.</p><p class="snippet">#!/usr/bin/env python</p><p class="snippet">import rospy</p><p class="snippet">from std_msgs.msg import String</p><p>Create a function to publish the message.</p><p class="snippet">def publisher():</p><p>Declare a publisher that publishes a <strong class="inline">String</strong> message into a new topic, no matter its name.</p><p class="snippet">    pub  =rospy.Publisher('publisher_topic', String, queue_size=1)</p><h4>Note</h4><p class="callout">As the ROS publishing process is asynchronous, a queue is created containing published messages. For ROS to register the amount of messages a queue can store, the size value of this queue must be established each time a publisher is created. In this case, we pick a size of 1 because we are going to publish the same message all the time.</p><p>Initialize the node with the <strong class="inline">init_node</strong> method. It is a good practice to set the anonymous flag to true when initializing a node. This is how naming conflicts can be avoided:</p><p class="snippet">    rospy.init_node('publisher', anonymous=True)</p><p>Use the created publisher variable to publish any desired <strong class="inline">String</strong>. For instance:</p><p class="snippet">    pub.publish("Sending message")</p><p>Finally, detect the program entry and call the created function:</p><p class="snippet">if __name__ == '__main__':</p><p class="snippet">    publisher()</p></li>
				<li>Continue with the subscriber implementation:<p>Initialize Python and import libraries as you did for your publisher.</p><h4>Note</h4><p class="callout">This code needs to be added in the <strong class="inline">subscriber.py </strong>file.</p><p class="snippet">#!/usr/bin/env python</p><p class="snippet">import rospy</p><p class="snippet">from std_msgs.msg import String</p><p>Create a function to subscribe to the topic:</p><p class="snippet">def subscriber():</p><p>Initialize the node in the same way as you did before:</p><p class="snippet">    rospy.init_node('subscriber', anonymous=True)</p><p>Subscribe to <strong class="inline">publisher_topic</strong> using this function:</p><p class="snippet">    rospy.Subscriber('publisher_topic', String, callback)</p><h4>Note</h4><p class="callout">The third parameter of the Subscriber call is a callback function, which means that it is a function not called by the user. The function pointer is passed to other components, the subscriber in this case, which will call the function when it seems appropriate. To sum up, the callback function will be launched every time the subscriber gets a message.</p><p>Use the <strong class="inline">spin()</strong> function to allow the subscriber to run a <strong class="inline">callback</strong> method. This function generates a loop for the program, which does not end the program:</p><p class="snippet">    rospy.spin()</p><p>Implement the <strong class="inline">callback</strong> function to print a message when it receives any data. For this first exercise, let's kill the subscriber node when receiving the first message from the publisher. This can be done with the <strong class="inline">signal_shutdown</strong> method, which is integrated in <strong class="inline">rospy</strong> and only needs the shutdown reason as a parameter:</p><p class="snippet">def callback(data):</p><p class="snippet">    if(data != None):</p><p class="snippet">        print("Message received")</p><p class="snippet">        rospy.signal_shutdown("Message received")</p><p>Call the created function from the main execution thread:</p><p class="snippet">    if __name__ == '__main__':</p><p class="snippet">        subscriber()</p></li>
				<li>Test the functioning of the created nodes. You can do this as described here:<p>Open a new terminal and switch to your workspace. Then, run the following command so that ROS checks it for executable files:</p><p class="snippet">source devel/setup.bash</p><p>Run the subscriber node. If the implementation is correct, it should remain under execution until you run your publisher:</p><p class="snippet">rosrun exercise20 subscriber.py</p><p>Open a new terminal and enter the command again.</p><p>Run the publisher node:</p><p class="snippet">rosrun exercise20 publisher.py</p><p>If the nodes are well implemented, the subscriber execution ends after executing the publisher node. The output must be the message printed in the callback, in this case: <strong class="inline">Message received</strong>.</p><h4>Note</h4><p class="callout">There is no need to compile the workspace in order to run your package nodes because they are written in Python. If they were coded in C++, you would have to build a package after every change in code.</p></li>
			</ol>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor155"/>Exercise 21: Publishers and Subscribers</h3>
			<p>This exercise is similar to the previous one but is complex. The publisher created before could only send one message per execution. Now, we are going to implement a publisher that won't stop sending data until we terminate it.</p>
			<p>The goal of this exercise is to create a number-finding system following these rules:</p>
			<ul>
				<li>The publisher node must publish random numbers into a topic until it is stopped by the user.</li>
				<li>The subscriber node decides a number to look for and searches for it in the received message list. Here, there are two possibilities:<p>If the number is found before 1000 tries, a positive message will be printed and the number of tries it took to achieve it too.</p><p>If the number is not found in 1000 tries, a negative message will be printed telling the user that it was not possible to find the number.</p><p>So, this can be done in the following way:</p></li>
			</ul>
			<ol>
				<li value="1">As mentioned earlier, begin by creating the package and files:<p class="snippet">cd ~/catkin_ws/src</p><p class="snippet">catkin_create_pkg exercise21 rospy std_msgs</p><p class="snippet">cd exercise21</p><p class="snippet">mkdir scripts</p><p class="snippet">cd scripts</p><p class="snippet">touch generator.py</p><p class="snippet">touch finder.py</p><p class="snippet">chmod +x generator.py finder.py</p></li>
				<li>Begin with the publisher implementation.<p>Import the necessary libraries. These libraries are the same as in the preface, but this time, you must change the <strong class="inline">String</strong> import for <strong class="inline">Int32</strong>, as the node is going to work with numbers. You should also import a random library to generate numbers.</p><h4>Note</h4><p class="callout">This code needs to be added in the <strong class="inline">generator.py</strong> file.</p><p class="snippet">#!/usr/bin/env python</p><p class="snippet">import rospy</p><p class="snippet">from std_msgs.msg import Int32</p><p class="snippet">import random</p></li>
				<li>Create the number generator function:<p class="snippet">def generate():</p></li>
				<li>Declare the publisher and initialize the node as you did in the previous exercise. Note that, this time, the data type is different and the queue size is set to 10, which means that it will be possible to have 10 published numbers. When the eleventh number is published, the first will be dropped from the queue:<p class="snippet">    pub = rospy.Publisher('numbers_topic', Int32, queue_size=10)</p><p class="snippet">    rospy.init_node('generator', anonymous=True)</p></li>
				<li>Configure the rate at which the program loop will iterate. We are setting a rate of 10 (Hz), which is not a very high rate and that will allow us to check the generated numbers:<p class="snippet">    rate = rospy.Rate(10)</p></li>
				<li>Implement the loop where the numbers will be generated and published. It has to iterate until the user stops it, so you can use the <strong class="inline">is_shutdown()</strong> function. Use the sleep function on the declared rate so it can take effect:<p class="snippet">    while not rospy.is_shutdown():</p><p class="snippet">        num = random.randint(1,101)</p><p class="snippet">        pub.publish(num)</p><p class="snippet">        rate.sleep()</p></li>
				<li>Call the created function from the node entry. Use a try directive so that the user shutdown doesn't produce an error:<p class="snippet">if __name__ == '__main__':</p><p class="snippet">    try:</p><p class="snippet">        generate()</p><p class="snippet">    except rospy.ROSInterruptException:</p><p class="snippet">        pass</p></li>
				<li>Continue with the subscriber implementation:<p>Import the necessary libraries.</p><h4>Note</h4><p class="callout">This code needs to be added in the <strong class="inline">finder.py</strong> file.</p><p class="snippet">#!/usr/bin/env python</p><p class="snippet">import rospy</p><p class="snippet">from std_msgs.msg import Int32</p></li>
				<li>Create a class with two attributes: one for establishing the value of the number to find and the other one for counting the number of tries:<p class="snippet">class Finder:</p><p class="snippet">    searched_number = 50</p><p class="snippet">    generated_numbers = 0</p></li>
				<li> Implement the callback function. The logic of the finder has to be coded in this function. There are lots of ways to do this but this is a frequently used one:<p class="snippet">    def callback(self, data):</p><p class="snippet">        if data.data == self.searched_number:</p><p class="snippet">            print(str(data.data) + ": YES")</p><p class="snippet">            self.generated_numbers += 1</p><p class="snippet">            print("The searched number has been found after " + str(self.generated_numbers) + " tries")</p><p class="snippet">            rospy.signal_shutdown("Number found")</p><p class="snippet">        elifself.generated_numbers&gt;= 1000:</p><p class="snippet">print("It wasn't possible to find the searched number")</p><p class="snippet">            rospy.signal_shutdown("Number not found")</p><p class="snippet">else:</p><p class="snippet">            print(str(data.data) + ": NO")</p><p class="snippet">            self.generated_numbers += 1</p><p>As you can see, it is a simple function that looks for the number and adds one to the counter for each failed try. If the number is found, it prints a positive message. If the counter reaches 1000, the search is aborted and a negative message is shown.</p></li>
				<li>Create the function for subscribing. Remember that, this time, the published data type is <strong class="inline">Int32</strong>:<p class="snippet">    def finder(self):</p><p class="snippet">        rospy.init_node('finder', anonymous=True)</p><p class="snippet">        rospy.Subscriber('numbers_topic', Int32, self.callback)</p><p class="snippet">        rospy.spin()</p></li>
				<li>Finally, from the node entry, create a <strong class="inline">Finder</strong> class instance and call the <strong class="inline">finder</strong> method:<p class="snippet">if __name__ == '__main__':</p><p class="snippet">    find = Finder()</p><p class="snippet">    find.finder()</p></li>
				<li>Test whether the performed implementation is correct.<p>Open a new terminal and run <strong class="inline">roscore</strong>.</p><p>Open another terminal and execute the subscriber node:</p><p class="snippet">cd ~/catkin_ws</p><p class="snippet">source devel/setup.bash</p><p class="snippet">rosrun exercise21 finder.py</p></li>
				<li>In another terminal, run the publisher node so that numbers are generated and the callback function starts working:<p class="snippet">cd ~/catkin_ws</p><p class="snippet">source devel/setup.bash</p><p class="snippet">rosrun exercise21 generator.py</p></li>
				<li> If the searched number, 50 in this case, is found, the output should be similar to this one:<div id="_idContainer176" class="IMG---Figure"><img src="image/C13550_06_02.jpg" alt="Figure 6.2: Execution example where the number is found"/></div><h6>Figure 6.2: Execution example where the number is found</h6></li>
				<li>Change the searched number to a value higher than 100 when the number is not found. You should obtain an output as follows:</li>
			</ol>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/C13550_06_03.jpg" alt="Figure 6.3: Execution example where the number is not found"/>
				</div>
			</div>
			<h6>Figure 6.3: Execution example where the number is not found</h6>
			<p>It will be interesting to use the <strong class="inline">rqt_graph</strong> command when both nodes are being executed; this way, you can see the structure you just created graphically. So, open a new terminal and enter the command. The output should be something like this:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/C13550_06_04.jpg" alt="Figure 6.4: Output"/>
				</div>
			</div>
			<h6>Figure 6.4: Output</h6>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor156"/>Simulators</h2>
			<p>Simulators are very good tools for developing and testing robotics software. They make robotics affordable for everyone. Imagine that you are working on a robotics project, where you constantly have to test functionality improvements with your robot. It would require connecting the robot for each test, charging it many times, and moving it with you. All of this can be avoided with a simulator, which can be launched in your computer at any time; it can even simulate the nodes and topics generated by the robot. Do you know any simulator for working with robots?</p>
			<p>We are going to use Gazebo, a simulator included in the ROS full installation. In fact, if you chose this option while installing it, you can write "<strong class="bold">gazebo</strong>" in a terminal and it will launch the simulator. The Gazebo interface is shown in Figure 6.4:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/C13550_06_05.jpg" alt="Figure 6.5: The Gazebo start point"/>
				</div>
			</div>
			<h6>Figure 6.5: The Gazebo start point</h6>
			<p>The next step is to install and set up the robot that we are going to simulate. In this case, we will use a <strong class="bold">Turtlebot</strong>, a wheelie robot that is equipped with sensors such as cameras and lasers. Turtlebot may not be compatible with your ROS distribution (we are using Kinetic Kame); but don't worry, there are lots of robots that you can simulate in Gazebo. You can look up different robots and try to use them with your ROS distribution.</p>
			<h3 id="_idParaDest-117"><a id="_idTextAnchor157"/>Exercise 22: The Turtlebot configuration</h3>
			<p>In this exercise, we are going to go through some things you will need to do before using Turtlebot:</p>
			<ol>
				<li value="1">Install its dependencies:<p class="snippet">sudo apt-get installros-kinetic-turtlebotros-kinetic-turtlebot-apps ros-kinetic-turtlebot-interactions ros-kinetic-turtlebot-simulator ros-kinetic-kobuki-ftdiros-kinetic-ar-track-alvar-msgs</p></li>
				<li>Download the <strong class="inline">Turtlebot</strong> simulator package in your <strong class="inline">catkin</strong> workspace.<h4>Note</h4><p class="callout">If Git is not installed in your local system, use this command to install git: <strong class="inline">sudo apt install git</strong></p><p class="snippet">cd ~/catkin_ws/src</p><p class="snippet">git clone <a href="https://github.com/PacktPublishing/Artificial-Vision-and-Language-Processing-for-Robotics/blob/master/Lesson06/turtlebot_simulator.zip">https://github.com/PacktPublishing/Artificial-Vision-and-Language-Processing-for-Robotics/blob/master/Lesson06/turtlebot_simulator.zip</a></p></li>
				<li>After that, you should be able to use Turtlebot with Gazebo.<p>Start ROS services:</p><p class="snippet">roscore</p><p>Launch Turtlebot World:</p><p class="snippet">cd ~/catkin_ws</p><p class="snippet">source devel/setup.bash</p><p class="snippet">roslaunch turtlebot_gazebo turtlebot_world.launch</p></li>
				<li>Now, you should see the same Gazebo world as before, but with a set of objects, including Turtlebot, at the center, as mentioned in figure 6.5:</li>
			</ol>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/C13550_06_06.jpg" alt="Figure 6.6: The Turtlebot simulation using Gazebo"/>
				</div>
			</div>
			<h6>Figure 6.6: The Turtlebot simulation using Gazebo</h6>
			<p>Once the simulation is correctly running, let's do another exercise for learning how to obtain information from sensors and work with it.</p>
			<h3 id="_idParaDest-118"><a id="_idTextAnchor158"/>Exercise 23: Simulators and Sensors</h3>
			<p>In this exercise, we'll create a ROS node that subscribes to the Turtlebot camera to obtain corresponding images. Follow these steps:</p>
			<ol>
				<li value="1">Create a package with the necessary dependencies and files:<p class="snippet">cd ~/catkin_ws/src</p><p class="snippet">catkin_create_pkg exercise22 rospy sensor_msgs</p><p class="snippet">cd exercise22</p><p class="snippet">mkdir scripts</p><p class="snippet">cd scripts</p><p class="snippet">touch exercise22.py</p><p class="snippet">chmod +x exercise22.py</p></li>
				<li>Implement the node.<p>Import the necessary libraries. For this exercise, we are going to use <strong class="inline">OpenCV</strong> to work with the images obtained from the camera:</p><p class="snippet">#!/usr/bin/env python</p><p class="snippet">import rospy</p><p class="snippet">from sensor_msgs.msg import Image</p><p class="snippet">import cv2</p><p class="snippet">from cv_bridge import CvBridge</p><p>Create a class and declare an attribute of type <strong class="inline">CvBridge</strong>, which will be used later to change the image type to <strong class="inline">cv2</strong>:</p><p class="snippet">class ObtainImage:</p><p class="snippet">    bridge = CvBridge()</p><p>Code the callback function, where you will have to obtain the image and convert it to the cv2 format:</p><p class="snippet">    def callback(self, data):</p><p class="snippet">        cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")</p><p class="snippet">        cv2.imshow('Image',cv_image)</p><p class="snippet">        cv2.waitKey(0)</p><p class="snippet">        rospy.signal_shutdown("Finishing")</p><h4>Note</h4><p class="callout">We use the <strong class="inline">waitKey()</strong> function so that the image remains on the screen. It will disappear when the user presses any key.</p></li>
				<li>Define and implement the subscriber function. Remember that, now, the required data has an Image type:<p class="snippet">    def obtain(self):</p><p class="snippet">            rospy.Subscriber('/camera/rgb/image_raw', Image, self.callback)</p><p class="snippet">            rospy.init_node('image_obtainer', anonymous=True)</p><p class="snippet">            rospy.spin()</p><h4>Note</h4><p class="callout">If you don't know the name of the topic to which you want to subscribe, you can always enter the <strong class="inline">rostopic</strong> list command and check the available nodes. You should see a list like the following:</p><div id="_idContainer181" class="IMG---Figure"><img src="image/C13550_06_07.jpg" alt="Figure 6.7: Output of the rostopic list command"/></div><h6>Figure 6.7: Output of the rostopic list command</h6></li>
				<li>Call the subscriber function from the program entry:<p class="snippet">if __name__ == '__main__':</p><p class="snippet">    obt = ObtainImage()</p><p class="snippet">    obt.obtain()</p></li>
				<li>Check that the node works fine. To do that, you should run <strong class="inline">roscore</strong> command, Gazebo with Turtlebot, and created the node in different terminals. Note that you may also run the <strong class="inline">source devel/setup.bash</strong> source if you didn't do so earlier:<p class="snippet">roscore</p><p class="snippet">roslaunch turtlebot_gazebo turtlebot_world.launch</p><p class="snippet">rosrun exercise22 exercise22.py</p><p>The result should be something like this:</p></li>
			</ol>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/C13550_06_08.jpg" alt="Figure 6.8: The execution example of the exercise node"/>
				</div>
			</div>
			<h6>Figure 6.8: The execution example of the exercise node</h6>
			<h3 id="_idParaDest-119"><a id="_idTextAnchor159"/>Activity 6: Simulators and Sensors</h3>
			<p>Consider the following scenario: you are working for a robotics company that has recently acquired a new client, a security surveillance company. So, you are asked to implement a surveillance system for a robot that guards the store at night. The client wants the robot to stay in the middle of the store and to look around constantly.</p>
			<p>You have to simulate the system and you have been asked to use Turtlebot and Gazebo.</p>
			<ol>
				<li value="1">Implement a node that subscribes to the camera and shows all the images it receives.</li>
				<li>Implement a node for the robot to turn itself on.<h4>Note</h4><p class="callout">To do that, you will have to publish the /mobile_base/commands/velocity topic, which works with Twist messages. Twist is a type of message included in the <strong class="inline">geometry_msgs</strong> library, so you will have to add this as a dependency. To make the robot rotate on itself, create an instance of Twist and modify its <strong class="inline">angular.z</strong> value. Then, publish it.</p></li>
				<li>Now, run both nodes at the same time.<p>At the end of this activity, you will get an output similar to this:</p></li>
			</ol>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/C13550_06_09.jpg" alt="Figure 6.9: The rotating output that shows the images in the virtual environment"/>
				</div>
			</div>
			<h6>Figure <a id="_idTextAnchor160"/>6.9: The rotating output that shows the images in the virtual environment</h6>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 318.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor161"/>Summary</h2>
			<p>In this chapter, you learned how to work with ROS, from its installation and configuration to the implementation of nodes. You also worked with simulators and its sensors, obtaining information from them and making the acquired information valuable for solving problems. All the exercises and activities covered in the chapter will be useful for you in the following chapters.</p>
			<p>In the next chapter, you will work with natural language processing (NPL) and learn how to build a chatbot. If you build a good one, it could be a very interesting tool to add to a robot. You could even use ROS to develop it.</p>
		</div>
	</body></html>