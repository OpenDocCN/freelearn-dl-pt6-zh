- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Fundamentals – Learn How to Code in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is for people who have little or no experience with the Python
    programming language. If you already know how to use `for`/`while` loops, methods, and
    classes in Python, you can skip this chapter and you shouldn't have any problems
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you have not used Python before, or have only barely used it, I
    strongly recommend that you follow this guide. You'll learn how to code the elements
    of Python I mentioned in the previous paragraph, you'll fully understand the codes
    included in this book and you'll be able to code in Python on your own. I'll also
    give you some additional exercises, called "homework" throughout the chapter,
    which I strongly recommend that you do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin, open your Python editor. I recommend using the Google Colab
    notebook, introduced to you as part of your AI Toolkit in the previous chapter.
    All the code, along with homework solutions, are provided on the GitHub page of
    this book in `Chapter 3` in their corresponding section folders. Inside them,
    you will find two Python files: one (named the same as the section) is the code
    used in this book, while the `homework.py` file is the solution to the exercise.
    Instructions for each homework exercise will be provided at the end of each section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` statements and conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` and `while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially if you're starting from scratch, cover each section in the order
    they're presented here, and remember to try your hand at the homework. Let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll begin with the most popular way of introducing any programming language;
    you'll learn how to display some text in the Python console. The console is a
    tool that's part of every Python editor, which shows the information we want or
    displays any errors that occurred (let's hope not to get any!).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to show something in our console is to use the `print()` method,
    just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The text above `print`, starting with `#`, is called a comment. Comments are
    excluded when executing code and are only visible to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this short code in Google Colab, you''ll see this displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, just put what you want to display into the brackets of the `print`
    method – text surrounded by quotes, as in this example, or variables.
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious about what variables are, that's great – you'll learn about
    them after this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using only one `print()` method, try to display two or more lines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: Try using the `\n` symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/Displaying Text/homework.py` file
    on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables are simply values that are allocated somewhere in the memory of our
    computer. They are similar to variables in mathematics. They can be anything:
    text, integers, or floats (a number with precision after the decimal point, such
    as 2.33).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new variable, you only need to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have named a variable `x` and set its value to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in mathematics, you can perform some operations on these variables. The
    most common operations are addition, subtraction, multiplication, and division.
    The way to write them in Python is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you look at it for the first time, it doesn't make much sense—how can we
    write that `x = x + 5`?
  prefs: []
  type: TYPE_NORMAL
- en: In Python, and in most code, the "=" notation doesn't mean the two terms are
    equal. It means that we associate the new `x` value with the value of the old
    `x`, plus 5\. It is crucial to understand that this is not an equation, but rather
    the creation of a new variable with the same name as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: You can also write these operations as shown on the right side, in the comments.
    You'll usually see them written in this way, since it's more space efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also perform these operations on other variables, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new variable `y` and set it to `3`. Then, we added it to
    our existing `x`. Also, `x` will be displayed when you run this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does `x` turn out to be after all these operations? If you run the
    code, you''ll get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you calculate these operations by hand, you will see that `x` does indeed
    equal `6.33`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to find a way to raise one number to the power of another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: Try using the `pow()` built-in function for Python.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/Variables/homework.py` file on the
    GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists and arrays can be represented with a table. Imagine a **one-dimensional**
    (**1D**) vector or a matrix, and you have just imagined a list/array.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and arrays can contain data in them. Data can be anything – variables,
    other lists or arrays (these are called multi-dimensional lists/arrays), or objects
    of some classes (we will learn about them later).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a 1D list/array containing integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is an example of a **two-dimensional** (**2D**) list/array, also containing
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to create a 2D list, you have to create a list of lists. Creating
    a list is very simple, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create four lists: `L1`, `L2`, `L3` and `L4`. The first two lists are
    empty – they have zero elements. The two subsequent lists have some predefined
    values in them. `L3` is a one-dimensional list, same as the one in the first image.
    `L4` is a two-dimensional list, the same as in the second image. As you can see,
    `L4` actually consists of three smaller 1D lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I mention an array, I usually mean a "NumPy" array. NumPy is a Python
    library (a library is a collection of pre-coded programs that allows you to perform
    many actions without writing your code from scratch), widely used for list/array
    operations. You can think of a NumPy array as a special kind of list, with lots
    of additional functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a NumPy array, you have to specify a size and use an initialization
    method. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we import the NumPy library (as you can see, to import a
    library, you need to write `import`) and by using `as,` we give NumPy the abbreviation
    `np` to make it easier to use. Then, we create a new array that we call `nparray`,
    which is a 2D array of size 5 x 5, full of zeros. The initialization method is
    the part after the `.`; in this case, we initialize this array as full of zeros,
    by using the function `zeros`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get access to the values in a list or array, you need to give the
    index of this value. For example, if you wanted to change the first element in
    the `L3` list, you would have to get its index. In Python, indexes start at `0`,
    so you would need to write `L3[0]`. In fact, you can write `print(L3[0])`and execute
    it, and you will see that, as you might hope, the number `3` will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a single value in a multi-dimensional list/array requires you to input
    as many indexes as there are dimensions. For example, to get `0` from our `L4`
    list, we would have to write `L4[1][1]`. `L4[1]` would return the entire second
    row, which is a list.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to find the mean of all the numbers in the `L4` list. There are multiple
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: The simplest solution makes use of the NumPy library. Check out some
    of its functions here: [https://docs.scipy.org/doc/numpy/reference/](https://docs.scipy.org/doc/numpy/reference/)'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/Lists and Arrays/homework.py` file
    on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: if statements and conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now I would like to introduce you to a very useful tool in programming – `if` conditions!
  prefs: []
  type: TYPE_NORMAL
- en: They are widely used to check whether a statement is true or not. If the given
    statement is true, then some instructions for our code are followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll present this subject to you with some simple code that will tell us whether
    a number is positive, negative, or equal to 0\. The code''s very short, so I''ll
    show you all of it at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we introduce a new variable called `a` and we give it a value
    of `5`. This is the variable whose value we are going to check.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line we check if this variable is greater than `0`. We do this by
    using an `if` condition. If `a` is greater than `0`, then we follow the instructions
    written in the indented block; in this case, it is only displaying the message
    `a is greater than 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if the first condition fails, that is, if `a` is lower than or equal
    to `0`, we go to the next condition, which is introduced with `elif` (which is
    short for `else if`). This statement will check whether `a` is equal to zero or
    not. If it is, we follow the indented instruction, which will display a message
    displaying: `a is equal to 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: The final condition is introduced via `else`. Instructions included in an `else`
    condition will always be followed when all other conditions fail. In this case,
    failing both conditions would mean that `a` < `0`, and therefore we would display
    `a is lower than 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to predict what our code will return. It will be the first instruction,
    `print(''a is greater than 0'')`. And, in fact, once you run this code, this is
    what you will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In brief, `if` is used to introduce statement checking and the first condition,
    `elif` is used to check as many further conditions as we want, and `else` is a
    true statement when all other statements fail.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to know that once one condition is true, no other conditions
    are checked. So, in this case, once we enter the first condition and we see that
    it is true, we no longer check other statements. If you would like to check other
    conditions, you would need to replace the `elif` and `else` statements with new
    `if` statements. A new `if` always checks a new condition; therefore, a condition
    included in an `if` is always checked.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Build a condition that will check if a number is divisible by 3 or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: You can use a mathematical expression called modulo, which when used,
    returns the remainder from the division between two numbers. In Python, modulo
    is represented by `%`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 % 3 = 2
  prefs: []
  type: TYPE_NORMAL
- en: 71 % 5 = 1
  prefs: []
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/If Statements/homework.py` file
    on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: for and while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of a loop as continuously repeating the same instructions over
    and over until some condition is satisfied that breaks this loop. For example,
    the previous code was not a loop; since it was only executed once, we only checked
    `a` once.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of loops in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops have a specific number of iterations. You can think of an iteration
    as a single execution of the specific instructions included in the `for` loop.
    The number of iterations tells the program how many times the instruction inside
    the loop should be performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you create a for loop? Simply, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We initialize this loop by writing `for` to specify the type of loop. Then we
    create a variable `i,` that will be associated with integer values from `range
    (1,20)`. This means that when we enter this loop for the first time, `i` will
    be equal to `1`, the second time it will be equal to `2`, and so on, all the way
    to `19`. Why `19`? That's because in Python, upper bounds are excluded, so at
    the final iteration `i` will be equal to `19`. As for our instruction, in this
    case it's just showing the current `i` in our console by using the `print()` method.
    It's also important to understand that the main code does not progress until the
    for loop is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we get once we execute our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our code displayed every integer higher than 0 and lower than
    20.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a `for` loop to iterate through elements of a list, in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we come back to our `L3` 1D list. This code iterates through every element
    in the `L3` list and displays it. If you run it, you will see all the elements
    of this array from `3` to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loops, on the other hand, need a condition to stop. They go on as long
    as the given condition is satisfied. Take this `while` loop, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new variable called `stop`. This type of variable is called
    a bool, since it can be assigned only two values – `True` or `False`. Then, we
    create a variable called `i` that we'll use to count how many times our `while`
    loop is executed. Next, we create a `while` loop that will go on as long as the
    variable `stop` is `False`; only once `stop` is changed to `True` will the loop
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop, we increase `i` by 1, display it, and check if it is greater or
    equal to `19`. If it is greater or equal to `19`, we change `stop` to `True`;
    and as soon as we change `stop` to `True`, the loop will break!
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing this code, you will see the exact same output as in the `for`
    loop example, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also very important to know that you can stack `for` and `while` loops
    inside each other. For example, to display all the elements from the 2D list `L4`
    we created previously, one after another, you would have to make one `for` loop
    that iterates through every row, and then another `for` loop (inside the previous
    one) that iterates through every value in this row. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And running this yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This matches the `L4` list.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, `for` and `while` loops let us perform repetitive tasks with
    ease. `for` loops always work on a predefined range; you know exactly when they
    will stop. `while` loops work on an undefined range; just by looking at their
    `stop` condition, you may not be able to judge how many iterations will happen.
    `while` loops work as long as their particular condition is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Build both `for` and `while` loops that can calculate the factorial of a positive
    integer variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: Factorial is a mathematical function that returns the product of
    all positive integers lower or equal to the argument of this function. This is
    the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*n*) = *n* * (*n* – 1) * (*n* – 2) *...* 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*n*) – the factorial function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* – the integer in question, the factorial of which we are searching for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function is represented by `!` in mathematics, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 5! = 5 * 4 * 3 * 2 * 1 = 120
  prefs: []
  type: TYPE_NORMAL
- en: 4! = 4 * 3 * 2 * 1 = 24
  prefs: []
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/For and While Loops/homework.py`
    file on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are incredibly useful when you want to increase code readability.
    You can think of them as blocks of code outside the main flow of code. Functions
    are executed once they are called in the main code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines are a newly created function called `division`, and the
    last two lines are part of the main code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a function by writing `def` and then writing the function''s
    name. After the name, you put brackets and within them write the arguments of
    the function; these are some variables that you will be able to use inside of
    your function and are a part of the connection between the main code and the function.
    In this case, our function takes two arguments: `a` and `b`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, once we enter our function, what we do is calculate `a` divided by `b`
    and call this division `result`. Then, in the last line of our function, we say
    `return` so that when we call this function in code, it will return a value. In
    this case, the returned value is `result`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we go back to our main code and call our function. We do that by writing
    `division` and then in the brackets we input two numbers that we would like to
    divide. Remember, the `division` function returns a `result` of this division;
    therefore, we create a variable, `d`, that will hold this returned value. In the
    last line, we simply display `d` to see whether this code really works. If you
    run it, you''ll get the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can confirm by hand, 3 divided by 5 is indeed 0.6; you can test it on
    other numbers as well.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world code, functions can be much longer, and sometimes even call other
    functions. You will see them used a lot, even in the other chapters of this book.
    They also increase code readability, as you will see later; the code I've provided
    would be impossible to understand without functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Build a function to calculate the distance between two points on an *x,y* plane:
    one with coordinates `x1` and `y1`, and the other with coordinates `x2` and `y2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: You can use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_03_001.png)'
  prefs: []
  type: TYPE_IMG
- en: The solution is provided in the `Chapter 03/Functions/homework.py` file on the
    GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes, like functions, are another part of code that sits outside of the main
    code, executed only when called in the main flow of code. Objects are instances
    of a corresponding class, existing within the main flow of our code. To better
    understand it, think of a class as a plan of something, for example, a plan of
    a car. It contains information on how certain components look and work with each
    other. A class in Python is a general plan of something.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of objects as real-life constructions based on the plan. For example,
    a real, working, and self-driving car would be an example of an object. You create
    a plan of a car (which is a class) and then you build a car based on this plan
    (which is an object). And of course, when you have a plan of something, you can create
    as many copies as you want; for example, you can run a production line to produce cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you more insight into classes, we will create a simple bot. We begin
    with writing a class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We write `class` to specify that we are creating a new class, which we name
    `Bot`. Then, a very important step is to write an `__init__()` method, which is
    a necessity when creating a class. This function is called automatically whenever
    an object of this class is created in the main flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: All functions in a class need to take `self` as one argument. So, what is `self`?
    This parameter specifies that this function and its variables, whose names are
    preceded by `self`, are a part of this class. We will be able to call the `self`
    variables once we have an object of this class. Our bot's `__init__()` method
    also takes two arguments, `posx` and `posy`, which will be the initial position
    of our bot.
  prefs: []
  type: TYPE_NORMAL
- en: We have also created a method that will move our bot, by increasing or decreasing
    its `posx` and `posy`. A method is a function tucked inside a class. You can think
    of it as an instruction on how something has to work when we have a plan. For
    example, going back to the example of a car, a method could define the way our
    engine or gearbox works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can create an object of this class. Remember, this will be a real-life
    object, constructed on the basis of a plan (`class`). Before, the class was predefined
    and didn''t work along with your code. After you create an object, the class becomes
    an integral part of your main code. We can achieve this by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new object of class `Bot`; we called this object `bot`. We
    also need to specify the two arguments that the `__init__()` method of class `Bot`
    takes, which are `posx` and `posy`. This isn't optional; when creating an object,
    you always have to specify all the arguments given in the `__init__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the main code, you can move the bot and display its new position, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we use the `move` method from our `Bot` class. As you can
    see in its definition, `move` takes two arguments. These two arguments specify,
    respectively, by how much we will increase `posx` and `posy`. Then we just display
    the new `posx` and `posy`. This is where `self` comes into action; if the variables
    `posx` and `posy` were not preceded by `self` in our `Bot` class, we wouldn''t
    have access to them via the method. Running this code gives us this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the result, our bot moved two units forward on the *x* axis
    and one unit backward on the *y* axis. Remember, `posx` was set to `3` initially
    and has now been increased by `2` using the `move` method from the `Bot` class;
    `posy` was set to `4` initially and has now been decreased by `1`, with the use
    of the same `move` method.
  prefs: []
  type: TYPE_NORMAL
- en: One great advantage of taking the time to code a `Bot` class is that now we
    are able to create as many bots as we want without making our code any longer.
    Simply put, objects are copies of a class and we can create as many of them as
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, you can think of a class as a collection of predefined instructions
    and closed in methods, and you can think of an object as an instance of this class
    that is accessible in our code and that runs along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your final challenge will be to build a very simple car class. As arguments,
    a car object should take the maximum velocity at which the car can move (unit
    in m/s), as well as the acceleration at which the car is accelerating (unit in
    m/s²). I also challenge you to build a method that will calculate the time it
    will take for the car to accelerate from the current speed to the maximum speed,
    knowing the acceleration (use the current speed as the argument of this method).
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: To calculate the time required, you can use the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_03_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14110_03_003.png) – time required to achieve the top speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B14110_03_004.png) – maximum speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B14110_03_005.png) – current speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B14110_03_006.png) – acceleration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution is provided in the `Chapter 03/Classes/homework.py` file on the
    GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we covered the Python fundamentals that you'll need to keep
    up with the code presented in this book, from sending a simple text display to
    the console to writing your very first class in Python. You've now got all the
    skills you need to continue on your AI journey; in *Chapter 4*, *AI Foundation
    Techniques*, we will begin to study the foundational techniques of AI.
  prefs: []
  type: TYPE_NORMAL
